{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Why? \u00b6 Using org-roam , mkdocs-material , I can generate a website to search for my idea, using the zettelkasten methods. Org mode is great for authoring, but I do prefer some nice font and a good navigation, search navigation. mkdocs-material offered a great compromise and orgmk allowed me to have a command line conversion. Clojure allowed to handle all the files systems, interaction with the sqlite database, the parsing and the concurrency. I came up with my own set up, cards for writing anything that goes into my minds, links them and decks for writing summaries. Blog posts are a place where I can write some ideas and opinions to share them. Technical challenge \u00b6 I created some functions to leverage the org-roam.db sqlite data base. With my own starting template, the code reads the tags and the links, such that automatic see also are created at the end of each page. See org-roam-clj on how to use the library. Small index for quick access \u00b6 Programming \u00b6 clj , core.async . See also (generated) \u00b6","title":"Why?"},{"location":"#why","text":"Using org-roam , mkdocs-material , I can generate a website to search for my idea, using the zettelkasten methods. Org mode is great for authoring, but I do prefer some nice font and a good navigation, search navigation. mkdocs-material offered a great compromise and orgmk allowed me to have a command line conversion. Clojure allowed to handle all the files systems, interaction with the sqlite database, the parsing and the concurrency. I came up with my own set up, cards for writing anything that goes into my minds, links them and decks for writing summaries. Blog posts are a place where I can write some ideas and opinions to share them.","title":"Why?"},{"location":"#technical-challenge","text":"I created some functions to leverage the org-roam.db sqlite data base. With my own starting template, the code reads the tags and the links, such that automatic see also are created at the end of each page. See org-roam-clj on how to use the library.","title":"Technical challenge"},{"location":"#small-index-for-quick-access","text":"","title":"Small index for quick access"},{"location":"#programming","text":"clj , core.async .","title":"Programming"},{"location":"#see-also-generated","text":"","title":"See also (generated)"},{"location":"todo/","text":"TOOD List \u00b6 This Todo file is a simple example of what I still have to learn or do. These are the goals I would like to reach or interest me. Highly important \u00b6 Read \u00b6 how to write notes efficiently. org journal, org-roam-server. git subrepositories (for multiple projects). Check how org gather indices properties. pods in babashka. Write \u00b6 Simple made easy test.check and generative testing Idea \u00b6 Check sha1 in converting org files (because it is super slow otherwise) org-roam-clj Download clojure.core and use materiala for testing. Materiala Fork marginalia parser and correct its bug: parser Goals \u00b6 specs, core.async, datomic, testing. Kubernetes, container technology. Webworkers and websockets. GPU computing GraphQL Spark Kafka Learn about databases (postgres, elastic search and datomic). SICP, Read data science and algorithm manual. TODO Read Advanced Data Analysis from an elementary point of view \u00b6 Advanced data analysis from an elementary point of view Multipass and Ansible \u00b6 Use multipass and Ansible to simulate networks and kubernetes. Learn CSS \u00b6 Write a summary (check create of Bulma) cljss , woolybear Leverage indices and org-parser \u00b6 Check whether we can use indices to create better indexing. Use pods and sqlite to leverage on the org-roam and extend it to markdown. See also (generated) \u00b6","title":"TOOD List"},{"location":"todo/#tood-list","text":"This Todo file is a simple example of what I still have to learn or do. These are the goals I would like to reach or interest me.","title":"TOOD List"},{"location":"todo/#highly-important","text":"","title":"Highly important"},{"location":"todo/#read","text":"how to write notes efficiently. org journal, org-roam-server. git subrepositories (for multiple projects). Check how org gather indices properties. pods in babashka.","title":"Read"},{"location":"todo/#write","text":"Simple made easy test.check and generative testing","title":"Write"},{"location":"todo/#idea","text":"Check sha1 in converting org files (because it is super slow otherwise) org-roam-clj Download clojure.core and use materiala for testing. Materiala Fork marginalia parser and correct its bug: parser","title":"Idea"},{"location":"todo/#goals","text":"specs, core.async, datomic, testing. Kubernetes, container technology. Webworkers and websockets. GPU computing GraphQL Spark Kafka Learn about databases (postgres, elastic search and datomic). SICP, Read data science and algorithm manual.","title":"Goals"},{"location":"todo/#todo-read-advanced-data-analysis-from-an-elementary-point-of-view","text":"Advanced data analysis from an elementary point of view","title":"TODO Read Advanced Data Analysis from an elementary point of view"},{"location":"todo/#multipass-and-ansible","text":"Use multipass and Ansible to simulate networks and kubernetes.","title":"Multipass and Ansible"},{"location":"todo/#learn-css","text":"Write a summary (check create of Bulma) cljss , woolybear","title":"Learn CSS"},{"location":"todo/#leverage-indices-and-org-parser","text":"Check whether we can use indices to create better indexing. Use pods and sqlite to leverage on the org-roam and extend it to markdown.","title":"Leverage indices and org-parser"},{"location":"todo/#see-also-generated","text":"","title":"See also (generated)"},{"location":"blog/20200502171331-first_blog_ticket/","text":"First blog ticket \u00b6 Written on 2020-05-02. Voil\u00e0! The start of a new blog! Probably like all blogs, this one will remain probably empty, without a lot of content. I just created this website to gather my notes and find a system that can make leverage of all the ideas. I think the zettelkasten method is interesting and I decided to try it. Please read the README for more details! See also (generated) \u00b6 <../README.md>","title":"First blog ticket"},{"location":"blog/20200502171331-first_blog_ticket/#first-blog-ticket","text":"Written on 2020-05-02. Voil\u00e0! The start of a new blog! Probably like all blogs, this one will remain probably empty, without a lot of content. I just created this website to gather my notes and find a system that can make leverage of all the ideas. I think the zettelkasten method is interesting and I decided to try it. Please read the README for more details!","title":"First blog ticket"},{"location":"blog/20200502171331-first_blog_ticket/#see-also-generated","text":"<../README.md>","title":"See also (generated)"},{"location":"cards/20200430141226-life_in_dynamic_typing/","text":"Life In Dynamic Typing \u00b6 tags: Clojure In dynamic typed language, assertions are used often to check assumption of your input data. In Clojure the :pre and :post conditions can be used effectively to fill this purpose. ( defn f [ x ] { :pre [( integer? x )] :post string? } ( str x )) {:elide-asserts true} in production build compiler options to remove :pre and :post assertions in your code. Source \u00b6 http://swannodette.github.io/2015/01/09/life-with-dynamic-typing/ See also (generated) \u00b6 <../decks/clojure.md> <20200430141609-david_nolen.md> <20200430154647-shadow_cljs.md> <20200430155438-mastering_clojure_macro.md> <20200430155637-applied_clojure.md> <20200430160432-clojure_for_the_brave_and_the_true.md> <20200430235013-specs.md>","title":"Life In Dynamic Typing"},{"location":"cards/20200430141226-life_in_dynamic_typing/#life-in-dynamic-typing","text":"tags: Clojure In dynamic typed language, assertions are used often to check assumption of your input data. In Clojure the :pre and :post conditions can be used effectively to fill this purpose. ( defn f [ x ] { :pre [( integer? x )] :post string? } ( str x )) {:elide-asserts true} in production build compiler options to remove :pre and :post assertions in your code.","title":"Life In Dynamic Typing"},{"location":"cards/20200430141226-life_in_dynamic_typing/#source","text":"http://swannodette.github.io/2015/01/09/life-with-dynamic-typing/","title":"Source"},{"location":"cards/20200430141226-life_in_dynamic_typing/#see-also-generated","text":"<../decks/clojure.md> <20200430141609-david_nolen.md> <20200430154647-shadow_cljs.md> <20200430155438-mastering_clojure_macro.md> <20200430155637-applied_clojure.md> <20200430160432-clojure_for_the_brave_and_the_true.md> <20200430235013-specs.md>","title":"See also (generated)"},{"location":"cards/20200430141609-david_nolen/","text":"David Nolen \u00b6 ClojureScript (cljs) lead developer Defn episode 60 \u00b6 React achieve a local maximum in UI development. Functional way of creating UI (25 years after MVC). Change will be incremental from now on probably. :bundle target in cljs allows to defer packaging problem to building tools from javascript. dart might be used a future target for clojurescript. Source \u00b6 https://soundcloud.com/defn-771544745/60-4th-anniversary-episode-return-of-david-nolen-aka-swannodette Rethinking Identity with Clojure \u00b6 Clojure specs is data specification mechanism and can be shared between programs. It complex constructor and type (type checking on the language construct, the constructor) [whereas we can share specifications]. The set of specifications (the body of specification) can be used everywhere. Find the sources of complexity. Designing and simplify concepts by keeping independents one separate. Complexity will be felt all the way down to the user and provides a bad UX. Hyperledger fabric for block chain. Rich Hickey is a good way for learning decomplicting. Source \u00b6 Rethinking Identity with Clojure Gerry Sussman - We Really Don\u2019t Know How to Compute! Links \u00b6 http://swannodette.github.io/ See also (generated) \u00b6 <../decks/clojure.md> <20200430141226-life_in_dynamic_typing.md> <20200430154647-shadow_cljs.md> <20200430155438-mastering_clojure_macro.md> <20200430155637-applied_clojure.md> <20200430160432-clojure_for_the_brave_and_the_true.md>","title":"David Nolen"},{"location":"cards/20200430141609-david_nolen/#david-nolen","text":"ClojureScript (cljs) lead developer","title":"David Nolen"},{"location":"cards/20200430141609-david_nolen/#defn-episode-60","text":"React achieve a local maximum in UI development. Functional way of creating UI (25 years after MVC). Change will be incremental from now on probably. :bundle target in cljs allows to defer packaging problem to building tools from javascript. dart might be used a future target for clojurescript.","title":"Defn episode 60"},{"location":"cards/20200430141609-david_nolen/#source","text":"https://soundcloud.com/defn-771544745/60-4th-anniversary-episode-return-of-david-nolen-aka-swannodette","title":"Source"},{"location":"cards/20200430141609-david_nolen/#rethinking-identity-with-clojure","text":"Clojure specs is data specification mechanism and can be shared between programs. It complex constructor and type (type checking on the language construct, the constructor) [whereas we can share specifications]. The set of specifications (the body of specification) can be used everywhere. Find the sources of complexity. Designing and simplify concepts by keeping independents one separate. Complexity will be felt all the way down to the user and provides a bad UX. Hyperledger fabric for block chain. Rich Hickey is a good way for learning decomplicting.","title":"Rethinking Identity with Clojure"},{"location":"cards/20200430141609-david_nolen/#source_1","text":"Rethinking Identity with Clojure Gerry Sussman - We Really Don\u2019t Know How to Compute!","title":"Source"},{"location":"cards/20200430141609-david_nolen/#links","text":"http://swannodette.github.io/","title":"Links"},{"location":"cards/20200430141609-david_nolen/#see-also-generated","text":"<../decks/clojure.md> <20200430141226-life_in_dynamic_typing.md> <20200430154647-shadow_cljs.md> <20200430155438-mastering_clojure_macro.md> <20200430155637-applied_clojure.md> <20200430160432-clojure_for_the_brave_and_the_true.md>","title":"See also (generated)"},{"location":"cards/20200430153912-ethz/","text":"ETHZ \u00b6 Lectures \u00b6 DONE Projects [3/3] \u00b6 [X] Semester paper in economics : Public Employment [X] Write e-mail. [X] Decide subject and write about it. [X] Read papers [X] Do the regression [X] Semester paper in statistics: Missing data [X] Read introduction missing data. [X] Play with mi. [X] Use Digital Ocean API in R. [X] Master thesis [X] Webapp to teach math in clojure and middleman yaml DONE Causality [2/2] \u00b6 I had 5.75 (kind of deserved). PDAG: Partially means no directed cycle whereas DAG means no cycle at all. CPDAG (Markov Equivalent Graphs): for every directed node, all graph have the same edge. For undirected edges, there exist at least two graphs with opposite direction of the edge. Markov equivalent if they have the same skeleton and immoralities (v-struct). D-separation \\to \\to Blocked Reverse engineer the definition by thinking about the independence Markov blanket M M : for a target node Y Y , it is smallest set M M of nodes in the graphs that make Y Y independent of all the other nodes given M M . In DAG: for X X it contains its parents, its children and the parents of children. Causal minimality: P^X P^X is not markov to any proper subgraph of \\mathcal{G} \\mathcal{G} if and only if there are no useless edge. Markov: conditional d-sep \\Rightarrow \\Rightarrow independence, faithfulness is the converse. Local: X X is independent of any non descendent given its parnets. Adjustment formula (tautology): the conditional probability given the parents remains the same under the interventions. The goal adjustment set: evaluate interventions or causality with observational data. Valid adjustment set Z Z : p_{\\mathcal{S}, do(X=x)}(y) = \\sum_{z \\in Z} p_{\\mathcal{S}}(y \\vert X=x, z) p(z) p_{\\mathcal{S}, do(X=x)}(y) = \\sum_{z \\in Z} p_{\\mathcal{S}}(y \\vert X=x, z) p(z) for y y not in the parent of x x and x, y \\notin Z x, y \\notin Z . Backdoor criterion: S S blocks all paths from X X to Y Y that come \\emph{into} X X (backward path) and S S contains no descendant of X X . DONE QRM [3/3] \u00b6 <2015-08-18 Tue> Know the main theorems by heart: Fisher-Tippet, Pickands-Balkema-de Hann, Sklar. 5.5/6 [X] Read slides [X] Learn slides by heart [X] Do past exams DONE Multivariate Statistics [2/2] \u00b6 I had 4.5/6 (which was not deserved at all). [X] Do exercises [X] Serie 1 [X] Serie 2 [X] Serie 3 [X] Serie 4 [X] Serie 5 [X] Read scripts DONE Computational Statistics, finish the series [2/2] \u00b6 <2015-08-18 Tue> I got 6 (was a little bit easy, thanks to emacs and R-help). [X] Do Series [X] Read script DONE Economics Cycle [2/2] \u00b6 <2015-06-09 Tue> I had 4.75/6 at the exam. [X] Read scripts [X] Do Exercise See also (generated) \u00b6","title":"ETHZ"},{"location":"cards/20200430153912-ethz/#ethz","text":"","title":"ETHZ"},{"location":"cards/20200430153912-ethz/#lectures","text":"","title":"Lectures"},{"location":"cards/20200430153912-ethz/#done-projects-33","text":"[X] Semester paper in economics : Public Employment [X] Write e-mail. [X] Decide subject and write about it. [X] Read papers [X] Do the regression [X] Semester paper in statistics: Missing data [X] Read introduction missing data. [X] Play with mi. [X] Use Digital Ocean API in R. [X] Master thesis [X] Webapp to teach math in clojure and middleman yaml","title":"DONE Projects [3/3]"},{"location":"cards/20200430153912-ethz/#done-causality-22","text":"I had 5.75 (kind of deserved). PDAG: Partially means no directed cycle whereas DAG means no cycle at all. CPDAG (Markov Equivalent Graphs): for every directed node, all graph have the same edge. For undirected edges, there exist at least two graphs with opposite direction of the edge. Markov equivalent if they have the same skeleton and immoralities (v-struct). D-separation \\to \\to Blocked Reverse engineer the definition by thinking about the independence Markov blanket M M : for a target node Y Y , it is smallest set M M of nodes in the graphs that make Y Y independent of all the other nodes given M M . In DAG: for X X it contains its parents, its children and the parents of children. Causal minimality: P^X P^X is not markov to any proper subgraph of \\mathcal{G} \\mathcal{G} if and only if there are no useless edge. Markov: conditional d-sep \\Rightarrow \\Rightarrow independence, faithfulness is the converse. Local: X X is independent of any non descendent given its parnets. Adjustment formula (tautology): the conditional probability given the parents remains the same under the interventions. The goal adjustment set: evaluate interventions or causality with observational data. Valid adjustment set Z Z : p_{\\mathcal{S}, do(X=x)}(y) = \\sum_{z \\in Z} p_{\\mathcal{S}}(y \\vert X=x, z) p(z) p_{\\mathcal{S}, do(X=x)}(y) = \\sum_{z \\in Z} p_{\\mathcal{S}}(y \\vert X=x, z) p(z) for y y not in the parent of x x and x, y \\notin Z x, y \\notin Z . Backdoor criterion: S S blocks all paths from X X to Y Y that come \\emph{into} X X (backward path) and S S contains no descendant of X X .","title":"DONE Causality [2/2]"},{"location":"cards/20200430153912-ethz/#done-qrm-33","text":"<2015-08-18 Tue> Know the main theorems by heart: Fisher-Tippet, Pickands-Balkema-de Hann, Sklar. 5.5/6 [X] Read slides [X] Learn slides by heart [X] Do past exams","title":"DONE QRM [3/3]"},{"location":"cards/20200430153912-ethz/#done-multivariate-statistics-22","text":"I had 4.5/6 (which was not deserved at all). [X] Do exercises [X] Serie 1 [X] Serie 2 [X] Serie 3 [X] Serie 4 [X] Serie 5 [X] Read scripts","title":"DONE Multivariate Statistics [2/2]"},{"location":"cards/20200430153912-ethz/#done-computational-statistics-finish-the-series-22","text":"<2015-08-18 Tue> I got 6 (was a little bit easy, thanks to emacs and R-help). [X] Do Series [X] Read script","title":"DONE Computational Statistics, finish the series [2/2]"},{"location":"cards/20200430153912-ethz/#done-economics-cycle-22","text":"<2015-06-09 Tue> I had 4.75/6 at the exam. [X] Read scripts [X] Do Exercise","title":"DONE Economics Cycle [2/2]"},{"location":"cards/20200430153912-ethz/#see-also-generated","text":"","title":"See also (generated)"},{"location":"cards/20200430154352-cli_arguments/","text":"CLI Arguments \u00b6 Check how to use cli arguments for release scripts. ( require ' [ clojure.tools.cli :refer [ parse-opts ]]) ( def cli-options ;; An option with a required argument [[ \"-p\" \"--port PORT\" \"Port number\" :default 80 :parse-fn # ( Integer/parseInt % ) :validate [ # ( < 0 % 0 x10000 ) \"Must be a number between 0 and 65536\" ]] [ \"-h\" \"--help\" ]]) ( :options ( parse-opts *command-line-args* cli-options )) See also (generated) \u00b6 <../decks/clojure.md> <20200430154528-multiple_environment.md> <20200430155438-mastering_clojure_macro.md> <20200430155637-applied_clojure.md> <20200430160432-clojure_for_the_brave_and_the_true.md> <20200503165952-materiala.md> <20200505124946-clj_toolkit.md>","title":"CLI Arguments"},{"location":"cards/20200430154352-cli_arguments/#cli-arguments","text":"Check how to use cli arguments for release scripts. ( require ' [ clojure.tools.cli :refer [ parse-opts ]]) ( def cli-options ;; An option with a required argument [[ \"-p\" \"--port PORT\" \"Port number\" :default 80 :parse-fn # ( Integer/parseInt % ) :validate [ # ( < 0 % 0 x10000 ) \"Must be a number between 0 and 65536\" ]] [ \"-h\" \"--help\" ]]) ( :options ( parse-opts *command-line-args* cli-options ))","title":"CLI Arguments"},{"location":"cards/20200430154352-cli_arguments/#see-also-generated","text":"<../decks/clojure.md> <20200430154528-multiple_environment.md> <20200430155438-mastering_clojure_macro.md> <20200430155637-applied_clojure.md> <20200430160432-clojure_for_the_brave_and_the_true.md> <20200503165952-materiala.md> <20200505124946-clj_toolkit.md>","title":"See also (generated)"},{"location":"cards/20200430154528-multiple_environment/","text":"Multiple environments \u00b6 We can have different class paths for configuration with clj and alias in deps.edn to manage them. Proxies: you add in ~.shadow-cljs/config.edn or in the config file { :maven { :proxy { :host \"proxy.host.com\" :port 8080 }}} tags: clj build See also (generated) \u00b6 <../decks/clojure.md> <20200430154352-cli_arguments.md> <20200430155438-mastering_clojure_macro.md> <20200430155637-applied_clojure.md> <20200430160432-clojure_for_the_brave_and_the_true.md> <20200503165952-materiala.md>","title":"Multiple environments"},{"location":"cards/20200430154528-multiple_environment/#multiple-environments","text":"We can have different class paths for configuration with clj and alias in deps.edn to manage them. Proxies: you add in ~.shadow-cljs/config.edn or in the config file { :maven { :proxy { :host \"proxy.host.com\" :port 8080 }}} tags: clj build","title":"Multiple environments"},{"location":"cards/20200430154528-multiple_environment/#see-also-generated","text":"<../decks/clojure.md> <20200430154352-cli_arguments.md> <20200430155438-mastering_clojure_macro.md> <20200430155637-applied_clojure.md> <20200430160432-clojure_for_the_brave_and_the_true.md> <20200503165952-materiala.md>","title":"See also (generated)"},{"location":"cards/20200430154647-shadow_cljs/","text":"shadow-cljs \u00b6 NGINX Configuration for developping locally \u00b6 Install nginx on your remote server and place this file into your configuration. server { listen 80 default_server; listen [::]:80 default_server; root /var/www/html; server_name _; location / { proxy_pass http://localhost:8080/; try_files $uri $uri/a 404; } location /shadow-cljs/ { # upgrade to websocket proxy_pass http://localhost:9630/; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"Upgrade\"; proxy_set_header Host $host; } } Open the ports: `sudo ufw 8080` and `sudo ufw 9630`. Connect directly to the ip/domain of the server with the correct ports. Inspect \u00b6 Inject the correct namespaces with :devtools preloads in the shadow-cljs.edn config file. { :devtools { :preloads [ shadow.remote.runtime.cljs.browser ;; shadow.remote.runtime.cljs.node ;; for nodejs ]}} Inspect with Clojure and not only ClojureScript ( require ' [ shadow.cljs.devtools.server :as server ]) ( server/start! ) ( tap> :hello ) Devcards \u00b6 For devcards 0.2.7, we have to make the following adjustment for making it work with shadow-cljs. { :builds { :app { :build-options { :ns-aliases { devcards-marked cljsjs.marked devcards-syntax-highlighter cljsjs.highlight }}}}} ( ns cljsjs.marked ( :require [ \"marked\" :as marked ])) ( js/goog.exportSymbol \"marked\" marked ) ( js/goog.exportSymbol \"DevcardsMarked\" marked ) ( ns cljsjs.highlight ( :require [ \"highlight\" :as highlight ])) ( js/goog.exportSymbol \"highlight\" highlight ) ( js/goog.exportSymbol \"DevcardsSyntaxHighlighter\" highlight ) Sources \u00b6 https://clojureverse.org/t/introducing-shadow-cljs-inspect/5012 Links \u00b6 shadow-cljs cljs See also (generated) \u00b6 cljss Clojure Clojure toolkit David Nolen High Performance CLJS Life In Dynamic Typing nginx See also (generated) \u00b6 cljss Clojure Clojure toolkit David Nolen High Performance CLJS Life In Dynamic Typing nginx See also (generated) \u00b6 cljss Clojure Clojure Functional Programming Principles Clojure toolkit David Nolen High Performance CLJS Life In Dynamic Typing nginx See also (generated) \u00b6 <../decks/clojure.md> <20200430141226-life_in_dynamic_typing.md> <20200430141609-david_nolen.md> <20200505112918-nginx.md> <20200505113402-high_performance_clojurescript.md> <20200505124946-clj_toolkit.md> <20200521232124-cljss.md> <20200524185034-clojure_functional_programming_principles.md> See also (generated) \u00b6 <../decks/clojure.md> <20200430141226-life_in_dynamic_typing.md> <20200430141609-david_nolen.md> <20200505112918-nginx.md> <20200505113402-high_performance_clojurescript.md> <20200505124946-clj_toolkit.md> <20200521232124-cljss.md> <20200524185034-clojure_functional_programming_principles.md> See also (generated) \u00b6 <../decks/clojure.md> <20200430141226-life_in_dynamic_typing.md> <20200430141609-david_nolen.md> <20200505112918-nginx.md> <20200505113402-high_performance_clojurescript.md> <20200505124946-clj_toolkit.md> <20200521232124-cljss.md> <20200524185034-clojure_functional_programming_principles.md>","title":"shadow-cljs"},{"location":"cards/20200430154647-shadow_cljs/#shadow-cljs","text":"","title":"shadow-cljs"},{"location":"cards/20200430154647-shadow_cljs/#nginx-configuration-for-developping-locally","text":"Install nginx on your remote server and place this file into your configuration. server { listen 80 default_server; listen [::]:80 default_server; root /var/www/html; server_name _; location / { proxy_pass http://localhost:8080/; try_files $uri $uri/a 404; } location /shadow-cljs/ { # upgrade to websocket proxy_pass http://localhost:9630/; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"Upgrade\"; proxy_set_header Host $host; } } Open the ports: `sudo ufw 8080` and `sudo ufw 9630`. Connect directly to the ip/domain of the server with the correct ports.","title":"NGINX Configuration for developping locally"},{"location":"cards/20200430154647-shadow_cljs/#inspect","text":"Inject the correct namespaces with :devtools preloads in the shadow-cljs.edn config file. { :devtools { :preloads [ shadow.remote.runtime.cljs.browser ;; shadow.remote.runtime.cljs.node ;; for nodejs ]}} Inspect with Clojure and not only ClojureScript ( require ' [ shadow.cljs.devtools.server :as server ]) ( server/start! ) ( tap> :hello )","title":"Inspect"},{"location":"cards/20200430154647-shadow_cljs/#devcards","text":"For devcards 0.2.7, we have to make the following adjustment for making it work with shadow-cljs. { :builds { :app { :build-options { :ns-aliases { devcards-marked cljsjs.marked devcards-syntax-highlighter cljsjs.highlight }}}}} ( ns cljsjs.marked ( :require [ \"marked\" :as marked ])) ( js/goog.exportSymbol \"marked\" marked ) ( js/goog.exportSymbol \"DevcardsMarked\" marked ) ( ns cljsjs.highlight ( :require [ \"highlight\" :as highlight ])) ( js/goog.exportSymbol \"highlight\" highlight ) ( js/goog.exportSymbol \"DevcardsSyntaxHighlighter\" highlight )","title":"Devcards"},{"location":"cards/20200430154647-shadow_cljs/#sources","text":"https://clojureverse.org/t/introducing-shadow-cljs-inspect/5012","title":"Sources"},{"location":"cards/20200430154647-shadow_cljs/#links","text":"shadow-cljs cljs","title":"Links"},{"location":"cards/20200430154647-shadow_cljs/#see-also-generated","text":"cljss Clojure Clojure toolkit David Nolen High Performance CLJS Life In Dynamic Typing nginx","title":"See also (generated)"},{"location":"cards/20200430154647-shadow_cljs/#see-also-generated_1","text":"cljss Clojure Clojure toolkit David Nolen High Performance CLJS Life In Dynamic Typing nginx","title":"See also (generated)"},{"location":"cards/20200430154647-shadow_cljs/#see-also-generated_2","text":"cljss Clojure Clojure Functional Programming Principles Clojure toolkit David Nolen High Performance CLJS Life In Dynamic Typing nginx","title":"See also (generated)"},{"location":"cards/20200430154647-shadow_cljs/#see-also-generated_3","text":"<../decks/clojure.md> <20200430141226-life_in_dynamic_typing.md> <20200430141609-david_nolen.md> <20200505112918-nginx.md> <20200505113402-high_performance_clojurescript.md> <20200505124946-clj_toolkit.md> <20200521232124-cljss.md> <20200524185034-clojure_functional_programming_principles.md>","title":"See also (generated)"},{"location":"cards/20200430154647-shadow_cljs/#see-also-generated_4","text":"<../decks/clojure.md> <20200430141226-life_in_dynamic_typing.md> <20200430141609-david_nolen.md> <20200505112918-nginx.md> <20200505113402-high_performance_clojurescript.md> <20200505124946-clj_toolkit.md> <20200521232124-cljss.md> <20200524185034-clojure_functional_programming_principles.md>","title":"See also (generated)"},{"location":"cards/20200430154647-shadow_cljs/#see-also-generated_5","text":"<../decks/clojure.md> <20200430141226-life_in_dynamic_typing.md> <20200430141609-david_nolen.md> <20200505112918-nginx.md> <20200505113402-high_performance_clojurescript.md> <20200505124946-clj_toolkit.md> <20200521232124-cljss.md> <20200524185034-clojure_functional_programming_principles.md>","title":"See also (generated)"},{"location":"cards/20200430155438-mastering_clojure_macro/","text":"Mastering Clojure Macro \u00b6 Macro is about manipulating the arguments of your functions before they get evaluated. We should think about templating when thinking about macros. The macro returns a S-Expression which should be valid Clojure code. Use ` for namespace quoting everything after the backquote (usually a list). Unquote is done through ~ . Unquote splicing ~@ allows to remove the parenthesis in a list and put them at the same level as the parent S-Expression. For example the following `(1 2 ~@(3 4) 5)` returns (1 2 3 4 5) . Whenever we need to bind a symbol in a macro (e.g fn and let ), the argument should be gensym, or symbol appended of a # , e.g x# . &form [the calling expression] and &env [the binding environment] are special values only available in macros. Disadvantage with macros. Macros are not values (as they are not functions). So we can\u2019t use map or any other function on them. Macros can be contagious as they can leak force your user to also write macros to use your library. They can be tough to get right (mainly because of side effect and computation time). We should avoid doing a mess in our user namespace whenever writing macros. Macros are useful to evaluate code in Context. When using dynamic binding, ( declare ^ :dynamic *radius* ) ( defn circle-area [] ( * Math/PI ( * *radius* *radius* ))) ( binding [ *radius* 10 ] ( circle-area )) it can be useful to abstract the binding step with a macro. Most common bindings are for *out* . In general, we should have the core of the manipulation of a macro written in a function, and have the smallest possible amount of lines of code into a the macro. ( defn with-out-file-fn [ file body-fn ] ( with-open [ writer ( clojure.java.io/writer file :append true )] ( binding [ *out* writer ] ( body-fn )))) ( defn with-out-file [ file & body ] ` ( with-out-file-fn ~ file ( fn [] ~@ body ))) Macro can also decide how we evaluate (or not) the input, e.g. comment . A cool trick for a function that should be executed only once ( let [ x :a f ( ^ :once fn* [] ( println x ))] ( f ) ;; prints :a ( f )) ;; prints nil Macros can also rescuing errors and clean up resources. The main point is macros allow to eliminate noisy details of cleaning up an open resource, rescuing errors, or setting up dynamic bindings or other context for evaluation. It allows to abstract away the contextual details and core operations can be clarified to make the purpose of the code more obvious. - Optimization. Before optimizing, we should know how to benchmark. criterium.core is a nice solution for that. Macros can let write type hinting without the users being noticed and as the computation is done at compile time, they allow optimization of operations or functions which does not depend on user input. - Macro can build apis that say what they mean. It allows to avoid unnecessary intermediary steps for the users to know, especially ones that require forms that are not essentials to the API. For example, building resources or calling functions. In this case, we should try to have as much operations in functions, to avoid bugs but also to offer the choice to the user to call functions (which are values) or macros. - As macro execute the logic of its body before executing its arguments, we can bend the control flow of our code. The lowest level of looping in Clojure is the loop/recur construction and most control flow in Clojure are derived from this. This is a special case of creating languages features. Links \u00b6 Mastering Clojure Macros tags: clj See also (generated) \u00b6 <../decks/clojure.md> <20200430141226-life_in_dynamic_typing.md> <20200430141609-david_nolen.md> <20200430154352-cli_arguments.md> <20200430154528-multiple_environment.md> <20200430155637-applied_clojure.md> <20200430155819-core_async.md> <20200430160432-clojure_for_the_brave_and_the_true.md> <20200430235013-specs.md> <20200502122138-simple_made_easy.md> <20200503222619-org_roam_clj.md> <20200504204808-why_clojure.md> <20200504212017-edn_and_transit.md> <20200505112138-clojure_reducers.md>","title":"Mastering Clojure Macro"},{"location":"cards/20200430155438-mastering_clojure_macro/#mastering-clojure-macro","text":"Macro is about manipulating the arguments of your functions before they get evaluated. We should think about templating when thinking about macros. The macro returns a S-Expression which should be valid Clojure code. Use ` for namespace quoting everything after the backquote (usually a list). Unquote is done through ~ . Unquote splicing ~@ allows to remove the parenthesis in a list and put them at the same level as the parent S-Expression. For example the following `(1 2 ~@(3 4) 5)` returns (1 2 3 4 5) . Whenever we need to bind a symbol in a macro (e.g fn and let ), the argument should be gensym, or symbol appended of a # , e.g x# . &form [the calling expression] and &env [the binding environment] are special values only available in macros. Disadvantage with macros. Macros are not values (as they are not functions). So we can\u2019t use map or any other function on them. Macros can be contagious as they can leak force your user to also write macros to use your library. They can be tough to get right (mainly because of side effect and computation time). We should avoid doing a mess in our user namespace whenever writing macros. Macros are useful to evaluate code in Context. When using dynamic binding, ( declare ^ :dynamic *radius* ) ( defn circle-area [] ( * Math/PI ( * *radius* *radius* ))) ( binding [ *radius* 10 ] ( circle-area )) it can be useful to abstract the binding step with a macro. Most common bindings are for *out* . In general, we should have the core of the manipulation of a macro written in a function, and have the smallest possible amount of lines of code into a the macro. ( defn with-out-file-fn [ file body-fn ] ( with-open [ writer ( clojure.java.io/writer file :append true )] ( binding [ *out* writer ] ( body-fn )))) ( defn with-out-file [ file & body ] ` ( with-out-file-fn ~ file ( fn [] ~@ body ))) Macro can also decide how we evaluate (or not) the input, e.g. comment . A cool trick for a function that should be executed only once ( let [ x :a f ( ^ :once fn* [] ( println x ))] ( f ) ;; prints :a ( f )) ;; prints nil Macros can also rescuing errors and clean up resources. The main point is macros allow to eliminate noisy details of cleaning up an open resource, rescuing errors, or setting up dynamic bindings or other context for evaluation. It allows to abstract away the contextual details and core operations can be clarified to make the purpose of the code more obvious. - Optimization. Before optimizing, we should know how to benchmark. criterium.core is a nice solution for that. Macros can let write type hinting without the users being noticed and as the computation is done at compile time, they allow optimization of operations or functions which does not depend on user input. - Macro can build apis that say what they mean. It allows to avoid unnecessary intermediary steps for the users to know, especially ones that require forms that are not essentials to the API. For example, building resources or calling functions. In this case, we should try to have as much operations in functions, to avoid bugs but also to offer the choice to the user to call functions (which are values) or macros. - As macro execute the logic of its body before executing its arguments, we can bend the control flow of our code. The lowest level of looping in Clojure is the loop/recur construction and most control flow in Clojure are derived from this. This is a special case of creating languages features.","title":"Mastering Clojure Macro"},{"location":"cards/20200430155438-mastering_clojure_macro/#links","text":"Mastering Clojure Macros tags: clj","title":"Links"},{"location":"cards/20200430155438-mastering_clojure_macro/#see-also-generated","text":"<../decks/clojure.md> <20200430141226-life_in_dynamic_typing.md> <20200430141609-david_nolen.md> <20200430154352-cli_arguments.md> <20200430154528-multiple_environment.md> <20200430155637-applied_clojure.md> <20200430155819-core_async.md> <20200430160432-clojure_for_the_brave_and_the_true.md> <20200430235013-specs.md> <20200502122138-simple_made_easy.md> <20200503222619-org_roam_clj.md> <20200504204808-why_clojure.md> <20200504212017-edn_and_transit.md> <20200505112138-clojure_reducers.md>","title":"See also (generated)"},{"location":"cards/20200430155637-applied_clojure/","text":"Applied Clojure \u00b6 Collections \u00b6 List (adddition at the head), vectors (addition at the end) and queues (FIFO). ( def new-orders clojure.lang.PersistentQueue/EMPTY ) Use transient and persistent! if the transformation is local. The library medley from weavejester incorporate useful functions. Collection accessing: use keyword first (:key m) , or (m :key) if it is certain that m is a map, otherwise if both might be null use (get m k) . If possible avoid having a stack of left parentheses such as ((f) x) . Abuse of select-keys to subset a map. If performance is required, we can create custom collection by defining a type and implementing the protocol, a custom printing is possible. Use records and maps to describe your entities. Maps should be the default choice, unless you decide to use protocols and need performance for dispatch. Protocols and multimethods are the two ways for dispatching. Protocols are faster in Clojure, but multimethods are more flexible. Processing Sequential Data. \u00b6 We can use map , filter , reduce to process sequence of values, but it might not be efficient. Transducers are created to avoid the concretion of the data structure. A transducer (usually denoted by xf or xform ) is a function that transform a reducing function into an another reducing function. That is xf: f -> g where f and g have signature whatever, input -> whatever . Concrete example of reducing function are conj with whatever being a list, + (with whatever being a number, and input a number). See here for more details. The trick is you can define map, filter and other operations as reducing function (reducing function are used in reduce operations usually). It is important to note that reducing function can actually grow the whatever (see conj ). We create them by omitting the coll argument in the typical sequence functions, e.g. (map f) yields a transducer. Use the sequence function to realize the transducer. The following calls are equal ( = ( map # ( * 2 % ) ( range 10 )) ( sequence ( map # ( * 2 % )) ( range 10 ))) If we need eagerness we could use into ( into [] ( map # ( * 2 % )) ( range 10 )) The benefit of transducer is intermediate values are not allocated and there is a decoupling of the transformations with the reducer (reducing function and reducible collection). They are also polymorphic. We can compose transducers and reduction with transduce ( def moons-transform ( comp ( filter planet? ) ( map :moons ))) ( defn total-moons [ entities ] ( transduce moons-transform + 0 entities )) See understanding transducers for more details. Duplicate removal with distinct and dedupe (only remove subsequent duplicate and safer for large input). Use mapcat instead of (-> map flatten) . Reference, State and Mutation \u00b6 Identity and state are two distinct notions. An identity is a sequence of immutable values, and the state is the actual value of an identity at a certain point of time. The challenge is to always display a single valid value to all the observer at the same time. There are two types of successions (mutation): atomic and transactions. An atomic transaction only cares about the change happening to the identity itself and not about the coordination of other identity. Transactional ensure that either all changes or none are performed. There are two states: program and runtime states. Program state is concerned with mutation in the problem domain, whereas runtime facilitate the software\u2019s execution (e.g. connections to databases or network, config files). Runtime state is often unavoidable whereas program state should be minimized and access through API with curated methods rather than directly. For managing change, we should build just enough to ensure the application\u2019s needs are met. Every side effect and mutable reference slows you down. We should be responsible over our functions (make them pure) and make choices about what need to be managed. State is a series of snapshots of values (data) which allows to act responsibly when considering the presence of observers in other processes. In Clojure, observers have consistent set of values as of a particular instant thanks to Clojure\u2019s mutable references. Use your cores \u00b6 One of the problem is to send task of the main thread to be completed asynchronously and retrieve the result ( future and promise ). Tasks and workers for long lived task-oriented concurrency. We can also use reducers and core.async (with channels and go blocks ). For agents, use send for computational tasks and won\u2019t block for I/O and send-off for updates that might block for an arbitrary time (thread pool will grow accordingly). The advantage is agent can maintain state compared to future . Use deref or @ for retrieving back the value of a future or promise . Promise are used to returns several values from a future block. Use realized? to check if a promise is available, otherwise it will block. The deref function with an additional argument can force timeout. Use Java queues and workers for task oriented programs. This is for coarse grained task parallelism. Queues , threads and executors are the tools from Java to perform a queue of incoming work or requests. For fine-grained parallelism The pmap function can be used for easy parallelism, but the overhead might be consequential. The clojure.core.reducer library is the solution for parallelism [fine-grained operations and memory efficient]. A reducer is reducible collection combined with a reducing function . fold is used to perform the reduction [only vectors and maps can be folded in parallel, but the serial version can be faster thanks to avoiding intermediary values]. A reducer splits the data into partition, reduce the elements and then combine them. The reduce and the combine functions can hence be different. Concurrency (design the program as a set of concurrent threads of execution) we can use core.async . Channels come in unbuffered, fixed buffered, dropping (discard new data) and sliding buffer (discard old data). Creating a channel is done with chan the function. nil can not be passed into channels (as it is the value for saying the channel is closed). The important operations are put and take . A full channel (once the buffer is complete) blocks a thread if no process other process is the other end of the channel to take the value sent by put . Backpressure is the efffect that fixed sized buffers creates by making the producers block when trying to add to a full queue. Traditionally channels are used in go block . In the Communicating Sequential Processes (CSP), process belongs to a thread pool and are parked when not blocked by a channel operation ( >! or <! ). Go blocks are great for building pipelines of data transformation. core.async/pipelines gives up the raw performance of fine-grained data parallelism but yield a more flexible architecture. The function moves the value from input to output channel with parallel transducer execution. Next step is to break a growing system into pieces using concurrency. Designing components \u00b6 Use of channels, better to receive and provide channels for interface. In core.async , a single go block is to call the body of the go block once asynchronously, while go-loop is intended for looping, unless we close the channel. go blocks return a channel, which can be used for pedestal. A good design is to split an API layer and implementation layer with a record. As for core.async , there are three additional concept for channels that are useful: pipeline, fan-in and fan-out. In a system, pipelines link an output channel to an input channel (acting like as a conveyor belt) and can possibly transform its input values with a transducer (async, sync, blocking). The pipe function should be used when no transformation. Fan-in channels gather the input of several channels and provide a single output channel. merge is a simple way to merge all the incoming channels into a single output channels, but it can\u2019t be modified after creation. The mix (for audio mix) function with its functions admix/unmix allows channel to participate in the mix. Users can toggle options for each input channel: :pause (no consumption nor inclusion in output channel), :mute (consumption but no inclusion), :solo ( if true, only solo-ed channels in output channel mix, :pause and :mute ignored if this is the case). Fan-out have three ways: mult , pub/sub , split . The mult abstraction is multiply traffic from the input channel into multiple output channels. Output channels (with different blocking policy) can participate in the connection with tap/untap (if a tap is closed, it is removed from the mult ). All the receiving channels must accept a value from the mult before the mult can move on to the next value. This is where alternative buffering strategy are useful. The pub/sub allows to distribute the traffic through a partition function and subscribers can inform to which partition value they want to lisen to. split divides the traffic two channels based on a truthiness of a predicate. split is actually a pub/sub with a partition function providing only truthy/falsy . Compose Your Application \u00b6 Taking things apart: usualy some portion of the code will work on the same data, or have the data has a common scope or lifetime, likelihehood of change from external requirement is similar are resource needed. If code is reusable when configured differently in more than one context, then it is a component. Component should communicate with channels, but in order to set up the system correctly, we need something to orchestrate it. Several library exist, the book recommends Component , but it has been super-seeded by integrant . An example can be found here reitit/integrant . Environment variable also should exist with different settings. The solution in the book are a bit old. Environ still seems to be good on clojure (jvm). Testing \u00b6 There are three ways to create tests in clojure: repl, example based, generative testing (properties check). With REPL driven development, the example used for development are stored in a file (these are candidates for examples). For example based, there is the expectations library and the following snippets ( deftest test-range-are ( testing \"Testing range(endIndex)\" ( are [ expected endIndex ( = ( range endIndex ) expected ) ' ( 0 1 2 3 4 ) 5 ' () 0 ]))) Generative testing using ( ns generative-testing.core ( :require [ clojure.test.check :as tc ] [ clojure.test.check.generators :as gen ] [ clojure.test.check.properties :as prop ])) I think nowadays we would use spec for it. We are looking for invariants \u2013 properties that are always true. [\u2026] mathematical laws, relationships between inputs and outputs, round-trip or complementing functions, and comparing action effects. Properties like identity, associativity, commutativity and idempotency are an excellent place to start. Invariants are important because they reduce the number of case your code must consider. Thinking in Clojure \u00b6 Make Reasoned Choices: always compare trade-off of solutions (benefits and costs). Think first, then do . Careful treatment of decisions and weighed trade-off to fully understand the consequences. Be Reasonable: code with clearly expressed intent, limited side effects, neatly separated concerns, and unambiguous naming. Simple. Keep It Simple: Keep distinct concern as distinct as possible and avoid entangling concepts with other concepts. The code can be reasoned about, test and implemented without any incidental complexity. Entities are simplest when distinct and composable. Domain functions avoid complexity by avoiding side effects and concerning themselves only with entities in their domain. Build Just Enough: Keep complexity at bay and avoid overengineering. Compose: compose component, and evaluate your code composability by using it from another component. Results will be a set of tidy interfaces to distinct independent subsystems with clear communication channels. With a stable interface, a component can grow easily and adapt quickly. Be Precise: avoid ambiguity and communicate clearly with others and your future self. Entities typify one concept. Functions effect a single transformation. Queries ask simple questions and return unambiguous results. Use What Works: look for working libraries, solution in other languages or papers. Link \u00b6 Clojure Applied tags: clj core-async design See also (generated) \u00b6 <../decks/clojure.md> <../todo.md> <20200430141226-life_in_dynamic_typing.md> <20200430141609-david_nolen.md> <20200430154352-cli_arguments.md> <20200430154528-multiple_environment.md> <20200430155438-mastering_clojure_macro.md> <20200430155819-core_async.md> <20200430160432-clojure_for_the_brave_and_the_true.md> <20200430190921-design.md> <20200430235013-specs.md> <20200502122138-simple_made_easy.md> <20200503222619-org_roam_clj.md> <20200504204808-why_clojure.md> <20200504212017-edn_and_transit.md> <20200505112138-clojure_reducers.md> <20200516171955-generative_testing.md>","title":"Applied Clojure"},{"location":"cards/20200430155637-applied_clojure/#applied-clojure","text":"","title":"Applied Clojure"},{"location":"cards/20200430155637-applied_clojure/#collections","text":"List (adddition at the head), vectors (addition at the end) and queues (FIFO). ( def new-orders clojure.lang.PersistentQueue/EMPTY ) Use transient and persistent! if the transformation is local. The library medley from weavejester incorporate useful functions. Collection accessing: use keyword first (:key m) , or (m :key) if it is certain that m is a map, otherwise if both might be null use (get m k) . If possible avoid having a stack of left parentheses such as ((f) x) . Abuse of select-keys to subset a map. If performance is required, we can create custom collection by defining a type and implementing the protocol, a custom printing is possible. Use records and maps to describe your entities. Maps should be the default choice, unless you decide to use protocols and need performance for dispatch. Protocols and multimethods are the two ways for dispatching. Protocols are faster in Clojure, but multimethods are more flexible.","title":"Collections"},{"location":"cards/20200430155637-applied_clojure/#processing-sequential-data","text":"We can use map , filter , reduce to process sequence of values, but it might not be efficient. Transducers are created to avoid the concretion of the data structure. A transducer (usually denoted by xf or xform ) is a function that transform a reducing function into an another reducing function. That is xf: f -> g where f and g have signature whatever, input -> whatever . Concrete example of reducing function are conj with whatever being a list, + (with whatever being a number, and input a number). See here for more details. The trick is you can define map, filter and other operations as reducing function (reducing function are used in reduce operations usually). It is important to note that reducing function can actually grow the whatever (see conj ). We create them by omitting the coll argument in the typical sequence functions, e.g. (map f) yields a transducer. Use the sequence function to realize the transducer. The following calls are equal ( = ( map # ( * 2 % ) ( range 10 )) ( sequence ( map # ( * 2 % )) ( range 10 ))) If we need eagerness we could use into ( into [] ( map # ( * 2 % )) ( range 10 )) The benefit of transducer is intermediate values are not allocated and there is a decoupling of the transformations with the reducer (reducing function and reducible collection). They are also polymorphic. We can compose transducers and reduction with transduce ( def moons-transform ( comp ( filter planet? ) ( map :moons ))) ( defn total-moons [ entities ] ( transduce moons-transform + 0 entities )) See understanding transducers for more details. Duplicate removal with distinct and dedupe (only remove subsequent duplicate and safer for large input). Use mapcat instead of (-> map flatten) .","title":"Processing Sequential Data."},{"location":"cards/20200430155637-applied_clojure/#reference-state-and-mutation","text":"Identity and state are two distinct notions. An identity is a sequence of immutable values, and the state is the actual value of an identity at a certain point of time. The challenge is to always display a single valid value to all the observer at the same time. There are two types of successions (mutation): atomic and transactions. An atomic transaction only cares about the change happening to the identity itself and not about the coordination of other identity. Transactional ensure that either all changes or none are performed. There are two states: program and runtime states. Program state is concerned with mutation in the problem domain, whereas runtime facilitate the software\u2019s execution (e.g. connections to databases or network, config files). Runtime state is often unavoidable whereas program state should be minimized and access through API with curated methods rather than directly. For managing change, we should build just enough to ensure the application\u2019s needs are met. Every side effect and mutable reference slows you down. We should be responsible over our functions (make them pure) and make choices about what need to be managed. State is a series of snapshots of values (data) which allows to act responsibly when considering the presence of observers in other processes. In Clojure, observers have consistent set of values as of a particular instant thanks to Clojure\u2019s mutable references.","title":"Reference, State and Mutation"},{"location":"cards/20200430155637-applied_clojure/#use-your-cores","text":"One of the problem is to send task of the main thread to be completed asynchronously and retrieve the result ( future and promise ). Tasks and workers for long lived task-oriented concurrency. We can also use reducers and core.async (with channels and go blocks ). For agents, use send for computational tasks and won\u2019t block for I/O and send-off for updates that might block for an arbitrary time (thread pool will grow accordingly). The advantage is agent can maintain state compared to future . Use deref or @ for retrieving back the value of a future or promise . Promise are used to returns several values from a future block. Use realized? to check if a promise is available, otherwise it will block. The deref function with an additional argument can force timeout. Use Java queues and workers for task oriented programs. This is for coarse grained task parallelism. Queues , threads and executors are the tools from Java to perform a queue of incoming work or requests. For fine-grained parallelism The pmap function can be used for easy parallelism, but the overhead might be consequential. The clojure.core.reducer library is the solution for parallelism [fine-grained operations and memory efficient]. A reducer is reducible collection combined with a reducing function . fold is used to perform the reduction [only vectors and maps can be folded in parallel, but the serial version can be faster thanks to avoiding intermediary values]. A reducer splits the data into partition, reduce the elements and then combine them. The reduce and the combine functions can hence be different. Concurrency (design the program as a set of concurrent threads of execution) we can use core.async . Channels come in unbuffered, fixed buffered, dropping (discard new data) and sliding buffer (discard old data). Creating a channel is done with chan the function. nil can not be passed into channels (as it is the value for saying the channel is closed). The important operations are put and take . A full channel (once the buffer is complete) blocks a thread if no process other process is the other end of the channel to take the value sent by put . Backpressure is the efffect that fixed sized buffers creates by making the producers block when trying to add to a full queue. Traditionally channels are used in go block . In the Communicating Sequential Processes (CSP), process belongs to a thread pool and are parked when not blocked by a channel operation ( >! or <! ). Go blocks are great for building pipelines of data transformation. core.async/pipelines gives up the raw performance of fine-grained data parallelism but yield a more flexible architecture. The function moves the value from input to output channel with parallel transducer execution. Next step is to break a growing system into pieces using concurrency.","title":"Use your cores"},{"location":"cards/20200430155637-applied_clojure/#designing-components","text":"Use of channels, better to receive and provide channels for interface. In core.async , a single go block is to call the body of the go block once asynchronously, while go-loop is intended for looping, unless we close the channel. go blocks return a channel, which can be used for pedestal. A good design is to split an API layer and implementation layer with a record. As for core.async , there are three additional concept for channels that are useful: pipeline, fan-in and fan-out. In a system, pipelines link an output channel to an input channel (acting like as a conveyor belt) and can possibly transform its input values with a transducer (async, sync, blocking). The pipe function should be used when no transformation. Fan-in channels gather the input of several channels and provide a single output channel. merge is a simple way to merge all the incoming channels into a single output channels, but it can\u2019t be modified after creation. The mix (for audio mix) function with its functions admix/unmix allows channel to participate in the mix. Users can toggle options for each input channel: :pause (no consumption nor inclusion in output channel), :mute (consumption but no inclusion), :solo ( if true, only solo-ed channels in output channel mix, :pause and :mute ignored if this is the case). Fan-out have three ways: mult , pub/sub , split . The mult abstraction is multiply traffic from the input channel into multiple output channels. Output channels (with different blocking policy) can participate in the connection with tap/untap (if a tap is closed, it is removed from the mult ). All the receiving channels must accept a value from the mult before the mult can move on to the next value. This is where alternative buffering strategy are useful. The pub/sub allows to distribute the traffic through a partition function and subscribers can inform to which partition value they want to lisen to. split divides the traffic two channels based on a truthiness of a predicate. split is actually a pub/sub with a partition function providing only truthy/falsy .","title":"Designing components"},{"location":"cards/20200430155637-applied_clojure/#compose-your-application","text":"Taking things apart: usualy some portion of the code will work on the same data, or have the data has a common scope or lifetime, likelihehood of change from external requirement is similar are resource needed. If code is reusable when configured differently in more than one context, then it is a component. Component should communicate with channels, but in order to set up the system correctly, we need something to orchestrate it. Several library exist, the book recommends Component , but it has been super-seeded by integrant . An example can be found here reitit/integrant . Environment variable also should exist with different settings. The solution in the book are a bit old. Environ still seems to be good on clojure (jvm).","title":"Compose Your Application"},{"location":"cards/20200430155637-applied_clojure/#testing","text":"There are three ways to create tests in clojure: repl, example based, generative testing (properties check). With REPL driven development, the example used for development are stored in a file (these are candidates for examples). For example based, there is the expectations library and the following snippets ( deftest test-range-are ( testing \"Testing range(endIndex)\" ( are [ expected endIndex ( = ( range endIndex ) expected ) ' ( 0 1 2 3 4 ) 5 ' () 0 ]))) Generative testing using ( ns generative-testing.core ( :require [ clojure.test.check :as tc ] [ clojure.test.check.generators :as gen ] [ clojure.test.check.properties :as prop ])) I think nowadays we would use spec for it. We are looking for invariants \u2013 properties that are always true. [\u2026] mathematical laws, relationships between inputs and outputs, round-trip or complementing functions, and comparing action effects. Properties like identity, associativity, commutativity and idempotency are an excellent place to start. Invariants are important because they reduce the number of case your code must consider.","title":"Testing"},{"location":"cards/20200430155637-applied_clojure/#thinking-in-clojure","text":"Make Reasoned Choices: always compare trade-off of solutions (benefits and costs). Think first, then do . Careful treatment of decisions and weighed trade-off to fully understand the consequences. Be Reasonable: code with clearly expressed intent, limited side effects, neatly separated concerns, and unambiguous naming. Simple. Keep It Simple: Keep distinct concern as distinct as possible and avoid entangling concepts with other concepts. The code can be reasoned about, test and implemented without any incidental complexity. Entities are simplest when distinct and composable. Domain functions avoid complexity by avoiding side effects and concerning themselves only with entities in their domain. Build Just Enough: Keep complexity at bay and avoid overengineering. Compose: compose component, and evaluate your code composability by using it from another component. Results will be a set of tidy interfaces to distinct independent subsystems with clear communication channels. With a stable interface, a component can grow easily and adapt quickly. Be Precise: avoid ambiguity and communicate clearly with others and your future self. Entities typify one concept. Functions effect a single transformation. Queries ask simple questions and return unambiguous results. Use What Works: look for working libraries, solution in other languages or papers.","title":"Thinking in Clojure"},{"location":"cards/20200430155637-applied_clojure/#link","text":"Clojure Applied tags: clj core-async design","title":"Link"},{"location":"cards/20200430155637-applied_clojure/#see-also-generated","text":"<../decks/clojure.md> <../todo.md> <20200430141226-life_in_dynamic_typing.md> <20200430141609-david_nolen.md> <20200430154352-cli_arguments.md> <20200430154528-multiple_environment.md> <20200430155438-mastering_clojure_macro.md> <20200430155819-core_async.md> <20200430160432-clojure_for_the_brave_and_the_true.md> <20200430190921-design.md> <20200430235013-specs.md> <20200502122138-simple_made_easy.md> <20200503222619-org_roam_clj.md> <20200504204808-why_clojure.md> <20200504212017-edn_and_transit.md> <20200505112138-clojure_reducers.md> <20200516171955-generative_testing.md>","title":"See also (generated)"},{"location":"cards/20200430155819-core_async/","text":"core.async \u00b6 tags: clojure asynchronous CSP Problems \u00b6 Function chains make poor machines Real world concurrency is exposed via callback API. core.async in Use \u00b6 Source: core.async in use Transducers are really important for using core.async. Use transducers as much as possible in channels and go block to avoid side effect. Make sure to return the channels. Disadvantage: async code pollutes the return type, problem with error handling, channels are IO and hence have side effects. It introduces non-determinism in the code. Don\u2019t use async, unless required. Pattern fetch and them conj all the result in a callback. A good api for library creators is to ask the user to take the result of the asynchronous code as a callback. Make a framework where the asynchronicity is set as an implemented detail. Remove it from the interface (user or API). You need to contains the asynchronicity and hide it from the business perspective. This yields, testable data, explicit data. Reifying is the act of taking virtual and making it concrete. Intangible to tangible. The interceptors ( enter , exit , on-error ). Dataflow and FRP. Nodes are connected via communication channels, each nodes takes and emits from on or more inputs/outputs, each node consists of a function that computes outputs ased on inputs. The advantage is that it Separates transformation from communication and connection. It is functionally pure, async code is removed from the user interface, connections are explicit, and any connections can be used. Actor, connections are implicit, sending message inside user code, opqare state hidden in loop local. Pattern in Pattern \u00b6 Keep user space code pure; Move the complexity of async out of the user space; Make dependencies/connections between modules/components explicit (the system can introspect itself). It increase leverage; Leverage this for easier testing; Use core.async to enable cleaner abstractions, not as aned in itself. Pitfalls \u00b6 Sliding/dropping buffers still required to be put into channels ( def c ( chan ( sliding-buffer 10 ))) To Read \u00b6 https://www.teigfam.net/oyvind/home/technology/084-csp-on-node-js-and-clojurescript-by-javascript/#coreasync_channels_library Link \u00b6 Announcement Rich Hickey on core.async core.async in use See also (generated) \u00b6 <../decks/clojure.md> <../README.md> <../todo.md> <20200430155438-mastering_clojure_macro.md> <20200430155637-applied_clojure.md> <20200430160432-clojure_for_the_brave_and_the_true.md> <20200505112138-clojure_reducers.md>","title":"core.async"},{"location":"cards/20200430155819-core_async/#coreasync","text":"tags: clojure asynchronous CSP","title":"core.async"},{"location":"cards/20200430155819-core_async/#problems","text":"Function chains make poor machines Real world concurrency is exposed via callback API.","title":"Problems"},{"location":"cards/20200430155819-core_async/#coreasync-in-use","text":"Source: core.async in use Transducers are really important for using core.async. Use transducers as much as possible in channels and go block to avoid side effect. Make sure to return the channels. Disadvantage: async code pollutes the return type, problem with error handling, channels are IO and hence have side effects. It introduces non-determinism in the code. Don\u2019t use async, unless required. Pattern fetch and them conj all the result in a callback. A good api for library creators is to ask the user to take the result of the asynchronous code as a callback. Make a framework where the asynchronicity is set as an implemented detail. Remove it from the interface (user or API). You need to contains the asynchronicity and hide it from the business perspective. This yields, testable data, explicit data. Reifying is the act of taking virtual and making it concrete. Intangible to tangible. The interceptors ( enter , exit , on-error ). Dataflow and FRP. Nodes are connected via communication channels, each nodes takes and emits from on or more inputs/outputs, each node consists of a function that computes outputs ased on inputs. The advantage is that it Separates transformation from communication and connection. It is functionally pure, async code is removed from the user interface, connections are explicit, and any connections can be used. Actor, connections are implicit, sending message inside user code, opqare state hidden in loop local.","title":"core.async in Use"},{"location":"cards/20200430155819-core_async/#pattern-in-pattern","text":"Keep user space code pure; Move the complexity of async out of the user space; Make dependencies/connections between modules/components explicit (the system can introspect itself). It increase leverage; Leverage this for easier testing; Use core.async to enable cleaner abstractions, not as aned in itself.","title":"Pattern in Pattern"},{"location":"cards/20200430155819-core_async/#pitfalls","text":"Sliding/dropping buffers still required to be put into channels ( def c ( chan ( sliding-buffer 10 )))","title":"Pitfalls"},{"location":"cards/20200430155819-core_async/#to-read","text":"https://www.teigfam.net/oyvind/home/technology/084-csp-on-node-js-and-clojurescript-by-javascript/#coreasync_channels_library","title":"To Read"},{"location":"cards/20200430155819-core_async/#link","text":"Announcement Rich Hickey on core.async core.async in use","title":"Link"},{"location":"cards/20200430155819-core_async/#see-also-generated","text":"<../decks/clojure.md> <../README.md> <../todo.md> <20200430155438-mastering_clojure_macro.md> <20200430155637-applied_clojure.md> <20200430160432-clojure_for_the_brave_and_the_true.md> <20200505112138-clojure_reducers.md>","title":"See also (generated)"},{"location":"cards/20200430160432-clojure_for_the_brave_and_the_true/","text":"Clojure for the brave and the true \u00b6 Parallel demons :concurrency: \u00b6 Reference cell: Read and write a shared state. Mutual exclusion: Example with writing a log with several processes, e.g. concatenate \u201cab\u201d and \u201ccd\u201d in a file results in \u201cacbd\u201d. Deadlock: On a table, every one has to take the left and right stick and the same time. However, there is only one stick per person. Leading to a deadlock. Solutions to these are future (new thread), delay (like future but executed only at deref time), promise (empty memory location shared to all thread that will receive value only once with deliver ). The advantage is all the execution are cached. Note : deference is done with either the defer function or the @ sign in front of the variable. References type :concurrency:epochal_time_model: \u00b6 atom are identities that can be set and shared by multiple threads. They use a set and compare algorithm, i.e. the swap! function modifies the value of the atom variable only if its values did not change between the beginning and the end of the transaction. swap! and reset! are the main function to work with atoms. watch are function with four arguments: a key (a keyword for identifying the process calling the watcher), a reference variable being watched, the old-state, and the new state. ( defn f [ key watched old-state new-state ] nil ) A watcher function is attached to a reference type (e.g an atom) with the add-watch function having the following signature: ( def counter ( atom 0 )) ( add-watch counter :watching-counter watch-fn ) Validators are functions that can check if new states are valid. They take as argument the atom and return a boolean. They are added to the atom as follow ( defn bigger-than-1 [ x ] ( or ( > x 1 ) ( throw ( IllegalStateException. \"That's too small\" )))) ( def account ( atom 2 :validator bigger-than-1 )) ( swap! account inc ) ( swap! account - 10 ) ;; Throw an error ref type are the ACI in the ACID accronym (atomic, consistent and isolated) and use STM . It means that either the operations between two refs happened correctly, or the transaction is aborted. alter and dosync are the key functions. In a transaction (that is the body of dosync ), every ref keep their state to the transaction (invisible to outside threads) and when the transaction tries to commit, every ref checks if the value has been altered by other threads. If any of them has been change, then none of the ref are updated, and the transaction restart with the new value and commits only when the initial states has not been /alter/ed by other processes. commute also allow to change the state of a ref. However, at transaction time, if ref states have been altered, only the commute part is run again with the new states, which might lead to inconsistent state, but increased performance. ensure function protects refs from being modified by other transaction. This is helpful, when a transaction must modify only one refs, but the other related refs must not be altered by other transaction. 5. vars are associations between symbols and objects. ^:dynamic is a keyword in def to signal to clojure that a vars is dynamic. Varnames are enclosed around * (e.g. *user-email* ) to show to other programmers that the variable is dynamic. bindings is a dynamic let . Dynamic vars are often use to name a resource that one ore more functions target. set! allows to change the state of the dynamic vars. alter-var-root allows to rebind a immutable vars (which is unadvised), and with-redefs allows to create local binding for testing. 6. pmap and the following ppmap can be used to execute parallel task: ( defn ppmap \"Partitioned pmap, for grouping map ops together to make parallel overehead worthwile\" [ grain-size f & colls ] ( apply concat ( apply pmap ( fn [ & pgroups ] ( doall ( apply map f pgroups ))) ( map ( partial partition-all grain-size ) colls )))) core.async and channels :core_async: \u00b6 chan creates a channel. And channel communicate through messages . One can put and take message. Processes wait for completion of their message. Process: Wait and do nothing until successful completion of either put or take from a channel. After success of the operation, continue. go and their blocks ( go blocks ) runs separately on a concurrent thread. go creates a process (i.e. its go block), which runs a pool of threads equal two plus the number of machines cores (avoiding the overhead of creating threads). Each go block only live until it reach the ends of its body. <! and <!! are the take function. It listen to the channel and wait until an another process puts a value in the channel which the take function returns. >! and >!! are the put function which always return true. It provides a message to a channel and wait until the message to be taken by another process before releasing resources. The number of ! in the operation depends if one is inside a go block (one ! ) or not (two ! ). Blocking and parking waiting are key to understand the number of ! . Parking wait allows a thread to handle several process (and this is only possible in a go block ). When one of the process starts to wait, the thread put it aside and starts an another process until it starts to wait, and so on. Use poll! and offer! to have non blocking channel interactions in the REPL. Channel buffers are created as following: ( def buffer-size 2 ) ( def channel-buffer ( chan buffer-size )) This means we can create 2 values without waiting for a response. sliding-buffer (FIFO) and dropping-buffer (LIFO) can be used to discard channel message without blocking. 5. close! closes channel. A closed channel does not accept any puts anymore and after all the values have been retrieved, the subsequent takes return nil . 6. alts!! lets us use the result of the first successful channel operation among a collection of channel operations. The elegant solution with alts!! is one can define a timeout ( let [[ message channel ] ( alts!! [ c1 c2 ( timout 20 )])] ;; c1 and c2 are predefined channels. ( println message )) if the timeout is the first to finish than message is nil . See alt! macro as well. 7. Queues and pipelines (escaping the callback hell) are common patterns. Abstraction and polymorphism \u00b6 Multimethods ( defmulti method-name ( fn [ x ] ( :type x ))) ;; or simplty :type, can be more complicated as well ( defmethod method-name :hello [ x ] \"Hello\" ) ( defmethod method-name :good-bye [ x ] \"Good-bye\" ) ( defmethod method-name :default [ x ] \"I don't know you\" ) ( method-name { :type :hello }) ; => Hello ( method-name { :type :good-bye }) ; Good-bye ( method-name { :type :what? }) ; => I don't know you One can also create hierarchies with derive and namespace keywords. 2. A protocol allows to make dispatch by the type of the first argument and it is a collection of polymorphic operations (unlike multimethod which is just one function). Methods from protocols can not have a & rest argument. Key functions are defprotocol , extend-type , extend-protocol (for specifying for several type at once). - Caveat: methods from protocols are property of the namespace and not from the object. 3. Records are extension of hash-map . ( defrecord WereWolf [ name title ]) ( WereWolf. \"David\" \"Master\" ) ( ->WereWolf \"David\" \"Master\" ) ( map->WereWolf { :name \"David\" :title \"Master\" }) On has to use the :import: statement in the ns macro in order to import records. One can access field through the keyword or the dot . macro. ( .name ( WereWolf. \"David\" \"Master\" )) ; \"David\" ( :title ( WereWolf. \"David\" \"Master\" )) ; \"Master\" Any function on map works on record (although they do not retain their class if one dissoc or assoc them). Here is how one could extend a protocol. ( defprotocol WereCreature \"Awesom Were\" ( full-moon-behavior [ x ] \"Full-moon behavior\" )) ( defrecord WereWolf [ name title ] WereCreature ( full-moon-behavior [ x ] ( str name \" will kill everyone\" ))) ( full-moon-behavior ( WereWolf. \"David\" \"Master\" )) deftype , reify , proxy . reify is about implementing an anonymous protocol at runtime. Link \u00b6 Brave and the True See also (generated) \u00b6 <../decks/clojure.md> <../todo.md> <20200430141226-life_in_dynamic_typing.md> <20200430141609-david_nolen.md> <20200430154352-cli_arguments.md> <20200430154528-multiple_environment.md> <20200430155438-mastering_clojure_macro.md> <20200430155637-applied_clojure.md> <20200430155819-core_async.md> <20200430235013-specs.md> <20200502122138-simple_made_easy.md> <20200503222619-org_roam_clj.md> <20200504204808-why_clojure.md> <20200504212017-edn_and_transit.md> <20200505112138-clojure_reducers.md>","title":"Clojure for the brave and the true"},{"location":"cards/20200430160432-clojure_for_the_brave_and_the_true/#clojure-for-the-brave-and-the-true","text":"","title":"Clojure for the brave and the true"},{"location":"cards/20200430160432-clojure_for_the_brave_and_the_true/#parallel-demons-concurrency","text":"Reference cell: Read and write a shared state. Mutual exclusion: Example with writing a log with several processes, e.g. concatenate \u201cab\u201d and \u201ccd\u201d in a file results in \u201cacbd\u201d. Deadlock: On a table, every one has to take the left and right stick and the same time. However, there is only one stick per person. Leading to a deadlock. Solutions to these are future (new thread), delay (like future but executed only at deref time), promise (empty memory location shared to all thread that will receive value only once with deliver ). The advantage is all the execution are cached. Note : deference is done with either the defer function or the @ sign in front of the variable.","title":"Parallel demons     :concurrency:"},{"location":"cards/20200430160432-clojure_for_the_brave_and_the_true/#references-type-concurrencyepochal_time_model","text":"atom are identities that can be set and shared by multiple threads. They use a set and compare algorithm, i.e. the swap! function modifies the value of the atom variable only if its values did not change between the beginning and the end of the transaction. swap! and reset! are the main function to work with atoms. watch are function with four arguments: a key (a keyword for identifying the process calling the watcher), a reference variable being watched, the old-state, and the new state. ( defn f [ key watched old-state new-state ] nil ) A watcher function is attached to a reference type (e.g an atom) with the add-watch function having the following signature: ( def counter ( atom 0 )) ( add-watch counter :watching-counter watch-fn ) Validators are functions that can check if new states are valid. They take as argument the atom and return a boolean. They are added to the atom as follow ( defn bigger-than-1 [ x ] ( or ( > x 1 ) ( throw ( IllegalStateException. \"That's too small\" )))) ( def account ( atom 2 :validator bigger-than-1 )) ( swap! account inc ) ( swap! account - 10 ) ;; Throw an error ref type are the ACI in the ACID accronym (atomic, consistent and isolated) and use STM . It means that either the operations between two refs happened correctly, or the transaction is aborted. alter and dosync are the key functions. In a transaction (that is the body of dosync ), every ref keep their state to the transaction (invisible to outside threads) and when the transaction tries to commit, every ref checks if the value has been altered by other threads. If any of them has been change, then none of the ref are updated, and the transaction restart with the new value and commits only when the initial states has not been /alter/ed by other processes. commute also allow to change the state of a ref. However, at transaction time, if ref states have been altered, only the commute part is run again with the new states, which might lead to inconsistent state, but increased performance. ensure function protects refs from being modified by other transaction. This is helpful, when a transaction must modify only one refs, but the other related refs must not be altered by other transaction. 5. vars are associations between symbols and objects. ^:dynamic is a keyword in def to signal to clojure that a vars is dynamic. Varnames are enclosed around * (e.g. *user-email* ) to show to other programmers that the variable is dynamic. bindings is a dynamic let . Dynamic vars are often use to name a resource that one ore more functions target. set! allows to change the state of the dynamic vars. alter-var-root allows to rebind a immutable vars (which is unadvised), and with-redefs allows to create local binding for testing. 6. pmap and the following ppmap can be used to execute parallel task: ( defn ppmap \"Partitioned pmap, for grouping map ops together to make parallel overehead worthwile\" [ grain-size f & colls ] ( apply concat ( apply pmap ( fn [ & pgroups ] ( doall ( apply map f pgroups ))) ( map ( partial partition-all grain-size ) colls ))))","title":"References type     :concurrency:epochal_time_model:"},{"location":"cards/20200430160432-clojure_for_the_brave_and_the_true/#coreasync-and-channels-core_async","text":"chan creates a channel. And channel communicate through messages . One can put and take message. Processes wait for completion of their message. Process: Wait and do nothing until successful completion of either put or take from a channel. After success of the operation, continue. go and their blocks ( go blocks ) runs separately on a concurrent thread. go creates a process (i.e. its go block), which runs a pool of threads equal two plus the number of machines cores (avoiding the overhead of creating threads). Each go block only live until it reach the ends of its body. <! and <!! are the take function. It listen to the channel and wait until an another process puts a value in the channel which the take function returns. >! and >!! are the put function which always return true. It provides a message to a channel and wait until the message to be taken by another process before releasing resources. The number of ! in the operation depends if one is inside a go block (one ! ) or not (two ! ). Blocking and parking waiting are key to understand the number of ! . Parking wait allows a thread to handle several process (and this is only possible in a go block ). When one of the process starts to wait, the thread put it aside and starts an another process until it starts to wait, and so on. Use poll! and offer! to have non blocking channel interactions in the REPL. Channel buffers are created as following: ( def buffer-size 2 ) ( def channel-buffer ( chan buffer-size )) This means we can create 2 values without waiting for a response. sliding-buffer (FIFO) and dropping-buffer (LIFO) can be used to discard channel message without blocking. 5. close! closes channel. A closed channel does not accept any puts anymore and after all the values have been retrieved, the subsequent takes return nil . 6. alts!! lets us use the result of the first successful channel operation among a collection of channel operations. The elegant solution with alts!! is one can define a timeout ( let [[ message channel ] ( alts!! [ c1 c2 ( timout 20 )])] ;; c1 and c2 are predefined channels. ( println message )) if the timeout is the first to finish than message is nil . See alt! macro as well. 7. Queues and pipelines (escaping the callback hell) are common patterns.","title":"core.async and channels     :core_async:"},{"location":"cards/20200430160432-clojure_for_the_brave_and_the_true/#abstraction-and-polymorphism","text":"Multimethods ( defmulti method-name ( fn [ x ] ( :type x ))) ;; or simplty :type, can be more complicated as well ( defmethod method-name :hello [ x ] \"Hello\" ) ( defmethod method-name :good-bye [ x ] \"Good-bye\" ) ( defmethod method-name :default [ x ] \"I don't know you\" ) ( method-name { :type :hello }) ; => Hello ( method-name { :type :good-bye }) ; Good-bye ( method-name { :type :what? }) ; => I don't know you One can also create hierarchies with derive and namespace keywords. 2. A protocol allows to make dispatch by the type of the first argument and it is a collection of polymorphic operations (unlike multimethod which is just one function). Methods from protocols can not have a & rest argument. Key functions are defprotocol , extend-type , extend-protocol (for specifying for several type at once). - Caveat: methods from protocols are property of the namespace and not from the object. 3. Records are extension of hash-map . ( defrecord WereWolf [ name title ]) ( WereWolf. \"David\" \"Master\" ) ( ->WereWolf \"David\" \"Master\" ) ( map->WereWolf { :name \"David\" :title \"Master\" }) On has to use the :import: statement in the ns macro in order to import records. One can access field through the keyword or the dot . macro. ( .name ( WereWolf. \"David\" \"Master\" )) ; \"David\" ( :title ( WereWolf. \"David\" \"Master\" )) ; \"Master\" Any function on map works on record (although they do not retain their class if one dissoc or assoc them). Here is how one could extend a protocol. ( defprotocol WereCreature \"Awesom Were\" ( full-moon-behavior [ x ] \"Full-moon behavior\" )) ( defrecord WereWolf [ name title ] WereCreature ( full-moon-behavior [ x ] ( str name \" will kill everyone\" ))) ( full-moon-behavior ( WereWolf. \"David\" \"Master\" )) deftype , reify , proxy . reify is about implementing an anonymous protocol at runtime.","title":"Abstraction and polymorphism"},{"location":"cards/20200430160432-clojure_for_the_brave_and_the_true/#link","text":"Brave and the True","title":"Link"},{"location":"cards/20200430160432-clojure_for_the_brave_and_the_true/#see-also-generated","text":"<../decks/clojure.md> <../todo.md> <20200430141226-life_in_dynamic_typing.md> <20200430141609-david_nolen.md> <20200430154352-cli_arguments.md> <20200430154528-multiple_environment.md> <20200430155438-mastering_clojure_macro.md> <20200430155637-applied_clojure.md> <20200430155819-core_async.md> <20200430235013-specs.md> <20200502122138-simple_made_easy.md> <20200503222619-org_roam_clj.md> <20200504204808-why_clojure.md> <20200504212017-edn_and_transit.md> <20200505112138-clojure_reducers.md>","title":"See also (generated)"},{"location":"cards/20200430180442-org_mode/","text":"Org mode \u00b6 tags: org-mode Orgmk allows to use command line for exporting org files. org2gfm [ OPTION ] FILE Tricks \u00b6 Changing timestamp status . shift-up/down on the delimiters. See also (generated) \u00b6 <../README.md>","title":"Org mode"},{"location":"cards/20200430180442-org_mode/#org-mode","text":"tags: org-mode Orgmk allows to use command line for exporting org files. org2gfm [ OPTION ] FILE","title":"Org mode"},{"location":"cards/20200430180442-org_mode/#tricks","text":"Changing timestamp status . shift-up/down on the delimiters.","title":"Tricks"},{"location":"cards/20200430180442-org_mode/#see-also-generated","text":"<../README.md>","title":"See also (generated)"},{"location":"cards/20200430190921-design/","text":"Design \u00b6 Design, Composition and Performance - Rich Hickey [2013] \u00b6 Summary \u00b6 Design is about taking things apart in such a way we can recompose them again. There are numerous concepts we should take apart (needs to problem, information to mechanism, knowns to unknowns, domain to technological solution, benefits and tradeoffs of solutions.) Design is an effective way to reduce the cost of bugs and to test our software as test now embeds the value of our design. Composition is about constraints and communication. A composition is a design, or a plan for the performer. Bigger scales require more precision and lower scale allows more freedom to the performer. Performance is about preparation, study and experience. It is the ability to bring our knowledge and our experience to solve the problem on a given context. Most coders stop learning after college which is a contrast to any artistic career who are lifelong learners. Both activities requires a sensibility about harmony (in a given context, will two things work well together?). Programming languages are like instruments. As such, we should chose those who are backing some fundamental idea (e.g. immutability, functional programming) and chose those who are aimed to those who have studied the language. In software engineering, everything is code all the way down. Hence we have a paralysis of choice and distraction (we can improve any part of the problem). Making choices, and hence putting constraints move us forward. Thus, the value of the design is based on the decision made. In conclusion, good design is about taking things about such that we can put them back together, we should compose by requiring as much constraint as possible, perform by preparing and studying and finally choose and learn simple tools aimed to experts. Notes \u00b6 Disclamer (joke): analogies are like equivalence, except when they are not. Design by definition is about to prepare the plans for (a work to be executed), especially to plan the form and the structure of. Execution is interesting as someone or a machine will perform the work. The root is to mark out, to make a plan and write it down. The value proposition of design: the bugs are the cheapest at design phases, when they are good. What is a good design? Good design is about taking things apart. We want to separating and break down things into several pieces in such a way that they can be put together again, i.e. recomposed. Each component should be about one or a few things. We solve a problem by composing the parts and it is iterative. Design is about taking things apart. Requirements: move from the want/need to the problems. Take the features and requirements and break them down into a problems perspective. We can explicit the knowns to the unknowns (what do we know how to do, from what we don\u2019t know how to do?). Requirement from the domain side (what does the information encodes and what purpose its transformation will it serve for the customer) to the solution side (on which technology should the code run). We can split the cause and the symptom for the problem (how do you solve a black screen problem?), and explicit the unstated requirement (e.g. should not destroy the machine or crash), these are the state we should to avoid. We should transform the set all of need/features to the intrinsic problems. Time, order and flow: In which ordering are the operation to happen, can they be commutative? Queues. Idempotency (redundant activity), transactions (operations have to happen together at the same time). Place, participants: Who (developer) is participating into the process? Which processes (which systems)? Planing about independent development. Information and mechanism: Which components belongs to the information or business problem, and which belongs to the technical solution. Information is usually a logical abstract idea (the sets of users) against a language construct to represent them (=#{:a :b :c}). It is information against the mechanics of a program. Solutions: We have to compare multiple solutions and state their benefits and trade offs, costs and problem fit (if the solution is not too larger to the problem). Why Design? We can understand the system (because design is smaller). Coordination (for writing the code). Extension and reuse (the broken pieces of system become connecting points, and new pieces can be connected to the pieces and thus extend them). As the pieces are independent, they can be reuse in other contexts as well. Testing is facilitated as the design constraints are put into test, in opposition as tests driving the design (quickcheck is interesting we need to think at properties and the computer write the test). Efficiency : the easiest and cheapest way to remove bugs is at design phases, even after shipping, the solution for bugs in the field is to break things even more. Composition is about addressing self imposed problems and constraints. Learning requires inefficiency. Constraint is a driver of creativity. So we should ask as much constraint as possible when solving a problem. We are forced to take a choice and move on. Composition is designed for performers and is an organizational challenge. In composition, there is a vast variety of specificity and scale (fully orchestrated, arranged, larger scales in opposition to melody and changes, increased latitude for performance and more responsibility). Most composition are about one or a few things. (melodic, harmonic, rhythmic, timbral ideas). Theme: variations, resolutions, larger works, provides more structural components. Improvisation (not foreseen or provided). The melody and the changes and provides constraints. The performer provides variations. Improvisation (well executed) requires a tremendous amount of preparation, practice and study . It is about dynamic composition of planned material. The skill is about preparation of plans, material or sensibilities and apply them in the correct situation. Deep knowledge and vocabulary is necessary. Harmony (accord, congruity, how does things line up in simultaneous combinations). How do things work together when applied at the same time? It might also be the art or science concerned with the structure and combination. Harmonic sensibility is a key design skill . A good designer knows, in a given context, if they make new choices, the pieces will be harmonious (or work together), and the knowledge is acquired through study and experience. In the context of music, great composer and performers were masters of harmony, and they were students of harmoniousness. They went beyond the rules, they developed their own comprehension. They made new systems that preserver/explore harmonic essences. Programming languages are more like instruments. Most instrument are about one excitation (pluck, vibrate, strike), combined with control and interface to shape the excitation, with the projection (the problem is how people will hear the sound). They all also have the resonance problem (the body of the instrument will respond to the excitation). Instruments are limited (piano can\u2019t play in-between notes, saxophone can only play one note at a time). They are minimal yet sufficient (no missing notes usually). The shortcomings might be overcome by the player. Instruments are made for people who can play them. But beginners are not players yet. So we should stop designing languages for maximizing the first 5 minutes of experience of a language and we should target long term productivity. (The talk make criticism about cello which should auto-tunes, having green/red lights for good bad notes, or should note make any sound until the whole piece is played perfectly). The first critic is about coercion/javascript and the second one is about IDE, and the third is about static type compile checking (which would not run your program until it is self consistent with the types rules). Learning requires inefficiency. Players endures pains to overcome and learn instruments. Humans are incredible, good learners and good teachers. Minimizing beginners effort as primary goal will never allow them to reach virtuous abilities with the tools. So teaching and learning are not effort-free. We are all novices (beginner for only a really brief moment). We are permanently students. It takes efforts. Overcoming effort and accomplishing things provides a sense of engagement (effort matters). Instruments (and tools) are usually for one user. We should practice and plan much more than performing. Coders spend more time performing than studying (unlike other creative people). In order to be creative you hate to know how to prepare to be creative \u2013 Twyla Tharp, The Creative Habit. There is too much focus and emphasis on how fast a beginner can accomplish some things against what is required to be effective in the real world. Electronic instruments are at the intersection of art and computer software. In their construction, there are two types of interfaces: machine and human. The instrument makers were smart as they built a human interface on top the machine interface allowing to compose. In contrast in IT, we have two examples where human interface were designed first and brings a lot of problems: SQL and UNIX. When we need to programmatically interface with these, we need to smash strings together or parse the output from a another process. Design can also be layered and people are concerned with different matters. But for IT: code all the way down, we have the same mechanism at every layer (it does mean we can do filter design). It leads to distraction and unnecessary expansion. It yields the paralysis of choice (we don\u2019t know what to do). We need the impetus of constraint. Constraint drives creativity as it helps to move forward (when we have a few choices, we need to make a choice and move on). We need to quit fidgeting (agglomerating, fiddling, tweakling). Maybe a lot of good ideas does not lead to a good construct. Design is imagining (potential solutions) and embrace constraints, rush to them, create additional if not enough restrictive. It is optimistic , be positive and imagine a lot. Design is about making decisions. The value conveyed is in decisions made . Admit very little, and ability to say no. Leaving all options open is avoiding design. Performing is preparing (planning). We should practice and study. Develop sensibilities you can apply on the fly (pattern, techniques, knowledge what works and what not). Design is about taking things apart in order to be able to pull them back together. Design like Bartok ( communicate very well at multiple levels). Code like Coltrane ( prepare, study and experience , by doing multiple different things and not the same thing over and over), such that it feels more like improvisation. Find and choose tools that are like instruments (stable, simple , directed at one thing, and oriented around people who know how to use them). They should express and backing some fundamental idea (or excitation for instruments). Try to pursue harmony in the design, about the nature of harmoniousness, about what make things work together in a given context. Source \u00b6 Design, Composition, and Performance - Rich Hickey Solving Problems the Clojure Way - Rafal Dittwald [2019] \u00b6 Pure functions everywhere. Minimize the number of mutable state. Concentrate the mutable parts into a few objects, like re-frame global state Defer side effects to the edge (end) of the program, like re-frame effects. Data first, something like configuration driven development . Put parts of your code into configuration. Source: \u00b6 Solving Problems the Clojure Way - Rafal Dittwald See also (generated) \u00b6 <../decks/clojure.md> <20200430155637-applied_clojure.md> <20200502122138-simple_made_easy.md> <20200504213225-rich_hickey.md>","title":"Design"},{"location":"cards/20200430190921-design/#design","text":"","title":"Design"},{"location":"cards/20200430190921-design/#design-composition-and-performance-rich-hickey-2013","text":"","title":"Design, Composition and Performance - Rich Hickey [2013]"},{"location":"cards/20200430190921-design/#summary","text":"Design is about taking things apart in such a way we can recompose them again. There are numerous concepts we should take apart (needs to problem, information to mechanism, knowns to unknowns, domain to technological solution, benefits and tradeoffs of solutions.) Design is an effective way to reduce the cost of bugs and to test our software as test now embeds the value of our design. Composition is about constraints and communication. A composition is a design, or a plan for the performer. Bigger scales require more precision and lower scale allows more freedom to the performer. Performance is about preparation, study and experience. It is the ability to bring our knowledge and our experience to solve the problem on a given context. Most coders stop learning after college which is a contrast to any artistic career who are lifelong learners. Both activities requires a sensibility about harmony (in a given context, will two things work well together?). Programming languages are like instruments. As such, we should chose those who are backing some fundamental idea (e.g. immutability, functional programming) and chose those who are aimed to those who have studied the language. In software engineering, everything is code all the way down. Hence we have a paralysis of choice and distraction (we can improve any part of the problem). Making choices, and hence putting constraints move us forward. Thus, the value of the design is based on the decision made. In conclusion, good design is about taking things about such that we can put them back together, we should compose by requiring as much constraint as possible, perform by preparing and studying and finally choose and learn simple tools aimed to experts.","title":"Summary"},{"location":"cards/20200430190921-design/#notes","text":"Disclamer (joke): analogies are like equivalence, except when they are not. Design by definition is about to prepare the plans for (a work to be executed), especially to plan the form and the structure of. Execution is interesting as someone or a machine will perform the work. The root is to mark out, to make a plan and write it down. The value proposition of design: the bugs are the cheapest at design phases, when they are good. What is a good design? Good design is about taking things apart. We want to separating and break down things into several pieces in such a way that they can be put together again, i.e. recomposed. Each component should be about one or a few things. We solve a problem by composing the parts and it is iterative. Design is about taking things apart. Requirements: move from the want/need to the problems. Take the features and requirements and break them down into a problems perspective. We can explicit the knowns to the unknowns (what do we know how to do, from what we don\u2019t know how to do?). Requirement from the domain side (what does the information encodes and what purpose its transformation will it serve for the customer) to the solution side (on which technology should the code run). We can split the cause and the symptom for the problem (how do you solve a black screen problem?), and explicit the unstated requirement (e.g. should not destroy the machine or crash), these are the state we should to avoid. We should transform the set all of need/features to the intrinsic problems. Time, order and flow: In which ordering are the operation to happen, can they be commutative? Queues. Idempotency (redundant activity), transactions (operations have to happen together at the same time). Place, participants: Who (developer) is participating into the process? Which processes (which systems)? Planing about independent development. Information and mechanism: Which components belongs to the information or business problem, and which belongs to the technical solution. Information is usually a logical abstract idea (the sets of users) against a language construct to represent them (=#{:a :b :c}). It is information against the mechanics of a program. Solutions: We have to compare multiple solutions and state their benefits and trade offs, costs and problem fit (if the solution is not too larger to the problem). Why Design? We can understand the system (because design is smaller). Coordination (for writing the code). Extension and reuse (the broken pieces of system become connecting points, and new pieces can be connected to the pieces and thus extend them). As the pieces are independent, they can be reuse in other contexts as well. Testing is facilitated as the design constraints are put into test, in opposition as tests driving the design (quickcheck is interesting we need to think at properties and the computer write the test). Efficiency : the easiest and cheapest way to remove bugs is at design phases, even after shipping, the solution for bugs in the field is to break things even more. Composition is about addressing self imposed problems and constraints. Learning requires inefficiency. Constraint is a driver of creativity. So we should ask as much constraint as possible when solving a problem. We are forced to take a choice and move on. Composition is designed for performers and is an organizational challenge. In composition, there is a vast variety of specificity and scale (fully orchestrated, arranged, larger scales in opposition to melody and changes, increased latitude for performance and more responsibility). Most composition are about one or a few things. (melodic, harmonic, rhythmic, timbral ideas). Theme: variations, resolutions, larger works, provides more structural components. Improvisation (not foreseen or provided). The melody and the changes and provides constraints. The performer provides variations. Improvisation (well executed) requires a tremendous amount of preparation, practice and study . It is about dynamic composition of planned material. The skill is about preparation of plans, material or sensibilities and apply them in the correct situation. Deep knowledge and vocabulary is necessary. Harmony (accord, congruity, how does things line up in simultaneous combinations). How do things work together when applied at the same time? It might also be the art or science concerned with the structure and combination. Harmonic sensibility is a key design skill . A good designer knows, in a given context, if they make new choices, the pieces will be harmonious (or work together), and the knowledge is acquired through study and experience. In the context of music, great composer and performers were masters of harmony, and they were students of harmoniousness. They went beyond the rules, they developed their own comprehension. They made new systems that preserver/explore harmonic essences. Programming languages are more like instruments. Most instrument are about one excitation (pluck, vibrate, strike), combined with control and interface to shape the excitation, with the projection (the problem is how people will hear the sound). They all also have the resonance problem (the body of the instrument will respond to the excitation). Instruments are limited (piano can\u2019t play in-between notes, saxophone can only play one note at a time). They are minimal yet sufficient (no missing notes usually). The shortcomings might be overcome by the player. Instruments are made for people who can play them. But beginners are not players yet. So we should stop designing languages for maximizing the first 5 minutes of experience of a language and we should target long term productivity. (The talk make criticism about cello which should auto-tunes, having green/red lights for good bad notes, or should note make any sound until the whole piece is played perfectly). The first critic is about coercion/javascript and the second one is about IDE, and the third is about static type compile checking (which would not run your program until it is self consistent with the types rules). Learning requires inefficiency. Players endures pains to overcome and learn instruments. Humans are incredible, good learners and good teachers. Minimizing beginners effort as primary goal will never allow them to reach virtuous abilities with the tools. So teaching and learning are not effort-free. We are all novices (beginner for only a really brief moment). We are permanently students. It takes efforts. Overcoming effort and accomplishing things provides a sense of engagement (effort matters). Instruments (and tools) are usually for one user. We should practice and plan much more than performing. Coders spend more time performing than studying (unlike other creative people). In order to be creative you hate to know how to prepare to be creative \u2013 Twyla Tharp, The Creative Habit. There is too much focus and emphasis on how fast a beginner can accomplish some things against what is required to be effective in the real world. Electronic instruments are at the intersection of art and computer software. In their construction, there are two types of interfaces: machine and human. The instrument makers were smart as they built a human interface on top the machine interface allowing to compose. In contrast in IT, we have two examples where human interface were designed first and brings a lot of problems: SQL and UNIX. When we need to programmatically interface with these, we need to smash strings together or parse the output from a another process. Design can also be layered and people are concerned with different matters. But for IT: code all the way down, we have the same mechanism at every layer (it does mean we can do filter design). It leads to distraction and unnecessary expansion. It yields the paralysis of choice (we don\u2019t know what to do). We need the impetus of constraint. Constraint drives creativity as it helps to move forward (when we have a few choices, we need to make a choice and move on). We need to quit fidgeting (agglomerating, fiddling, tweakling). Maybe a lot of good ideas does not lead to a good construct. Design is imagining (potential solutions) and embrace constraints, rush to them, create additional if not enough restrictive. It is optimistic , be positive and imagine a lot. Design is about making decisions. The value conveyed is in decisions made . Admit very little, and ability to say no. Leaving all options open is avoiding design. Performing is preparing (planning). We should practice and study. Develop sensibilities you can apply on the fly (pattern, techniques, knowledge what works and what not). Design is about taking things apart in order to be able to pull them back together. Design like Bartok ( communicate very well at multiple levels). Code like Coltrane ( prepare, study and experience , by doing multiple different things and not the same thing over and over), such that it feels more like improvisation. Find and choose tools that are like instruments (stable, simple , directed at one thing, and oriented around people who know how to use them). They should express and backing some fundamental idea (or excitation for instruments). Try to pursue harmony in the design, about the nature of harmoniousness, about what make things work together in a given context.","title":"Notes"},{"location":"cards/20200430190921-design/#source","text":"Design, Composition, and Performance - Rich Hickey","title":"Source"},{"location":"cards/20200430190921-design/#solving-problems-the-clojure-way-rafal-dittwald-2019","text":"Pure functions everywhere. Minimize the number of mutable state. Concentrate the mutable parts into a few objects, like re-frame global state Defer side effects to the edge (end) of the program, like re-frame effects. Data first, something like configuration driven development . Put parts of your code into configuration.","title":"Solving Problems the Clojure Way - Rafal Dittwald [2019]"},{"location":"cards/20200430190921-design/#source_1","text":"Solving Problems the Clojure Way - Rafal Dittwald","title":"Source:"},{"location":"cards/20200430190921-design/#see-also-generated","text":"<../decks/clojure.md> <20200430155637-applied_clojure.md> <20200502122138-simple_made_easy.md> <20200504213225-rich_hickey.md>","title":"See also (generated)"},{"location":"cards/20200430235013-specs/","text":"Specs \u00b6 Rationale Guide Summary \u00b6 This is a quick summary of the official guide in Clojure. The goal is to gather most function in a single place and also acts as a reminder. High leverage on specifying entities in Clojure code. Adds validation Conformance Documentation Generative testing Specs are predicates and can be composed with the assigned keys. You want to add this dependency at test time for generative testing ;; deps.edn { :aliases { :dev { :extra-deps { org.clojure/test.check { :mvn/version \"1.0.0\" }}}}} Definitions \u00b6 s/def defines specs (with fully qualified keys). s/valid and s/conform are the most important function for checking on runtime the specifications of input/output. ( require ' [ clojure.spec.alpha :as s ]) ( s/def :image/size ( s/cat :height pos-int? :width pos-int? :depth pos-int? )) ( s/conform :image/size [ 10 23 4 ]) ;; useful for turning tuples into maps ;; => {:height 10, :width 23, :depth 4} ( s/valid? :image/size [ 10 23 4 ]) ;; => true ( s/valid? :image/size [ 10 23 \"s\" ]) ;; => false ( s/valid? :image/size [ 10 23 -1 ]) ;; => false Composition is achieved with s/and and s/or ( s/def ::big-even ( s/and pos-int? even? # ( > % 1000 ))) ( s/def ::identifier ( s/or :name string? :id pos-int? )) ( s/conform ::identifier \"abc\" ) ( s/conform ::identifier 100 ) explain allows to have data on why a spec is failing. Entities map \u00b6 Entities map are defined with s/keys and has the req , req-un , opt , opt-un keywords argument ( un stands for unqualified keys). Sequential keyword arguments can be defined with the s/keys* function which will check vector of keywords-values pair. You can use s/and and s/or with the keys for a finer definition of membership of keys (for example when a field in a map, then other keys are required and having different element conforming). For example, either an email or a id string is required being conform. Collection \u00b6 Collection has s/cat , s/coll-of , s/every , s/map-of , s/every-kv , s/tuple . The last one is the most permissive as it similar product type. every and every-kv are suitable for large collection as they will not conform their value (trade off against coll-of and map-of is error message are less detailed). ( s/def ::point-0 ( s/tuple double? double? )) ( s/def ::x double? ) ( s/def ::y double? ) ( s/def ::point-1 ( s/tuple ::x ::y )) ( s/def ::point-2 ( s/cat :x double? :y double? )) ( s/def ::point-3 ( s/coll-of? double? )) ;; additional arguments: :kind (type such as vector?) ;; :count (exact) :min-count (minimal) :max-count (maximal) :distinct (unique ;; values) :into ([] {} () #{}) Multi specs \u00b6 You can use multimethods to define multi-specs. Useful for conforming maps depending on certain keys. ( defmulti event-type :event/type ) ( defmethod event-type :event/search [ _ ] ( s/keys :req [ :event/type :event/timestamp :search/url ])) ( defmethod event-type :event/error [ _ ] ( s/keys :req [ :event/type :event/timestamp :error/message :error/code ])) ( s/def :event/type keyword? ) ;; this will be used by multi-spec ;; the last argument is used for generative testing ( s/def :event/event ( s/multi-spec event-type :event/type )) ( s/valid? :event/event { :event/type :event/search :event/timestamp 1463970123000 :search/url \"https://clojure.org\" }) ;; => true ( s/explain :event/event { :event/type :event/search :search/url 200 }) ;; fails because missing timestamp ;; 200 - failed: string? in: [:search/url] ;; at: [:event/search :search/url] spec: :search/url ;; {:event/type :event/search, :search/url 200} - failed: (contains? % :event/timestamp) ;; at: [:event/search] spec: :event/event Sequence specs \u00b6 Sequences can be expressed with the regular expression operators s/cat , s/alt , s/* , s/+ , s/? . s/alt is difference from or as it will select one precisely and is usually use with s/cat . You can s/describe to take the description of a spec. s/& allows to combine and regex operators and additional predicates. s/spec should be used for nesting regex specs. ( s/def ::nested ( s/cat :names-kw # { :names } :names ( s/spec ( s/* string? )) :nums-kw # { :nums } :nums ( s/spec ( s/* number? )))) ( s/conform ::nested [ :names [ \"a\" \"b\" ] :nums [ 1 2 3 ]]) ;; => {:names-kw :names, :names [\"a\" \"b\"], :nums-kw :nums, :nums [1 2 3]} ( s/def ::unnested ( s/cat :names-kw # { :names } :names ( s/* string? ) :nums-kw # { :nums } :nums ( s/* number? ))) ( s/conform ::unnested [ :names \"a\" \"b\" :nums 1 2 3 ]) ;; => {:names-kw :names, :names [\"a\" \"b\"], :nums-kw :nums, :nums [1 2 3]} Validation \u00b6 Assertion can be done with s/assert , on success the value is returned on failure assertion error is thrown. Default is assertion checking is off, and can be change with s/check-asserts . Using s/conform , the result is either conformed, or ::s/invalid which is a special key and can be used for throwing errors. ;; ex-info stands for exception info ( when ( = ( s/conform ::config input ) ::s/invalid ) ( throw ( ex-info \"Invalid input\" ( s/explain-data ::config input )))) Functions specs \u00b6 s/fdef defines spec of a function while s/fspec allows to defines a generic function signature. The keys are :args , :ret and :fn all accepts predicates/specs as argument. The :fn keyword arguments is special as it is meant for defining properties of the function for generative testing (similar to prop/for-all in test.check ). The properties can be enforced on the argument (preconditions) on the result (post conditions) or on a relationship between the arguments and the return value or some invariant properties on the function call itself. See Generative Testing . Generation \u00b6 The main namespace is ( require ' [ clojure.spec.gen.alpha :as gen ]) and the function are gen/generate , gen/sample allows to generate value from the specs. If you want to conformed data as well you can use the s/exercise for sample value and conformed and s/exercise-fn to see to see sample arguments and results. An example of generation is ( require ' [ clojure.spec.alpha :as s ]) ( require ' [ clojure.spec.gen.alpha :as gen ]) ( s/def ::x pos-int? ) ( gen/generate ( s/gen ::x )) ;; => 12734020 ( gen/sample ( s/gen ::x )) ;; => (1 1 2 4 4 7 3 55 4 10) ( gen/sample ( s/gen ::x ) 3 ) ;; => (2 2 2) ( s/def ::m ( s/map-of keyword? pos-int? :min-count 2 )) ( s/exercise ::m 1 ) ( let [ custom-gen ( gen/bind ( s/gen ::m ) ( fn [ m ] ( gen/tuple ( gen/return m ) ( gen/vector-distinct ( gen/elements ( keys m )) { :min-elements 2 }))))] ( gen/sample custom-gen 10 )) Custom generation \u00b6 Three ways to create generators: spec create from the predicates, create our own with spec.gen and use test.check or compatible (such as test.chuk ), last options requires runtime dependence on test check (so first two are strongly recommended). The main functions are gen/fmap (returns a value from a generator) or gen/bind (returns a generator from a generator). Using test.check/let allows to use gen/bind with sanity. ( s/def ::kws ( s/with-gen ( s/and keyword? # ( = ( namespace % ) \"my.domain\" )) # ( s/gen # { :my.domain/name :my.domain/occupation :my.domain/id }))) ( gen/sample ( s/gen ::kws )) ( def kw-gen-2 ( gen/fmap # ( keyword \"my.domain\" % ) ( gen/string-ascii ))) ( gen/sample kw-gen-2 10 ) ( def kw-gen-3 ( gen/fmap # ( keyword \"my.domain\" % ) ( gen/such-that # ( not= % \"\" ) ( gen/string-alphanumeric )))) ( gen/sample kw-gen-3 5 ) ;; this is what we call using a model to generate our output ( s/def ::hello ( s/with-gen # ( clojure.string/includes? % \"hello\" ) # ( gen/fmap ( fn [[ s1 s2 ]] ( str s1 \"hello\" s2 )) ( gen/tuple ( gen/string-alphanumeric ) ( gen/string-alphanumeric ))))) ( gen/sample ( s/gen ::hello )) Testing \u00b6 Instrumentation is to validate the input argument (the :args key), whereas checking is for testing with random input and all the :args , :ret , :fn keys. ( require ' [ clojure.spec.test.alpha :as stest ]) ( require ' [ clojure.spec.alpha :as s ]) ( defn ranged-rand \"Returns random int in range start <= rand < end\" [ start end ] ( + start ( long ( rand ( - end start ))))) ( s/def ::int int? ) ( s/fdef ranged-rand :args ( s/and ( s/cat :start ::int :end ::int ) # ( < ( :start % ) ( :end % ))) :ret int? :fn ( fn [{ :keys [ args ret ]}] ( s/and # ( >= ret ( :start args )) # ( < ret ( :end args ))))) ( doc ranged-rand ) ( s/exercise-fn ` ranged-rand ) ( stest/check ` ranged-rand ) ( stest/check ` ranged-rand { :gen { ::int # { 2 5 7 10 }}}) In order to check all function in a given namepsace you can use enumerate-namespace . ( -> ( stest/enumerate-namespace 'user ) stest/check ) When stest/instrument is applied to a function, it can take options on function and the stub keys takes a spec x as a value which replace the function invokation by a generated value from the spec x . Hence it useful for testing systems without invoking server and side effects/IO. Tricks \u00b6 Check membership \u00b6 Use sets to check for membership ( s/def ::assets # { :equity :fixed-income :commodity :etf :products }) ( s/valid? ::assets :equity ) ; => true ( s/valid? ::assets :spx ) ; => false Check relationship between values of a map \u00b6 ( s/def ::dates ( s/coll-of inst? )) ( s/def ::values ( s/coll-of double? )) ( s/def ::timeseries ( s/and ( s/keys :req-un [ ::dates ::values ]) # ( let [{ :keys [ dates values ]} % ] ( = ( count dates ) ( count values ))))) Generic function signature \u00b6 ( defn f [ x y ] x ) ( defn g [ x y ] y ) ( s/def ::f ( s/fspec :args ( s/coll-of int? ) :ret int? )) ( s/fdef f ::f ) ( s/fdef g ::f ) Properties \u00b6 See Generative Testing . Share specs over the wire \u00b6 You can use the s/form function to get the definitions of the specs ( s/def ::a ( s/and even? pos-int? )) ( s/def ::m ( s/keys :req [ ::a ])) ( s/form ::a ) ;; => (clojure.spec.alpha/and clojure.core/even? clojure.core/pos-int?) ( s/form ::m ) ;; => (clojure.spec.alpha/keys :req [:user/a]) test.check \u00b6 Generative testing \u00b6 Using the namespace ( require ' [ test.check.generators :as gen ]) ;; or ( require ' [ clojure.spec.gen.alph :as gen ]) The following are combinators of simple generators gen/vector gen/vector-distinct gen/tuple ;; concatenate the generator gen/one-of ;; random choice of generator gen/frequency ;; distribution of generators gen/such-that ;; conditions for generation gen/fmap ;; returns a value from a generator gen/bind ;; returns a new generator gen/let ;; sane macro for using bind. Links \u00b6 https://github.com/clojure/test.check , quick check implementation in Clojure. https://github.com/clojure/test.check/blob/master/doc/cheatsheet.md https://github.com/metosin/spec-tools , tools for clojure.spec https://github.com/jeaye/orchestra , complete instrumentation for clojure.spec. https://github.com/bhb/expound , improved specs errors message. https://github.com/bhauman/spell-spec , spell checker for keys in map entities. https://github.com/reifyhealth/specmonstah , simulation of database state given specs and a schema. https://github.com/stathissideris/spec-provider , infer clojure specs from sample data. https://github.com/gnl/ghostwheel sane notation for fdef. Clojure cheat sheet https://blog.taylorwood.io/2018/10/15/clojure-spec-faq.html , good FAQ https://blog.taylorwood.io/2017/10/15/fspec.html , good details about fspec See also (generated) \u00b6 <../decks/clojure.md> <../todo.md> <20200430141226-life_in_dynamic_typing.md> <20200430155438-mastering_clojure_macro.md> <20200430155637-applied_clojure.md> <20200430160432-clojure_for_the_brave_and_the_true.md> <20200504204808-why_clojure.md> <20200516171955-generative_testing.md>","title":"Specs"},{"location":"cards/20200430235013-specs/#specs","text":"Rationale Guide","title":"Specs"},{"location":"cards/20200430235013-specs/#summary","text":"This is a quick summary of the official guide in Clojure. The goal is to gather most function in a single place and also acts as a reminder. High leverage on specifying entities in Clojure code. Adds validation Conformance Documentation Generative testing Specs are predicates and can be composed with the assigned keys. You want to add this dependency at test time for generative testing ;; deps.edn { :aliases { :dev { :extra-deps { org.clojure/test.check { :mvn/version \"1.0.0\" }}}}}","title":"Summary"},{"location":"cards/20200430235013-specs/#definitions","text":"s/def defines specs (with fully qualified keys). s/valid and s/conform are the most important function for checking on runtime the specifications of input/output. ( require ' [ clojure.spec.alpha :as s ]) ( s/def :image/size ( s/cat :height pos-int? :width pos-int? :depth pos-int? )) ( s/conform :image/size [ 10 23 4 ]) ;; useful for turning tuples into maps ;; => {:height 10, :width 23, :depth 4} ( s/valid? :image/size [ 10 23 4 ]) ;; => true ( s/valid? :image/size [ 10 23 \"s\" ]) ;; => false ( s/valid? :image/size [ 10 23 -1 ]) ;; => false Composition is achieved with s/and and s/or ( s/def ::big-even ( s/and pos-int? even? # ( > % 1000 ))) ( s/def ::identifier ( s/or :name string? :id pos-int? )) ( s/conform ::identifier \"abc\" ) ( s/conform ::identifier 100 ) explain allows to have data on why a spec is failing.","title":"Definitions"},{"location":"cards/20200430235013-specs/#entities-map","text":"Entities map are defined with s/keys and has the req , req-un , opt , opt-un keywords argument ( un stands for unqualified keys). Sequential keyword arguments can be defined with the s/keys* function which will check vector of keywords-values pair. You can use s/and and s/or with the keys for a finer definition of membership of keys (for example when a field in a map, then other keys are required and having different element conforming). For example, either an email or a id string is required being conform.","title":"Entities map"},{"location":"cards/20200430235013-specs/#collection","text":"Collection has s/cat , s/coll-of , s/every , s/map-of , s/every-kv , s/tuple . The last one is the most permissive as it similar product type. every and every-kv are suitable for large collection as they will not conform their value (trade off against coll-of and map-of is error message are less detailed). ( s/def ::point-0 ( s/tuple double? double? )) ( s/def ::x double? ) ( s/def ::y double? ) ( s/def ::point-1 ( s/tuple ::x ::y )) ( s/def ::point-2 ( s/cat :x double? :y double? )) ( s/def ::point-3 ( s/coll-of? double? )) ;; additional arguments: :kind (type such as vector?) ;; :count (exact) :min-count (minimal) :max-count (maximal) :distinct (unique ;; values) :into ([] {} () #{})","title":"Collection"},{"location":"cards/20200430235013-specs/#multi-specs","text":"You can use multimethods to define multi-specs. Useful for conforming maps depending on certain keys. ( defmulti event-type :event/type ) ( defmethod event-type :event/search [ _ ] ( s/keys :req [ :event/type :event/timestamp :search/url ])) ( defmethod event-type :event/error [ _ ] ( s/keys :req [ :event/type :event/timestamp :error/message :error/code ])) ( s/def :event/type keyword? ) ;; this will be used by multi-spec ;; the last argument is used for generative testing ( s/def :event/event ( s/multi-spec event-type :event/type )) ( s/valid? :event/event { :event/type :event/search :event/timestamp 1463970123000 :search/url \"https://clojure.org\" }) ;; => true ( s/explain :event/event { :event/type :event/search :search/url 200 }) ;; fails because missing timestamp ;; 200 - failed: string? in: [:search/url] ;; at: [:event/search :search/url] spec: :search/url ;; {:event/type :event/search, :search/url 200} - failed: (contains? % :event/timestamp) ;; at: [:event/search] spec: :event/event","title":"Multi specs"},{"location":"cards/20200430235013-specs/#sequence-specs","text":"Sequences can be expressed with the regular expression operators s/cat , s/alt , s/* , s/+ , s/? . s/alt is difference from or as it will select one precisely and is usually use with s/cat . You can s/describe to take the description of a spec. s/& allows to combine and regex operators and additional predicates. s/spec should be used for nesting regex specs. ( s/def ::nested ( s/cat :names-kw # { :names } :names ( s/spec ( s/* string? )) :nums-kw # { :nums } :nums ( s/spec ( s/* number? )))) ( s/conform ::nested [ :names [ \"a\" \"b\" ] :nums [ 1 2 3 ]]) ;; => {:names-kw :names, :names [\"a\" \"b\"], :nums-kw :nums, :nums [1 2 3]} ( s/def ::unnested ( s/cat :names-kw # { :names } :names ( s/* string? ) :nums-kw # { :nums } :nums ( s/* number? ))) ( s/conform ::unnested [ :names \"a\" \"b\" :nums 1 2 3 ]) ;; => {:names-kw :names, :names [\"a\" \"b\"], :nums-kw :nums, :nums [1 2 3]}","title":"Sequence specs"},{"location":"cards/20200430235013-specs/#validation","text":"Assertion can be done with s/assert , on success the value is returned on failure assertion error is thrown. Default is assertion checking is off, and can be change with s/check-asserts . Using s/conform , the result is either conformed, or ::s/invalid which is a special key and can be used for throwing errors. ;; ex-info stands for exception info ( when ( = ( s/conform ::config input ) ::s/invalid ) ( throw ( ex-info \"Invalid input\" ( s/explain-data ::config input ))))","title":"Validation"},{"location":"cards/20200430235013-specs/#functions-specs","text":"s/fdef defines spec of a function while s/fspec allows to defines a generic function signature. The keys are :args , :ret and :fn all accepts predicates/specs as argument. The :fn keyword arguments is special as it is meant for defining properties of the function for generative testing (similar to prop/for-all in test.check ). The properties can be enforced on the argument (preconditions) on the result (post conditions) or on a relationship between the arguments and the return value or some invariant properties on the function call itself. See Generative Testing .","title":"Functions specs"},{"location":"cards/20200430235013-specs/#generation","text":"The main namespace is ( require ' [ clojure.spec.gen.alpha :as gen ]) and the function are gen/generate , gen/sample allows to generate value from the specs. If you want to conformed data as well you can use the s/exercise for sample value and conformed and s/exercise-fn to see to see sample arguments and results. An example of generation is ( require ' [ clojure.spec.alpha :as s ]) ( require ' [ clojure.spec.gen.alpha :as gen ]) ( s/def ::x pos-int? ) ( gen/generate ( s/gen ::x )) ;; => 12734020 ( gen/sample ( s/gen ::x )) ;; => (1 1 2 4 4 7 3 55 4 10) ( gen/sample ( s/gen ::x ) 3 ) ;; => (2 2 2) ( s/def ::m ( s/map-of keyword? pos-int? :min-count 2 )) ( s/exercise ::m 1 ) ( let [ custom-gen ( gen/bind ( s/gen ::m ) ( fn [ m ] ( gen/tuple ( gen/return m ) ( gen/vector-distinct ( gen/elements ( keys m )) { :min-elements 2 }))))] ( gen/sample custom-gen 10 ))","title":"Generation"},{"location":"cards/20200430235013-specs/#custom-generation","text":"Three ways to create generators: spec create from the predicates, create our own with spec.gen and use test.check or compatible (such as test.chuk ), last options requires runtime dependence on test check (so first two are strongly recommended). The main functions are gen/fmap (returns a value from a generator) or gen/bind (returns a generator from a generator). Using test.check/let allows to use gen/bind with sanity. ( s/def ::kws ( s/with-gen ( s/and keyword? # ( = ( namespace % ) \"my.domain\" )) # ( s/gen # { :my.domain/name :my.domain/occupation :my.domain/id }))) ( gen/sample ( s/gen ::kws )) ( def kw-gen-2 ( gen/fmap # ( keyword \"my.domain\" % ) ( gen/string-ascii ))) ( gen/sample kw-gen-2 10 ) ( def kw-gen-3 ( gen/fmap # ( keyword \"my.domain\" % ) ( gen/such-that # ( not= % \"\" ) ( gen/string-alphanumeric )))) ( gen/sample kw-gen-3 5 ) ;; this is what we call using a model to generate our output ( s/def ::hello ( s/with-gen # ( clojure.string/includes? % \"hello\" ) # ( gen/fmap ( fn [[ s1 s2 ]] ( str s1 \"hello\" s2 )) ( gen/tuple ( gen/string-alphanumeric ) ( gen/string-alphanumeric ))))) ( gen/sample ( s/gen ::hello ))","title":"Custom generation"},{"location":"cards/20200430235013-specs/#testing","text":"Instrumentation is to validate the input argument (the :args key), whereas checking is for testing with random input and all the :args , :ret , :fn keys. ( require ' [ clojure.spec.test.alpha :as stest ]) ( require ' [ clojure.spec.alpha :as s ]) ( defn ranged-rand \"Returns random int in range start <= rand < end\" [ start end ] ( + start ( long ( rand ( - end start ))))) ( s/def ::int int? ) ( s/fdef ranged-rand :args ( s/and ( s/cat :start ::int :end ::int ) # ( < ( :start % ) ( :end % ))) :ret int? :fn ( fn [{ :keys [ args ret ]}] ( s/and # ( >= ret ( :start args )) # ( < ret ( :end args ))))) ( doc ranged-rand ) ( s/exercise-fn ` ranged-rand ) ( stest/check ` ranged-rand ) ( stest/check ` ranged-rand { :gen { ::int # { 2 5 7 10 }}}) In order to check all function in a given namepsace you can use enumerate-namespace . ( -> ( stest/enumerate-namespace 'user ) stest/check ) When stest/instrument is applied to a function, it can take options on function and the stub keys takes a spec x as a value which replace the function invokation by a generated value from the spec x . Hence it useful for testing systems without invoking server and side effects/IO.","title":"Testing"},{"location":"cards/20200430235013-specs/#tricks","text":"","title":"Tricks"},{"location":"cards/20200430235013-specs/#check-membership","text":"Use sets to check for membership ( s/def ::assets # { :equity :fixed-income :commodity :etf :products }) ( s/valid? ::assets :equity ) ; => true ( s/valid? ::assets :spx ) ; => false","title":"Check membership"},{"location":"cards/20200430235013-specs/#check-relationship-between-values-of-a-map","text":"( s/def ::dates ( s/coll-of inst? )) ( s/def ::values ( s/coll-of double? )) ( s/def ::timeseries ( s/and ( s/keys :req-un [ ::dates ::values ]) # ( let [{ :keys [ dates values ]} % ] ( = ( count dates ) ( count values )))))","title":"Check relationship between values of a map"},{"location":"cards/20200430235013-specs/#generic-function-signature","text":"( defn f [ x y ] x ) ( defn g [ x y ] y ) ( s/def ::f ( s/fspec :args ( s/coll-of int? ) :ret int? )) ( s/fdef f ::f ) ( s/fdef g ::f )","title":"Generic function signature"},{"location":"cards/20200430235013-specs/#properties","text":"See Generative Testing .","title":"Properties"},{"location":"cards/20200430235013-specs/#share-specs-over-the-wire","text":"You can use the s/form function to get the definitions of the specs ( s/def ::a ( s/and even? pos-int? )) ( s/def ::m ( s/keys :req [ ::a ])) ( s/form ::a ) ;; => (clojure.spec.alpha/and clojure.core/even? clojure.core/pos-int?) ( s/form ::m ) ;; => (clojure.spec.alpha/keys :req [:user/a])","title":"Share specs over the wire"},{"location":"cards/20200430235013-specs/#testcheck","text":"","title":"test.check"},{"location":"cards/20200430235013-specs/#generative-testing","text":"Using the namespace ( require ' [ test.check.generators :as gen ]) ;; or ( require ' [ clojure.spec.gen.alph :as gen ]) The following are combinators of simple generators gen/vector gen/vector-distinct gen/tuple ;; concatenate the generator gen/one-of ;; random choice of generator gen/frequency ;; distribution of generators gen/such-that ;; conditions for generation gen/fmap ;; returns a value from a generator gen/bind ;; returns a new generator gen/let ;; sane macro for using bind.","title":"Generative testing"},{"location":"cards/20200430235013-specs/#links","text":"https://github.com/clojure/test.check , quick check implementation in Clojure. https://github.com/clojure/test.check/blob/master/doc/cheatsheet.md https://github.com/metosin/spec-tools , tools for clojure.spec https://github.com/jeaye/orchestra , complete instrumentation for clojure.spec. https://github.com/bhb/expound , improved specs errors message. https://github.com/bhauman/spell-spec , spell checker for keys in map entities. https://github.com/reifyhealth/specmonstah , simulation of database state given specs and a schema. https://github.com/stathissideris/spec-provider , infer clojure specs from sample data. https://github.com/gnl/ghostwheel sane notation for fdef. Clojure cheat sheet https://blog.taylorwood.io/2018/10/15/clojure-spec-faq.html , good FAQ https://blog.taylorwood.io/2017/10/15/fspec.html , good details about fspec","title":"Links"},{"location":"cards/20200430235013-specs/#see-also-generated","text":"<../decks/clojure.md> <../todo.md> <20200430141226-life_in_dynamic_typing.md> <20200430155438-mastering_clojure_macro.md> <20200430155637-applied_clojure.md> <20200430160432-clojure_for_the_brave_and_the_true.md> <20200504204808-why_clojure.md> <20200516171955-generative_testing.md>","title":"See also (generated)"},{"location":"cards/20200501163355-goals/","text":"Goals \u00b6 Leverage TAGS \u00b6 Use #+TAGS options of orgs for generating automatically see also and tags field. [2020-05-04 Mon] . See also (generated) \u00b6 <../todo.md>","title":"Goals"},{"location":"cards/20200501163355-goals/#goals","text":"","title":"Goals"},{"location":"cards/20200501163355-goals/#leverage-tags","text":"Use #+TAGS options of orgs for generating automatically see also and tags field. [2020-05-04 Mon] .","title":"Leverage TAGS"},{"location":"cards/20200501163355-goals/#see-also-generated","text":"<../todo.md>","title":"See also (generated)"},{"location":"cards/20200501201607-quotes/","text":"Quotes \u00b6 Comics \u00b6 The measure of man lies not in what he says but in what he does . \u2013 Johnatan KENT Fiction \u00b6 Si on n\u2019est pas pr\u00eat \u00e0 tout, on n\u2019est pr\u00eat \u00e0 rien. \u2013 Paul AUSTER. A career is wonderful, but you can\u2019t curl up with it on a cold night. \u2013 Marilyn MONROE Science \u00b6 These quote are attributed to Einstein but I am not convinced. You can\u2019t blame gravity for falling in love. Learn from yesterday, live for today, hope for tomorrow. The important thing is not to stop questioning. Try not to become a man of success, but rather try to become a man of value. These, however, are probably from Einstein. Insanity: doing the same thing over and over again and expecting different results. The true sign of intelligence is not knowledge but imagination. The development of general ability for independent thinking and judgment should always be placed foremost. \u2013 Albert EINSTEIN Education \u00b6 Everybody is a genius. But if you judge a dolphin by its ability to climb a tree, it will live its whole life believing that it is stupid. \u2013 Anonymous Professional advice \u00b6 Do all the useless baggage stuff like writing thank-you emails whenever someone notifies you of an error, respond when it\u2019s fixed, and no matter if they care or not, write a quick one-minute explanation of why the error happened in the first place and how you fixed it. \u2013 keypressmonkey Life Style \u00b6 These are inspirational philosophy [but not empirically approved in class room]. Growth mindset is about meaningful and purposed efforts. \u2013 Carol DWECK Grit is passion and sustained persistence applied toward long-term achievement, with no particular concern for rewards or recognition along the way. \u2013 Angela DUCKWORTH There should be a mixed between targeted skills [with clear steps to achieve them] and efforts. Deliberated practice is the key to mastery. Computer Science \u00b6 I don\u2019t know, I don\u2019t want to know. (Rich Hickey) In C++ and now in Haskell, we used to say that If it compiles, it is probably correct. It was as true then, as it is now. (Rich Hickey) Programmers know the benefits of everything and the tradeoffs of nothing. (Rich Hickey) tags: clj See also (generated) \u00b6 <../decks/clojure.md>","title":"Quotes"},{"location":"cards/20200501201607-quotes/#quotes","text":"","title":"Quotes"},{"location":"cards/20200501201607-quotes/#comics","text":"The measure of man lies not in what he says but in what he does . \u2013 Johnatan KENT","title":"Comics"},{"location":"cards/20200501201607-quotes/#fiction","text":"Si on n\u2019est pas pr\u00eat \u00e0 tout, on n\u2019est pr\u00eat \u00e0 rien. \u2013 Paul AUSTER. A career is wonderful, but you can\u2019t curl up with it on a cold night. \u2013 Marilyn MONROE","title":"Fiction"},{"location":"cards/20200501201607-quotes/#science","text":"These quote are attributed to Einstein but I am not convinced. You can\u2019t blame gravity for falling in love. Learn from yesterday, live for today, hope for tomorrow. The important thing is not to stop questioning. Try not to become a man of success, but rather try to become a man of value. These, however, are probably from Einstein. Insanity: doing the same thing over and over again and expecting different results. The true sign of intelligence is not knowledge but imagination. The development of general ability for independent thinking and judgment should always be placed foremost. \u2013 Albert EINSTEIN","title":"Science"},{"location":"cards/20200501201607-quotes/#education","text":"Everybody is a genius. But if you judge a dolphin by its ability to climb a tree, it will live its whole life believing that it is stupid. \u2013 Anonymous","title":"Education"},{"location":"cards/20200501201607-quotes/#professional-advice","text":"Do all the useless baggage stuff like writing thank-you emails whenever someone notifies you of an error, respond when it\u2019s fixed, and no matter if they care or not, write a quick one-minute explanation of why the error happened in the first place and how you fixed it. \u2013 keypressmonkey","title":"Professional advice"},{"location":"cards/20200501201607-quotes/#life-style","text":"These are inspirational philosophy [but not empirically approved in class room]. Growth mindset is about meaningful and purposed efforts. \u2013 Carol DWECK Grit is passion and sustained persistence applied toward long-term achievement, with no particular concern for rewards or recognition along the way. \u2013 Angela DUCKWORTH There should be a mixed between targeted skills [with clear steps to achieve them] and efforts. Deliberated practice is the key to mastery.","title":"Life Style"},{"location":"cards/20200501201607-quotes/#computer-science","text":"I don\u2019t know, I don\u2019t want to know. (Rich Hickey) In C++ and now in Haskell, we used to say that If it compiles, it is probably correct. It was as true then, as it is now. (Rich Hickey) Programmers know the benefits of everything and the tradeoffs of nothing. (Rich Hickey) tags: clj","title":"Computer Science"},{"location":"cards/20200501201607-quotes/#see-also-generated","text":"<../decks/clojure.md>","title":"See also (generated)"},{"location":"cards/20200502122138-simple_made_easy/","text":"Simple Made Easy and Simplicity Matters \u00b6 I am merging notes on both talks into one summary as they deal with the same problem. Summary \u00b6 The talks goes around what the definition of simple and easy, and how as programmers we like complex constructs, because they are familiar and as we are in the conceptual and creative industry, our egos forbid us to accept that some tasks are too complex for us to handle (but especially for familiarity). Simple is an objective measure of how things are entangled, intertwined, not compound, whereas easy has a notion of familiarity and nearness (physical, knowledge and mental capability). Complex is the opposite of simple (when things are braided, tied, or folded together) and hard is the opposite of easy. When accessing the output of work, we should consider the properties of the artifacts (that thing that was made) more than those of the constructs. Is it effective? Understandable? Modifiable? Can be debugged? In contrast, none of our customer will care how easy it was to create the artifact if it does not fulfill the previous objectives. Simplicity matters as our cognitive ability to handle complexity is limited, hence complexity undermines the ability to think in isolation. Complexity affects our ability to change our artifacts as we need to able reason about a program for changing without fear (using informal reasoning, not category theory). Similarly, the ability to reason about a program allows us to solve bugs and no types nor tests increase the ability to reason about a program. Even though ease provides early speed, ignoring complexity will slow down the development or the long haul (it does not matter for trivial projects). Simplicity will be slower at the beginning because it requires thinking and design. Notes \u00b6 I usually summarize point I find interesting and quote the moment I find legendary. Some of the following sentence are just copy pasting from the slides. Simple, Complexes in contrast to Easy and Hard. \u00b6 Simple means disentangled, without braid, not compound, not twisted. Usually, it goes around one role, topic, concept, dimension, subject. But we should not focus on the one thing, instance or operations. It is about the lack of interleaving and it is objective. How to make complex things simple. Simple you have to disentangle them (or simplify them by the definition of unfolding). Ease is about adjacency or nearness and easy is relative. It is near at hand (hard drive, tool set, ID, understanding and skill set, familiar). I think that, collectively, we are infatuated with these two notions of easy. We are just so self-involved in these two aspects; it\u2019s hurting us tremendously. Right? All we care about is, you know, can I get this instantly and start running it in five seconds? It could be this giant hairball that you got, but all you care is, you know, can you get it. In addition, we\u2019re fixated on, oh, I can\u2019t; I can\u2019t read that. Now I can\u2019t read German. Does that mean German is unreadable? No. I don\u2019t know German. So, you know, this sort of approach is definitely not helpful. In particular, if you want everything to be familiar, you will never learn anything new because it can\u2019t be significantly different from what you already know and not drift away from the familiarity. Finally it is near our capabilities. This point is taboo, because we are in conceptual work and due to a combination of hubris and insecurity, we never talk about. Ease is subjective and relative as well (language and skills acquired by training are example). There\u2019s a third aspect of being easy that I don\u2019t think we think enough about that\u2019s going to become critical to this discussion, which now is being near to our capabilities. And we don\u2019t like to talk about this because it makes us uncomfortable because what kind of capabilities are we talking about? If we\u2019re talking about easy in the case of violin playing or piano playing or mountain climbing or something like that, well, you know, I don\u2019t personally feel bad if I don\u2019t play the violin well because I don\u2019t play the violin at all. But the work that we\u2019re in is conceptual work, so when we start talking about something being outside of our capability, well, you know, it really starts trampling on our egos in a big way. And so, you know, due to a combination of hubris and insecurity, we never really talk about whether or not something is outside of our capabilities. It ends up that it\u2019s not so embarrassing after all because we don\u2019t have tremendously divergent abilities in that area. The relevant point here is that whenever is hard, because it is conceptually complex, our egos prevent us to accept that the task is too complex and that we probably can\u2019t handle it. The reason why we can not have objective discussion about qualities that matters in our software is because we conflate the two notions of easy and simple (because we say something that is simple if it is near our abilities or familiarity). Construct vs Artifact \u00b6 Software are created using constructs (programming language, libraries) which, in and of themselves, have characteristic and we build artifact out of them.. But we\u2019re in a business of artifacts . Right? We don\u2019t ship source code, and the user doesn\u2019t look at our source code and say, \u201cAh, that\u2019s so pleasant.\u201d Right? No? They run our software, and they run it for a long period of time. And, over time, we keep glomming more stuff on our software. All of that stuff, the running of it, the performance of it, the ability to change it all is an attribute of the artifact, not the original construct. However, developers focus on their experience and the characteristic of the constructs (language, less typing) leading to the notion of programmer convenience at the detriment of the programmer: employers love the fact they can replace any programmer as long as our artifacts seems familiar to anyone (does not mean someone else can understand it though). That focus on experience of the use of the construct comes at the expanse the long term result. Does the software do what it is supposed to do? High quality? Can we rely on it? Fix problems when they arise? Change it, given a new requirement? These question are not properties of the constructs but with the attribute of the artifacts. Limits \u00b6 We can only hope to make reliable those thing we can understand. We can only consider a few things at a time. Intertwined things must be considered together. We lose the ability to think of them in isolation. And the burden becomes combinatorial with the number of things under consideration. Complexity undermines understanding. Change and Debugging \u00b6 So how do we change our software? Apparently, I heard in a talk today, that Agile and Extreme Programming have shown that refactoring and tests allow us to make change with zero impact. I never knew that. I still do not know that. That\u2019s not actually a knowable thing. That\u2019s phooey. Change to software require analysis and decisions. What will be impacted of a potential change? Where do changes need to be made? You know, I don\u2019t care if you\u2019re using XP or Agile or anything else. You\u2019re not going to get around the fact that if you can\u2019t reason about your program, you can\u2019t make these decisions The ability to reason about your program is critical to changing it without fear. Not talking about proof, just informal reasoning. One problem is to create new functionalities and the other face of the problem is to fix the parts we did not solve correctly (debugging). And I like to ask this question: What\u2019s true of every bug found in the field? \u2026 It passed the type checker \u2026 [and] all the tests. \u2026 I think we\u2019re in this world I\u2019d like to call guardrail programming. \u2026 We\u2019re like: I can make change because I have tests. Who does that? Who drives their car around banging against the guardrail saying, \u201cWhoa! I\u2019m glad I\u2019ve got these guardrails because I\u2019d never make it to the show on time.\u201d Right? And - and do the guardrails help you get to where you want to go? Like, do guardrails guide you places? No. There are guardrails everywhere. They don\u2019t point your car in any particular direction. We are going to need to be able to reason about our program and use ordinary logic to determine the location of the problem in a program. Development Speed \u00b6 What kind of runner can run as fast as they possibly can from the very start of a race? Right, only somebody who runs really short races, okay? But of course, we are programmers, and we are smarter than runners, apparently, because we know how to fix that problem, right? We just fire the starting pistol every hundred yards and call it a new sprint. I don\u2019t know why they haven\u2019t figured that out, but \u2013 right. It\u2019s my contention, based on experience, that if you ignore complexity, you will slow down. You will invariably slow down over the long haul. Easy Yet Complex \u00b6 And they\u2019re easy to use. In fact, by all measures, conventional measures, you would look at them and say this is easy. Right? But we don\u2019t care about that. Right? Again, the user is not looking at our software, and they don\u2019t actually care very much about how good a time we had when we were writing it. Right? What they care about is what the program does, and if it works well, it will be related to whether or not the output of those constructs were simple. In other words, what complexity did they yield? When there is complexity there, we\u2019re going to call that incidental complexity. Right? It wasn\u2019t part of what the user asked us to do. We chose a tool. It had some inherent complexity in it. It\u2019s incidental to the problem. I didn\u2019t put the definition in here, but incidental is Latin for your fault. How do we usually complect our work? \u00b6 I don\u2019t know and I don\u2019t wanna know. (Rich Hickey, about communication between modules) What, Who, When, Where, Why, How \u00b6 Links \u00b6 Talk , simple made easy, transcripts . Talk , simplicity matters, slides . See also (generated) \u00b6 <../decks/clojure.md> <20200430155438-mastering_clojure_macro.md> <20200430155637-applied_clojure.md> <20200430160432-clojure_for_the_brave_and_the_true.md> <20200430190921-design.md> <20200504213225-rich_hickey.md>","title":"Simple Made Easy and Simplicity Matters"},{"location":"cards/20200502122138-simple_made_easy/#simple-made-easy-and-simplicity-matters","text":"I am merging notes on both talks into one summary as they deal with the same problem.","title":"Simple Made Easy and Simplicity Matters"},{"location":"cards/20200502122138-simple_made_easy/#summary","text":"The talks goes around what the definition of simple and easy, and how as programmers we like complex constructs, because they are familiar and as we are in the conceptual and creative industry, our egos forbid us to accept that some tasks are too complex for us to handle (but especially for familiarity). Simple is an objective measure of how things are entangled, intertwined, not compound, whereas easy has a notion of familiarity and nearness (physical, knowledge and mental capability). Complex is the opposite of simple (when things are braided, tied, or folded together) and hard is the opposite of easy. When accessing the output of work, we should consider the properties of the artifacts (that thing that was made) more than those of the constructs. Is it effective? Understandable? Modifiable? Can be debugged? In contrast, none of our customer will care how easy it was to create the artifact if it does not fulfill the previous objectives. Simplicity matters as our cognitive ability to handle complexity is limited, hence complexity undermines the ability to think in isolation. Complexity affects our ability to change our artifacts as we need to able reason about a program for changing without fear (using informal reasoning, not category theory). Similarly, the ability to reason about a program allows us to solve bugs and no types nor tests increase the ability to reason about a program. Even though ease provides early speed, ignoring complexity will slow down the development or the long haul (it does not matter for trivial projects). Simplicity will be slower at the beginning because it requires thinking and design.","title":"Summary"},{"location":"cards/20200502122138-simple_made_easy/#notes","text":"I usually summarize point I find interesting and quote the moment I find legendary. Some of the following sentence are just copy pasting from the slides.","title":"Notes"},{"location":"cards/20200502122138-simple_made_easy/#simple-complexes-in-contrast-to-easy-and-hard","text":"Simple means disentangled, without braid, not compound, not twisted. Usually, it goes around one role, topic, concept, dimension, subject. But we should not focus on the one thing, instance or operations. It is about the lack of interleaving and it is objective. How to make complex things simple. Simple you have to disentangle them (or simplify them by the definition of unfolding). Ease is about adjacency or nearness and easy is relative. It is near at hand (hard drive, tool set, ID, understanding and skill set, familiar). I think that, collectively, we are infatuated with these two notions of easy. We are just so self-involved in these two aspects; it\u2019s hurting us tremendously. Right? All we care about is, you know, can I get this instantly and start running it in five seconds? It could be this giant hairball that you got, but all you care is, you know, can you get it. In addition, we\u2019re fixated on, oh, I can\u2019t; I can\u2019t read that. Now I can\u2019t read German. Does that mean German is unreadable? No. I don\u2019t know German. So, you know, this sort of approach is definitely not helpful. In particular, if you want everything to be familiar, you will never learn anything new because it can\u2019t be significantly different from what you already know and not drift away from the familiarity. Finally it is near our capabilities. This point is taboo, because we are in conceptual work and due to a combination of hubris and insecurity, we never talk about. Ease is subjective and relative as well (language and skills acquired by training are example). There\u2019s a third aspect of being easy that I don\u2019t think we think enough about that\u2019s going to become critical to this discussion, which now is being near to our capabilities. And we don\u2019t like to talk about this because it makes us uncomfortable because what kind of capabilities are we talking about? If we\u2019re talking about easy in the case of violin playing or piano playing or mountain climbing or something like that, well, you know, I don\u2019t personally feel bad if I don\u2019t play the violin well because I don\u2019t play the violin at all. But the work that we\u2019re in is conceptual work, so when we start talking about something being outside of our capability, well, you know, it really starts trampling on our egos in a big way. And so, you know, due to a combination of hubris and insecurity, we never really talk about whether or not something is outside of our capabilities. It ends up that it\u2019s not so embarrassing after all because we don\u2019t have tremendously divergent abilities in that area. The relevant point here is that whenever is hard, because it is conceptually complex, our egos prevent us to accept that the task is too complex and that we probably can\u2019t handle it. The reason why we can not have objective discussion about qualities that matters in our software is because we conflate the two notions of easy and simple (because we say something that is simple if it is near our abilities or familiarity).","title":"Simple, Complexes in contrast to Easy and Hard."},{"location":"cards/20200502122138-simple_made_easy/#construct-vs-artifact","text":"Software are created using constructs (programming language, libraries) which, in and of themselves, have characteristic and we build artifact out of them.. But we\u2019re in a business of artifacts . Right? We don\u2019t ship source code, and the user doesn\u2019t look at our source code and say, \u201cAh, that\u2019s so pleasant.\u201d Right? No? They run our software, and they run it for a long period of time. And, over time, we keep glomming more stuff on our software. All of that stuff, the running of it, the performance of it, the ability to change it all is an attribute of the artifact, not the original construct. However, developers focus on their experience and the characteristic of the constructs (language, less typing) leading to the notion of programmer convenience at the detriment of the programmer: employers love the fact they can replace any programmer as long as our artifacts seems familiar to anyone (does not mean someone else can understand it though). That focus on experience of the use of the construct comes at the expanse the long term result. Does the software do what it is supposed to do? High quality? Can we rely on it? Fix problems when they arise? Change it, given a new requirement? These question are not properties of the constructs but with the attribute of the artifacts.","title":"Construct vs Artifact"},{"location":"cards/20200502122138-simple_made_easy/#limits","text":"We can only hope to make reliable those thing we can understand. We can only consider a few things at a time. Intertwined things must be considered together. We lose the ability to think of them in isolation. And the burden becomes combinatorial with the number of things under consideration. Complexity undermines understanding.","title":"Limits"},{"location":"cards/20200502122138-simple_made_easy/#change-and-debugging","text":"So how do we change our software? Apparently, I heard in a talk today, that Agile and Extreme Programming have shown that refactoring and tests allow us to make change with zero impact. I never knew that. I still do not know that. That\u2019s not actually a knowable thing. That\u2019s phooey. Change to software require analysis and decisions. What will be impacted of a potential change? Where do changes need to be made? You know, I don\u2019t care if you\u2019re using XP or Agile or anything else. You\u2019re not going to get around the fact that if you can\u2019t reason about your program, you can\u2019t make these decisions The ability to reason about your program is critical to changing it without fear. Not talking about proof, just informal reasoning. One problem is to create new functionalities and the other face of the problem is to fix the parts we did not solve correctly (debugging). And I like to ask this question: What\u2019s true of every bug found in the field? \u2026 It passed the type checker \u2026 [and] all the tests. \u2026 I think we\u2019re in this world I\u2019d like to call guardrail programming. \u2026 We\u2019re like: I can make change because I have tests. Who does that? Who drives their car around banging against the guardrail saying, \u201cWhoa! I\u2019m glad I\u2019ve got these guardrails because I\u2019d never make it to the show on time.\u201d Right? And - and do the guardrails help you get to where you want to go? Like, do guardrails guide you places? No. There are guardrails everywhere. They don\u2019t point your car in any particular direction. We are going to need to be able to reason about our program and use ordinary logic to determine the location of the problem in a program.","title":"Change and Debugging"},{"location":"cards/20200502122138-simple_made_easy/#development-speed","text":"What kind of runner can run as fast as they possibly can from the very start of a race? Right, only somebody who runs really short races, okay? But of course, we are programmers, and we are smarter than runners, apparently, because we know how to fix that problem, right? We just fire the starting pistol every hundred yards and call it a new sprint. I don\u2019t know why they haven\u2019t figured that out, but \u2013 right. It\u2019s my contention, based on experience, that if you ignore complexity, you will slow down. You will invariably slow down over the long haul.","title":"Development Speed"},{"location":"cards/20200502122138-simple_made_easy/#easy-yet-complex","text":"And they\u2019re easy to use. In fact, by all measures, conventional measures, you would look at them and say this is easy. Right? But we don\u2019t care about that. Right? Again, the user is not looking at our software, and they don\u2019t actually care very much about how good a time we had when we were writing it. Right? What they care about is what the program does, and if it works well, it will be related to whether or not the output of those constructs were simple. In other words, what complexity did they yield? When there is complexity there, we\u2019re going to call that incidental complexity. Right? It wasn\u2019t part of what the user asked us to do. We chose a tool. It had some inherent complexity in it. It\u2019s incidental to the problem. I didn\u2019t put the definition in here, but incidental is Latin for your fault.","title":"Easy Yet Complex"},{"location":"cards/20200502122138-simple_made_easy/#how-do-we-usually-complect-our-work","text":"I don\u2019t know and I don\u2019t wanna know. (Rich Hickey, about communication between modules)","title":"How do we usually complect our work?"},{"location":"cards/20200502122138-simple_made_easy/#what-who-when-where-why-how","text":"","title":"What, Who, When, Where, Why, How"},{"location":"cards/20200502122138-simple_made_easy/#links","text":"Talk , simple made easy, transcripts . Talk , simplicity matters, slides .","title":"Links"},{"location":"cards/20200502122138-simple_made_easy/#see-also-generated","text":"<../decks/clojure.md> <20200430155438-mastering_clojure_macro.md> <20200430155637-applied_clojure.md> <20200430160432-clojure_for_the_brave_and_the_true.md> <20200430190921-design.md> <20200504213225-rich_hickey.md>","title":"See also (generated)"},{"location":"cards/20200503165952-materiala/","text":"Materiala \u00b6 My own tools for linking mkdocs and marginalia. See here for a rationale. TODO: \u00b6 Steal marginalia parser. Maybe do a fork, modify it and make a pull request. Github actions for updating the website and leaving the website in the git repo. Deploy to clojar. Get a group-id. Features \u00b6 Including multiple folder [2020-05-03 Sun] Extending the writer [2020-05-03 Sun] Parse non conform clojure code (marginalia has issue to reparse). [2020-05-03 Sun] Link \u00b6 https://github.com/davidpham87/materiala/ See also (generated) \u00b6 <../todo.md> <20200430154352-cli_arguments.md> <20200430154528-multiple_environment.md>","title":"Materiala"},{"location":"cards/20200503165952-materiala/#materiala","text":"My own tools for linking mkdocs and marginalia. See here for a rationale.","title":"Materiala"},{"location":"cards/20200503165952-materiala/#todo","text":"Steal marginalia parser. Maybe do a fork, modify it and make a pull request. Github actions for updating the website and leaving the website in the git repo. Deploy to clojar. Get a group-id.","title":"TODO:"},{"location":"cards/20200503165952-materiala/#features","text":"Including multiple folder [2020-05-03 Sun] Extending the writer [2020-05-03 Sun] Parse non conform clojure code (marginalia has issue to reparse). [2020-05-03 Sun]","title":"Features"},{"location":"cards/20200503165952-materiala/#link","text":"https://github.com/davidpham87/materiala/","title":"Link"},{"location":"cards/20200503165952-materiala/#see-also-generated","text":"<../todo.md> <20200430154352-cli_arguments.md> <20200430154528-multiple_environment.md>","title":"See also (generated)"},{"location":"cards/20200503222619-org_roam_clj/","text":"org-roam-clj \u00b6 Library for extending org-roam. Ideas \u00b6 Check sha1/hash in db to know which files to updates. Rewrite logic for tags to include indices and tags [and not only roam alias?]. Extend to markdown parsing. YAML heading. Own database [implement same operation]. GraalVM. Git as a database. Use Hugo for rendering. Cross device syncing with privacy. Use for leveraging: org-parser Make own parser for displaying org files. Learn about instaparse . Automatic index cards pages with maybe tags with primary tags. Pandoc for org to html conversion. Use of datascript for database. Use #ROAM_TAGS: for defining tags. Notes \u00b6 Pandoc does not convert the links so it requires a filter. See also (generated) \u00b6 <../decks/clojure.md> <20200430155438-mastering_clojure_macro.md> <20200430155637-applied_clojure.md> <20200430160432-clojure_for_the_brave_and_the_true.md>","title":"org-roam-clj"},{"location":"cards/20200503222619-org_roam_clj/#org-roam-clj","text":"Library for extending org-roam.","title":"org-roam-clj"},{"location":"cards/20200503222619-org_roam_clj/#ideas","text":"Check sha1/hash in db to know which files to updates. Rewrite logic for tags to include indices and tags [and not only roam alias?]. Extend to markdown parsing. YAML heading. Own database [implement same operation]. GraalVM. Git as a database. Use Hugo for rendering. Cross device syncing with privacy. Use for leveraging: org-parser Make own parser for displaying org files. Learn about instaparse . Automatic index cards pages with maybe tags with primary tags. Pandoc for org to html conversion. Use of datascript for database. Use #ROAM_TAGS: for defining tags.","title":"Ideas"},{"location":"cards/20200503222619-org_roam_clj/#notes","text":"Pandoc does not convert the links so it requires a filter.","title":"Notes"},{"location":"cards/20200503222619-org_roam_clj/#see-also-generated","text":"<../decks/clojure.md> <20200430155438-mastering_clojure_macro.md> <20200430155637-applied_clojure.md> <20200430160432-clojure_for_the_brave_and_the_true.md>","title":"See also (generated)"},{"location":"cards/20200504204808-why_clojure/","text":"Why Clojure? \u00b6 Simplicity and concision (factor of 5 to 10), transparence. Information driven (work with data). Novelty of Lisp and functional programming. Better at design Macros, consumption, at change of paradigm Immutable Functions Reach (jvm, js, python) Concurrency and parallelism Reference type and why Testing Topics \u00b6 Hot code reloading Effective programming from Rich Hickey Reddit answers: \u00b6 From u/pavelklavik ( here ) I would say it is not just a list of things but how all of them combine together to create a unique experience. For me, the main advantages are the following: Amazing immutable data structures: When all values are immutable, you don\u2019t have to think about a lot of things you have to think when you are programming in other languages. Great set of general functions: working on all of these via the unified sequence abstraction. I have never seen anything like this. The language: it is unusual but when you spend some time with it, it is really simple There are no surprises, no strange syntax, on overloading of meaning. I can\u2019t say this for any other language I have ever used: C++, Java, Python, \u2026 REPL: is live changing. A lot of languages nowadays have something they call REPL, giving you the illusion it is the same. Clojure REPL is a completely different beast. It is not just a quick console to test pieces of your code, for which it is even better, since its output is again a code. In Clojure, you get rid of the life-sucking compile-test loop. Instead you compile your program once and you run it while developing and testing. At any moment, you can investigate the state while manipulating the program, write new functionality and immediately see whether it works, etc. The combination of Clojure and ClojureScript is amazing because now you can target everything with one language. Links \u00b6 clojure specs core.async See also (generated) \u00b6 <../decks/clojure.md> <20200430155438-mastering_clojure_macro.md> <20200430155637-applied_clojure.md> <20200430160432-clojure_for_the_brave_and_the_true.md> <20200430235013-specs.md>","title":"Why Clojure?"},{"location":"cards/20200504204808-why_clojure/#why-clojure","text":"Simplicity and concision (factor of 5 to 10), transparence. Information driven (work with data). Novelty of Lisp and functional programming. Better at design Macros, consumption, at change of paradigm Immutable Functions Reach (jvm, js, python) Concurrency and parallelism Reference type and why Testing","title":"Why Clojure?"},{"location":"cards/20200504204808-why_clojure/#topics","text":"Hot code reloading Effective programming from Rich Hickey","title":"Topics"},{"location":"cards/20200504204808-why_clojure/#reddit-answers","text":"From u/pavelklavik ( here ) I would say it is not just a list of things but how all of them combine together to create a unique experience. For me, the main advantages are the following: Amazing immutable data structures: When all values are immutable, you don\u2019t have to think about a lot of things you have to think when you are programming in other languages. Great set of general functions: working on all of these via the unified sequence abstraction. I have never seen anything like this. The language: it is unusual but when you spend some time with it, it is really simple There are no surprises, no strange syntax, on overloading of meaning. I can\u2019t say this for any other language I have ever used: C++, Java, Python, \u2026 REPL: is live changing. A lot of languages nowadays have something they call REPL, giving you the illusion it is the same. Clojure REPL is a completely different beast. It is not just a quick console to test pieces of your code, for which it is even better, since its output is again a code. In Clojure, you get rid of the life-sucking compile-test loop. Instead you compile your program once and you run it while developing and testing. At any moment, you can investigate the state while manipulating the program, write new functionality and immediately see whether it works, etc. The combination of Clojure and ClojureScript is amazing because now you can target everything with one language.","title":"Reddit answers:"},{"location":"cards/20200504204808-why_clojure/#links","text":"clojure specs core.async","title":"Links"},{"location":"cards/20200504204808-why_clojure/#see-also-generated","text":"<../decks/clojure.md> <20200430155438-mastering_clojure_macro.md> <20200430155637-applied_clojure.md> <20200430160432-clojure_for_the_brave_and_the_true.md> <20200430235013-specs.md>","title":"See also (generated)"},{"location":"cards/20200504212017-edn_and_transit/","text":"edn and transit \u00b6 EDN \u00b6 EDN is the data format from Clojure. Transit \u00b6 Transit compress EDN to json or message pack and allows smaller payloads. You lose human readability, metadata and you need more context to understand the payloads. https://github.com/cognitect/transit-cljs/wiki/Getting-Started Links \u00b6 https://swannodette.github.io/2014/07/26/transit-clojurescript https://blog.cognitect.com/blog/2014/7/22/transit See also (generated) \u00b6 <../decks/clojure.md> <20200430155438-mastering_clojure_macro.md> <20200430155637-applied_clojure.md> <20200430160432-clojure_for_the_brave_and_the_true.md>","title":"edn and transit"},{"location":"cards/20200504212017-edn_and_transit/#edn-and-transit","text":"","title":"edn and transit"},{"location":"cards/20200504212017-edn_and_transit/#edn","text":"EDN is the data format from Clojure.","title":"EDN"},{"location":"cards/20200504212017-edn_and_transit/#transit","text":"Transit compress EDN to json or message pack and allows smaller payloads. You lose human readability, metadata and you need more context to understand the payloads. https://github.com/cognitect/transit-cljs/wiki/Getting-Started","title":"Transit"},{"location":"cards/20200504212017-edn_and_transit/#links","text":"https://swannodette.github.io/2014/07/26/transit-clojurescript https://blog.cognitect.com/blog/2014/7/22/transit","title":"Links"},{"location":"cards/20200504212017-edn_and_transit/#see-also-generated","text":"<../decks/clojure.md> <20200430155438-mastering_clojure_macro.md> <20200430155637-applied_clojure.md> <20200430160432-clojure_for_the_brave_and_the_true.md>","title":"See also (generated)"},{"location":"cards/20200504213118-effective_programs_10_years_of_clojure/","text":"Effective Programs - 10 years of clojure \u00b6 Links \u00b6 https://www.youtube.com/watch?v=2V1FtfBDsLU , Conj 2017 See also (generated) \u00b6 <20200504213225-rich_hickey.md>","title":"Effective Programs - 10 years of clojure"},{"location":"cards/20200504213118-effective_programs_10_years_of_clojure/#effective-programs-10-years-of-clojure","text":"","title":"Effective Programs - 10 years of clojure"},{"location":"cards/20200504213118-effective_programs_10_years_of_clojure/#links","text":"https://www.youtube.com/watch?v=2V1FtfBDsLU , Conj 2017","title":"Links"},{"location":"cards/20200504213118-effective_programs_10_years_of_clojure/#see-also-generated","text":"<20200504213225-rich_hickey.md>","title":"See also (generated)"},{"location":"cards/20200504213225-rich_hickey/","text":"Rich Hickey \u00b6 Author of Clojure Links \u00b6 https://github.com/tallesl/Rich-Hickey-fanclub Talk transcripts See also (generated) \u00b6 <20200430190921-design.md> <20200502122138-simple_made_easy.md> <20200504213118-effective_programs_10_years_of_clojure.md>","title":"Rich Hickey"},{"location":"cards/20200504213225-rich_hickey/#rich-hickey","text":"Author of Clojure","title":"Rich Hickey"},{"location":"cards/20200504213225-rich_hickey/#links","text":"https://github.com/tallesl/Rich-Hickey-fanclub Talk transcripts","title":"Links"},{"location":"cards/20200504213225-rich_hickey/#see-also-generated","text":"<20200430190921-design.md> <20200502122138-simple_made_easy.md> <20200504213118-effective_programs_10_years_of_clojure.md>","title":"See also (generated)"},{"location":"cards/20200505093126-multipass/","text":"Multipass \u00b6 Multipass is VM technology for running ubuntu VMs. Source \u00b6 https://multipass.run/ See also (generated) \u00b6","title":"Multipass"},{"location":"cards/20200505093126-multipass/#multipass","text":"Multipass is VM technology for running ubuntu VMs.","title":"Multipass"},{"location":"cards/20200505093126-multipass/#source","text":"https://multipass.run/","title":"Source"},{"location":"cards/20200505093126-multipass/#see-also-generated","text":"","title":"See also (generated)"},{"location":"cards/20200505093245-ansible/","text":"Ansible \u00b6 playbook: definition of the targeted end state of the VM. roles: collection of playbooks. inventories: a collection of configuration of hosts, aliases and variables variables: values that can be used dynamically in your playbook. Roles \u00b6 You define a role\u2019s tasks in tasks/main.yml and the default values for a role in defaults/main.yml. Source \u00b6 https://www.ansible.com/ https://www.braveclojure.com/quests/deploy/ansible-tutorial/ See also (generated) \u00b6 <20200505111243-learning_tips.md>","title":"Ansible"},{"location":"cards/20200505093245-ansible/#ansible","text":"playbook: definition of the targeted end state of the VM. roles: collection of playbooks. inventories: a collection of configuration of hosts, aliases and variables variables: values that can be used dynamically in your playbook.","title":"Ansible"},{"location":"cards/20200505093245-ansible/#roles","text":"You define a role\u2019s tasks in tasks/main.yml and the default values for a role in defaults/main.yml.","title":"Roles"},{"location":"cards/20200505093245-ansible/#source","text":"https://www.ansible.com/ https://www.braveclojure.com/quests/deploy/ansible-tutorial/","title":"Source"},{"location":"cards/20200505093245-ansible/#see-also-generated","text":"<20200505111243-learning_tips.md>","title":"See also (generated)"},{"location":"cards/20200505111243-learning_tips/","text":"Learning tips \u00b6 Source: https://www.braveclojure.com/quests/deploy/ansible-tutorial/ On Mastering Tools Whenever you\u2019re learning to use a new tool, its useful to focus separately on its purpose, external model and internal model. When you understand a tool\u2019s purpose, your brain gets loaded with helpful contextual details that make it easier for you to assimilate new knowledge. It\u2019s like working on a puzzle: when you\u2019re able to look at a picture of the completed puzzle, it\u2019s a lot easier to fit the pieces together. A tool\u2019s external model is the interface it presents and the way it wants you to think about problem solving. Clojure\u2019s external model is a Lisp that wants you to think about programming as mostly data-centric, immutable transformations. You\u2019ll soon see that Ansible wants you to think of server provisioning in terms of defining the end state, rather than defining the steps you should take to get to that state. A tool\u2019s internal model is how it transforms the inputs to its interface into some lower-level abstraction. Clojure transforms Lisp into JVM bytecode. Ansible transforms task definitions into shell commands. In an ideal world, you wouldn\u2019t have to understand the internal model, but in reality it\u2019s almost always helpful to understand a tool\u2019s internal model because it gives you a unified perspective on what might seem like confusing or contradictory parts. When the double-helix model of DNA was discovered, for example, it helped scientists make sense of higher-level pheonema. My point, of course, is that this book is one of the greatest scientific achievements of all time. Mini rant: Tutorials often mix up a tool\u2019s external model and internal model in a way that\u2019s confusing for learners, and I try not to do that here. If I f\u2019d up, then I apologize! But I hope that you\u2019ll find this distinction between purpose, external model, and internal model will serve you well as you continue along your human journey of learning. Links \u00b6 ansible programming See also (generated) \u00b6 <20200505093245-ansible.md>","title":"Learning tips"},{"location":"cards/20200505111243-learning_tips/#learning-tips","text":"Source: https://www.braveclojure.com/quests/deploy/ansible-tutorial/ On Mastering Tools Whenever you\u2019re learning to use a new tool, its useful to focus separately on its purpose, external model and internal model. When you understand a tool\u2019s purpose, your brain gets loaded with helpful contextual details that make it easier for you to assimilate new knowledge. It\u2019s like working on a puzzle: when you\u2019re able to look at a picture of the completed puzzle, it\u2019s a lot easier to fit the pieces together. A tool\u2019s external model is the interface it presents and the way it wants you to think about problem solving. Clojure\u2019s external model is a Lisp that wants you to think about programming as mostly data-centric, immutable transformations. You\u2019ll soon see that Ansible wants you to think of server provisioning in terms of defining the end state, rather than defining the steps you should take to get to that state. A tool\u2019s internal model is how it transforms the inputs to its interface into some lower-level abstraction. Clojure transforms Lisp into JVM bytecode. Ansible transforms task definitions into shell commands. In an ideal world, you wouldn\u2019t have to understand the internal model, but in reality it\u2019s almost always helpful to understand a tool\u2019s internal model because it gives you a unified perspective on what might seem like confusing or contradictory parts. When the double-helix model of DNA was discovered, for example, it helped scientists make sense of higher-level pheonema. My point, of course, is that this book is one of the greatest scientific achievements of all time. Mini rant: Tutorials often mix up a tool\u2019s external model and internal model in a way that\u2019s confusing for learners, and I try not to do that here. If I f\u2019d up, then I apologize! But I hope that you\u2019ll find this distinction between purpose, external model, and internal model will serve you well as you continue along your human journey of learning.","title":"Learning tips"},{"location":"cards/20200505111243-learning_tips/#links","text":"ansible programming","title":"Links"},{"location":"cards/20200505111243-learning_tips/#see-also-generated","text":"<20200505093245-ansible.md>","title":"See also (generated)"},{"location":"cards/20200505112138-clojure_reducers/","text":"Clojure Reducers \u00b6 Concepts \u00b6 Concurrency: the concept of handling multiple tasks at the same time. Parallelism: the concept of performing multiple computations at the same time. The difference lies in the fact that in concurrency there is a sense of competition of resources (who/what gets to use the memory or cpu) for completing the tasks, in contrast to parallelism which requires coordination and collaboration to achieve its goal. Sources \u00b6 How to Think about Parallel Programming: Not! , Guy Steele. Reducers \u00b6 The things that can be improved is usually latency and resources usages. Scan operation can be parallelized. The goal is to amortizing the overhead for launching parallel computation. Work-span: Compare the unit time cost of your program against what is the minimal sequential path of unit of work on a machine with infinite core, when the cost is one, the term is embarrassingly parallel problems. Observer that the amount of work increased with parallel work than in a serial version. Tiling: gathering many of the small problem, and compute the function on each group/tile. Parallel stack: ability to steal work from other tiles to increase speed. Fusion: is to join the operations to remove communication (similar to transducers to sequences operations). Fork/join: split the work, until a base case, make the computation the segment and combine the blocks back. Sources \u00b6 https://www.braveclojure.com/quests/reducers/intro/ Parallel Programming, Fork Join, and Reducers - Daniel Higginbotham Reducers A Library and Model for Collection Proc - Rich Hickey [2012] \u00b6 Summary \u00b6 The model of map/reduce is revisited to reduce/combine. The reduce function is replaced by the r/fold function. The main idea is to express map, filter and other operations on sequences as reducing functions. See transducers for more details on this. The advantage of this the reducers are not tied to the input nor order anymore. The r/fold function takes additionally to reduce a minimal size, a combining function and a reducing function. The r/fold function will fork the process and segments the collection until a certain size is reached. Note that fold does not have a single initial value. But the seeds (the initial value for each segment) is provided by the call to the combining function without any argument which should return a identity value (which is 0 for + , 1 for * , empty collection for the collection). The benefit is that you can provide mutable object for performance at the segment level, otherwise you will have trouble. The reducing function is then applied and then combined by the combing function (which could be the same as the reducer). At the bottom is of the processing, reduce will be called and so we don\u2019t need to have empty collection. A combining function is a monoid (a binary function with an identity value) . Although really similar to transducer, the advantage of reducers over transducers is still the ability to use r/fold . In the future, transducers might be replace the reducers in the parallel mode as well. The talk gives the example of a apple pie maker with an assistant with the operation remove stick ( r/map ) and keep only the healthy ones ( r/filter ). Sources \u00b6 Talks from Rich Hickey Transcripts Links \u00b6 Clojure for the brave and the true Applied Clojure See also (generated) \u00b6 <../decks/clojure.md> <20200430155438-mastering_clojure_macro.md> <20200430155637-applied_clojure.md> <20200430155819-core_async.md> <20200430160432-clojure_for_the_brave_and_the_true.md>","title":"Clojure Reducers"},{"location":"cards/20200505112138-clojure_reducers/#clojure-reducers","text":"","title":"Clojure Reducers"},{"location":"cards/20200505112138-clojure_reducers/#concepts","text":"Concurrency: the concept of handling multiple tasks at the same time. Parallelism: the concept of performing multiple computations at the same time. The difference lies in the fact that in concurrency there is a sense of competition of resources (who/what gets to use the memory or cpu) for completing the tasks, in contrast to parallelism which requires coordination and collaboration to achieve its goal.","title":"Concepts"},{"location":"cards/20200505112138-clojure_reducers/#sources","text":"How to Think about Parallel Programming: Not! , Guy Steele.","title":"Sources"},{"location":"cards/20200505112138-clojure_reducers/#reducers","text":"The things that can be improved is usually latency and resources usages. Scan operation can be parallelized. The goal is to amortizing the overhead for launching parallel computation. Work-span: Compare the unit time cost of your program against what is the minimal sequential path of unit of work on a machine with infinite core, when the cost is one, the term is embarrassingly parallel problems. Observer that the amount of work increased with parallel work than in a serial version. Tiling: gathering many of the small problem, and compute the function on each group/tile. Parallel stack: ability to steal work from other tiles to increase speed. Fusion: is to join the operations to remove communication (similar to transducers to sequences operations). Fork/join: split the work, until a base case, make the computation the segment and combine the blocks back.","title":"Reducers"},{"location":"cards/20200505112138-clojure_reducers/#sources_1","text":"https://www.braveclojure.com/quests/reducers/intro/ Parallel Programming, Fork Join, and Reducers - Daniel Higginbotham","title":"Sources"},{"location":"cards/20200505112138-clojure_reducers/#reducers-a-library-and-model-for-collection-proc-rich-hickey-2012","text":"","title":"Reducers A Library and Model for Collection Proc - Rich Hickey [2012]"},{"location":"cards/20200505112138-clojure_reducers/#summary","text":"The model of map/reduce is revisited to reduce/combine. The reduce function is replaced by the r/fold function. The main idea is to express map, filter and other operations on sequences as reducing functions. See transducers for more details on this. The advantage of this the reducers are not tied to the input nor order anymore. The r/fold function takes additionally to reduce a minimal size, a combining function and a reducing function. The r/fold function will fork the process and segments the collection until a certain size is reached. Note that fold does not have a single initial value. But the seeds (the initial value for each segment) is provided by the call to the combining function without any argument which should return a identity value (which is 0 for + , 1 for * , empty collection for the collection). The benefit is that you can provide mutable object for performance at the segment level, otherwise you will have trouble. The reducing function is then applied and then combined by the combing function (which could be the same as the reducer). At the bottom is of the processing, reduce will be called and so we don\u2019t need to have empty collection. A combining function is a monoid (a binary function with an identity value) . Although really similar to transducer, the advantage of reducers over transducers is still the ability to use r/fold . In the future, transducers might be replace the reducers in the parallel mode as well. The talk gives the example of a apple pie maker with an assistant with the operation remove stick ( r/map ) and keep only the healthy ones ( r/filter ).","title":"Summary"},{"location":"cards/20200505112138-clojure_reducers/#sources_2","text":"Talks from Rich Hickey Transcripts","title":"Sources"},{"location":"cards/20200505112138-clojure_reducers/#links","text":"Clojure for the brave and the true Applied Clojure","title":"Links"},{"location":"cards/20200505112138-clojure_reducers/#see-also-generated","text":"<../decks/clojure.md> <20200430155438-mastering_clojure_macro.md> <20200430155637-applied_clojure.md> <20200430155819-core_async.md> <20200430160432-clojure_for_the_brave_and_the_true.md>","title":"See also (generated)"},{"location":"cards/20200505112918-nginx/","text":"nginx \u00b6 This is a quick reminder about a few tricks in nginx. For me, nginx is the tools that solves the question: How can I serve multiple web apps from a single server with a common root? How can I serve multiple domain from the same server? Usually, the nginx root folder is stored under /etc/nginx . Note that adaptation (usually path) might be required between linux distributions. First of all, when you distribute multiple web app, it is much easier if you can have multiple domain names: web apps will have their routes and avoid paths conflict. In this case you will create server block for each domain. Tips: pay attention to the slashes ( / ) it the path, as nginx mainly concatenate strings, so you might accidentally have double slashes in your path which usually leads to unintended consequence. Server blocks \u00b6 Server blocks usually lives in the conf.d or sites-availables server { listen 80; listen [::]:80; root /var/www/your_domain/html; index index.html index.htm index.nginx-debian.html; server_name your_domain www.your_domain; location / { try_files $uri $uri/ =404; } } where your_domain is replaced by the domain you own. The root directive provides the root of your web app, the folder needs to be reachable by the process which started nginx. If the server block is defined in sites-availables , you need to create a symlink into the sites-enabled folder. Root directive \u00b6 The root directive provides the root path of your request. In the previous server block, the response from nginx to the request on the path www.your_domain/css/file.css will be the filer located under /var/www/your_domain/html/css/file.css , because /var/www/your_domain/html was defined as the root and /css/file.css is the path requested. If the files does not exists, the 404 (not found) answer is returned. Nginx has concatenated the root with the path. You can change the root for each location directive, which can handy for distribution under several folders (see later). Static file distribution through alias \u00b6 Usually, you desire to use some path of your domain to target different folder because they serve the files for your webapp. Most webapp are defined as if they were placed on the root folder, so if the web app is distributed under /my_webapp the associated assets files (javascript, css, images) will usually be unfound. To solve this problem, we use the alias directive. In a server block (the default or any other), the following directive will alias the www.your_domain/my_webapp to /var/www/my_webapp/html . location /my_webapp { alias /var/www/my_webapp/html; } The consequences are that nginx will answer to request www.your_domain/my_webapp/css/file.css with the file /var/www/my_webapp/html/css/files.css , concatenating the alias and the path. If root instead of alias was used, nginx would have returned /var/www/my_webapp/html/my_webapp/css/file.css , because nginx always append the full path to the route, whereas alias replace the the match path with the value provided to alias. In my personal experience, you will use and abuse alias more often than root. Proxy pass \u00b6 When creating web apps, you will often create a backend server. This server will usually be connected to some port under root (e.g. 8000, 8050, 8081). Under development, you will often use localhost:8050 as domain. In production, you will launch the same program which will still listen to the same port. However, you want your user to call a path on your_domain . The proxy_pass directive is the solution to this problem. location /backend_path { proxy_pass locahost:8050; } Hence the for each request called to my_domain//backend_path/data , the backend will match it to /data . Obviously you can use nginx to also perform some indirection location /backend_path/x { proxy_pass locahost:8050/y; } In this case, under the request my_domain//backend_path/x/data , the backend will return the handler registered under the route /y/data . Regex path \u00b6 Regex can be used to match multiple paths in nginx. You start a regex path by adding a tilde ~ sign after location and then using standard regex notation to reuse the match parts. location ~ /images/(.+)$ { try_files /other_images_folders/$1 =404; } Multiple source folder \u00b6 It might happens that your apps call the same path, but the content is located in different folder. In this case, we can combine root and regex to sovle the issue. location ~ /images/(.+)$ { root /var/www; try_files /my_webapp/images/$1 /your_domain/images/$1 =404; } Here nginx will try to server /images/file.jpeg from /my_webapp/images/file.jpeg before /your_domain/images/file.jpeg . HTTPS \u00b6 In order to promote the connection to https, you will need to change the server blocks and define the path of your certificates. server { listen 443 ssl; server_name www.example.com; ssl_certificate path/to/www.example.com.crt; ssl_certificate_key path/to/www.example.com.key; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; } Usually, you will want letsencrypt (if you own the domain name) to save this for you. Websocket \u00b6 In order to allow websocket, you must upgrade the connection. For this you can adapt the following snippet under the desired location: location /shadow-cljs/ { # upgrade to websocket proxy_pass http://localhost:9630/; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"Upgrade\"; proxy_set_header Host $host; } Links \u00b6 https://nginx.org/en/ Digital ocean guide An Introduction to DNS Terminology, Components, and Concepts See also (generated) \u00b6 <20200430154647-shadow_cljs.md>","title":"nginx"},{"location":"cards/20200505112918-nginx/#nginx","text":"This is a quick reminder about a few tricks in nginx. For me, nginx is the tools that solves the question: How can I serve multiple web apps from a single server with a common root? How can I serve multiple domain from the same server? Usually, the nginx root folder is stored under /etc/nginx . Note that adaptation (usually path) might be required between linux distributions. First of all, when you distribute multiple web app, it is much easier if you can have multiple domain names: web apps will have their routes and avoid paths conflict. In this case you will create server block for each domain. Tips: pay attention to the slashes ( / ) it the path, as nginx mainly concatenate strings, so you might accidentally have double slashes in your path which usually leads to unintended consequence.","title":"nginx"},{"location":"cards/20200505112918-nginx/#server-blocks","text":"Server blocks usually lives in the conf.d or sites-availables server { listen 80; listen [::]:80; root /var/www/your_domain/html; index index.html index.htm index.nginx-debian.html; server_name your_domain www.your_domain; location / { try_files $uri $uri/ =404; } } where your_domain is replaced by the domain you own. The root directive provides the root of your web app, the folder needs to be reachable by the process which started nginx. If the server block is defined in sites-availables , you need to create a symlink into the sites-enabled folder.","title":"Server blocks"},{"location":"cards/20200505112918-nginx/#root-directive","text":"The root directive provides the root path of your request. In the previous server block, the response from nginx to the request on the path www.your_domain/css/file.css will be the filer located under /var/www/your_domain/html/css/file.css , because /var/www/your_domain/html was defined as the root and /css/file.css is the path requested. If the files does not exists, the 404 (not found) answer is returned. Nginx has concatenated the root with the path. You can change the root for each location directive, which can handy for distribution under several folders (see later).","title":"Root directive"},{"location":"cards/20200505112918-nginx/#static-file-distribution-through-alias","text":"Usually, you desire to use some path of your domain to target different folder because they serve the files for your webapp. Most webapp are defined as if they were placed on the root folder, so if the web app is distributed under /my_webapp the associated assets files (javascript, css, images) will usually be unfound. To solve this problem, we use the alias directive. In a server block (the default or any other), the following directive will alias the www.your_domain/my_webapp to /var/www/my_webapp/html . location /my_webapp { alias /var/www/my_webapp/html; } The consequences are that nginx will answer to request www.your_domain/my_webapp/css/file.css with the file /var/www/my_webapp/html/css/files.css , concatenating the alias and the path. If root instead of alias was used, nginx would have returned /var/www/my_webapp/html/my_webapp/css/file.css , because nginx always append the full path to the route, whereas alias replace the the match path with the value provided to alias. In my personal experience, you will use and abuse alias more often than root.","title":"Static file distribution through alias"},{"location":"cards/20200505112918-nginx/#proxy-pass","text":"When creating web apps, you will often create a backend server. This server will usually be connected to some port under root (e.g. 8000, 8050, 8081). Under development, you will often use localhost:8050 as domain. In production, you will launch the same program which will still listen to the same port. However, you want your user to call a path on your_domain . The proxy_pass directive is the solution to this problem. location /backend_path { proxy_pass locahost:8050; } Hence the for each request called to my_domain//backend_path/data , the backend will match it to /data . Obviously you can use nginx to also perform some indirection location /backend_path/x { proxy_pass locahost:8050/y; } In this case, under the request my_domain//backend_path/x/data , the backend will return the handler registered under the route /y/data .","title":"Proxy pass"},{"location":"cards/20200505112918-nginx/#regex-path","text":"Regex can be used to match multiple paths in nginx. You start a regex path by adding a tilde ~ sign after location and then using standard regex notation to reuse the match parts. location ~ /images/(.+)$ { try_files /other_images_folders/$1 =404; }","title":"Regex path"},{"location":"cards/20200505112918-nginx/#multiple-source-folder","text":"It might happens that your apps call the same path, but the content is located in different folder. In this case, we can combine root and regex to sovle the issue. location ~ /images/(.+)$ { root /var/www; try_files /my_webapp/images/$1 /your_domain/images/$1 =404; } Here nginx will try to server /images/file.jpeg from /my_webapp/images/file.jpeg before /your_domain/images/file.jpeg .","title":"Multiple source folder"},{"location":"cards/20200505112918-nginx/#https","text":"In order to promote the connection to https, you will need to change the server blocks and define the path of your certificates. server { listen 443 ssl; server_name www.example.com; ssl_certificate path/to/www.example.com.crt; ssl_certificate_key path/to/www.example.com.key; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; } Usually, you will want letsencrypt (if you own the domain name) to save this for you.","title":"HTTPS"},{"location":"cards/20200505112918-nginx/#websocket","text":"In order to allow websocket, you must upgrade the connection. For this you can adapt the following snippet under the desired location: location /shadow-cljs/ { # upgrade to websocket proxy_pass http://localhost:9630/; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"Upgrade\"; proxy_set_header Host $host; }","title":"Websocket"},{"location":"cards/20200505112918-nginx/#links","text":"https://nginx.org/en/ Digital ocean guide An Introduction to DNS Terminology, Components, and Concepts","title":"Links"},{"location":"cards/20200505112918-nginx/#see-also-generated","text":"<20200430154647-shadow_cljs.md>","title":"See also (generated)"},{"location":"cards/20200505113402-high_performance_clojurescript/","text":"High Performance Clojurescript \u00b6 Chambered \u00b6 Use of for loop locals and javascript arrays for speed. Source \u00b6 https://github.com/swannodette/chambered ClojureScript, WebWorkers & WebGL \u00b6 Webworkers and javascript arrays for transfering data. Source \u00b6 https://medium.com/@thi.ng/clojurescript-webworkers-webgl-6c2f3c717d9e https://github.com/thi-ng/ws-ldn-8/tree/master/day3/ex07 TFJS \u00b6 The wasm part of tensorflow js provides incredible performance boost. Source \u00b6 https://blog.tensorflow.org/2020/03/introducing-webassembly-backend-for-tensorflow-js.html https://github.com/tensorflow/tfjs Links \u00b6 http://swannodette.github.io/2013/06/10/porting-notchs-minecraft-demo-to-clojurescript https://github.com/swannodette/chambered See also (generated) \u00b6 <../decks/clojure.md> <20200430154647-shadow_cljs.md>","title":"High Performance Clojurescript"},{"location":"cards/20200505113402-high_performance_clojurescript/#high-performance-clojurescript","text":"","title":"High Performance Clojurescript"},{"location":"cards/20200505113402-high_performance_clojurescript/#chambered","text":"Use of for loop locals and javascript arrays for speed.","title":"Chambered"},{"location":"cards/20200505113402-high_performance_clojurescript/#source","text":"https://github.com/swannodette/chambered","title":"Source"},{"location":"cards/20200505113402-high_performance_clojurescript/#clojurescript-webworkers-webgl","text":"Webworkers and javascript arrays for transfering data.","title":"ClojureScript, WebWorkers &amp; WebGL"},{"location":"cards/20200505113402-high_performance_clojurescript/#source_1","text":"https://medium.com/@thi.ng/clojurescript-webworkers-webgl-6c2f3c717d9e https://github.com/thi-ng/ws-ldn-8/tree/master/day3/ex07","title":"Source"},{"location":"cards/20200505113402-high_performance_clojurescript/#tfjs","text":"The wasm part of tensorflow js provides incredible performance boost.","title":"TFJS"},{"location":"cards/20200505113402-high_performance_clojurescript/#source_2","text":"https://blog.tensorflow.org/2020/03/introducing-webassembly-backend-for-tensorflow-js.html https://github.com/tensorflow/tfjs","title":"Source"},{"location":"cards/20200505113402-high_performance_clojurescript/#links","text":"http://swannodette.github.io/2013/06/10/porting-notchs-minecraft-demo-to-clojurescript https://github.com/swannodette/chambered","title":"Links"},{"location":"cards/20200505113402-high_performance_clojurescript/#see-also-generated","text":"<../decks/clojure.md> <20200430154647-shadow_cljs.md>","title":"See also (generated)"},{"location":"cards/20200505124708-potemkin/","text":"Potemkin \u00b6 Some ideas which are almost good \u00b6 Potemkin is a collection of facades and workarounds for things that are more difficult than they should be. All functions are within the potemkin namespace. The important function is impots-vars , it allows to define variable in one namespace and expose them in another. Source \u00b6 https://github.com/ztellman/potemkin Link \u00b6 clj-toolkit See also (generated) \u00b6 <../decks/clojure.md> <20200505124946-clj_toolkit.md>","title":"Potemkin"},{"location":"cards/20200505124708-potemkin/#potemkin","text":"","title":"Potemkin"},{"location":"cards/20200505124708-potemkin/#some-ideas-which-are-almost-good","text":"Potemkin is a collection of facades and workarounds for things that are more difficult than they should be. All functions are within the potemkin namespace. The important function is impots-vars , it allows to define variable in one namespace and expose them in another.","title":"Some ideas which are almost good"},{"location":"cards/20200505124708-potemkin/#source","text":"https://github.com/ztellman/potemkin","title":"Source"},{"location":"cards/20200505124708-potemkin/#link","text":"clj-toolkit","title":"Link"},{"location":"cards/20200505124708-potemkin/#see-also-generated","text":"<../decks/clojure.md> <20200505124946-clj_toolkit.md>","title":"See also (generated)"},{"location":"cards/20200505124946-clj_toolkit/","text":"clj-toolkit \u00b6 Libraries supporting writing clojure in a better way. It can be code editor support or libraries to avoid writing too much code. See also (generated) \u00b6 <../decks/clojure.md> <20200430154352-cli_arguments.md> <20200430154647-shadow_cljs.md> <20200505124708-potemkin.md> <20200505125105-medley.md> <20200506224558-enlive.md> <20200514104809-clojure_debug.md> <20200514114627-tools_deps.md> <20200517212936-postmortem.md>","title":"clj-toolkit"},{"location":"cards/20200505124946-clj_toolkit/#clj-toolkit","text":"Libraries supporting writing clojure in a better way. It can be code editor support or libraries to avoid writing too much code.","title":"clj-toolkit"},{"location":"cards/20200505124946-clj_toolkit/#see-also-generated","text":"<../decks/clojure.md> <20200430154352-cli_arguments.md> <20200430154647-shadow_cljs.md> <20200505124708-potemkin.md> <20200505125105-medley.md> <20200506224558-enlive.md> <20200514104809-clojure_debug.md> <20200514114627-tools_deps.md> <20200517212936-postmortem.md>","title":"See also (generated)"},{"location":"cards/20200505125105-medley/","text":"medley \u00b6 Clojure and ClojureScript common functions not implemented in core Source \u00b6 https://github.com/weavejester/medley See also (generated) \u00b6 <20200505124946-clj_toolkit.md>","title":"medley"},{"location":"cards/20200505125105-medley/#medley","text":"Clojure and ClojureScript common functions not implemented in core","title":"medley"},{"location":"cards/20200505125105-medley/#source","text":"https://github.com/weavejester/medley","title":"Source"},{"location":"cards/20200505125105-medley/#see-also-generated","text":"<20200505124946-clj_toolkit.md>","title":"See also (generated)"},{"location":"cards/20200505164639-cider/","text":"cider \u00b6 Emacs extension for using Clojure. Essential shortcut \u00b6 C-x C-e eval last S-EXP. C-c C-v w eval last S-EXP and replace C-c M-i inspect last S-EXP. C-c C-v [vrb] eval [form around, region, buffer]. C-c C-k load buffer, C-c C-l load file, C-c M-l load all files C-c C-d [djcwaf] docs for docs or javadoc , clojuredoc local , clojuredocs web , a propos , a propos documentation C-c C-t n run test of namespace. C-c C-t r run failed test. M-. find-var C-c M-. find resource M-, return to prejump location. Advanced shortcut \u00b6 C-c M-s for navigation C-u C-M-x inside a function to turn on debugging mode, see here for shortcuts. Conditional breakpoints ( dotimes [ i 10 ] # dbg ^ { :break/when ( = i 7 )} ( prn i )) C-c M-t v , tracing and untracing function. C-c M-t n , tracing and untracing all the namespace M-x cider-enlighten-mode M-x cider-browser-ns , browse namespace M-x cider-classpath , browse classpath. M-x cider-browser-spec , browse specs. M-x cider-browser-spec-all , browse specs. Source \u00b6 https://cider.mx/ See also (generated) \u00b6","title":"cider"},{"location":"cards/20200505164639-cider/#cider","text":"Emacs extension for using Clojure.","title":"cider"},{"location":"cards/20200505164639-cider/#essential-shortcut","text":"C-x C-e eval last S-EXP. C-c C-v w eval last S-EXP and replace C-c M-i inspect last S-EXP. C-c C-v [vrb] eval [form around, region, buffer]. C-c C-k load buffer, C-c C-l load file, C-c M-l load all files C-c C-d [djcwaf] docs for docs or javadoc , clojuredoc local , clojuredocs web , a propos , a propos documentation C-c C-t n run test of namespace. C-c C-t r run failed test. M-. find-var C-c M-. find resource M-, return to prejump location.","title":"Essential shortcut"},{"location":"cards/20200505164639-cider/#advanced-shortcut","text":"C-c M-s for navigation C-u C-M-x inside a function to turn on debugging mode, see here for shortcuts. Conditional breakpoints ( dotimes [ i 10 ] # dbg ^ { :break/when ( = i 7 )} ( prn i )) C-c M-t v , tracing and untracing function. C-c M-t n , tracing and untracing all the namespace M-x cider-enlighten-mode M-x cider-browser-ns , browse namespace M-x cider-classpath , browse classpath. M-x cider-browser-spec , browse specs. M-x cider-browser-spec-all , browse specs.","title":"Advanced shortcut"},{"location":"cards/20200505164639-cider/#source","text":"https://cider.mx/","title":"Source"},{"location":"cards/20200505164639-cider/#see-also-generated","text":"","title":"See also (generated)"},{"location":"cards/20200506224558-enlive/","text":"Enlive \u00b6 The best template library for Clojure. Use real web page as template, use deftempalte and defsnippet to create reusable parts. Use CSS selectors for selecting the nodes on the HTML page. Trick \u00b6 Reload your namespace file for updating the html. Hiccup \u00b6 Quick and dirty transformation to hiccup ( defn html->hiccup [ html ] ( if-not ( string? html ) ( ->> ( map html->hiccup ( :content html )) ( concat [( :tag html ) ( :attrs html )]) ( keep identity ) vec ) html )) Source \u00b6 https://github.com/cgrand/enlive https://github.com/swannodette/enlive-tutorial/ See also (generated) \u00b6 <20200505124946-clj_toolkit.md>","title":"Enlive"},{"location":"cards/20200506224558-enlive/#enlive","text":"The best template library for Clojure. Use real web page as template, use deftempalte and defsnippet to create reusable parts. Use CSS selectors for selecting the nodes on the HTML page.","title":"Enlive"},{"location":"cards/20200506224558-enlive/#trick","text":"Reload your namespace file for updating the html.","title":"Trick"},{"location":"cards/20200506224558-enlive/#hiccup","text":"Quick and dirty transformation to hiccup ( defn html->hiccup [ html ] ( if-not ( string? html ) ( ->> ( map html->hiccup ( :content html )) ( concat [( :tag html ) ( :attrs html )]) ( keep identity ) vec ) html ))","title":"Hiccup"},{"location":"cards/20200506224558-enlive/#source","text":"https://github.com/cgrand/enlive https://github.com/swannodette/enlive-tutorial/","title":"Source"},{"location":"cards/20200506224558-enlive/#see-also-generated","text":"<20200505124946-clj_toolkit.md>","title":"See also (generated)"},{"location":"cards/20200514104809-clojure_debug/","text":"Clojure Debug \u00b6 Tips \u00b6 Protocols \u00b6 When calling a function and the error messages state that the function is not implemented, while it is (for example with the core.async take! function, check that the arguments respects the protocol (in this case a chan ). See also (generated) \u00b6 <20200505124946-clj_toolkit.md>","title":"Clojure Debug"},{"location":"cards/20200514104809-clojure_debug/#clojure-debug","text":"","title":"Clojure Debug"},{"location":"cards/20200514104809-clojure_debug/#tips","text":"","title":"Tips"},{"location":"cards/20200514104809-clojure_debug/#protocols","text":"When calling a function and the error messages state that the function is not implemented, while it is (for example with the core.async take! function, check that the arguments respects the protocol (in this case a chan ).","title":"Protocols"},{"location":"cards/20200514104809-clojure_debug/#see-also-generated","text":"<20200505124946-clj_toolkit.md>","title":"See also (generated)"},{"location":"cards/20200514114627-tools_deps/","text":"tools.deps \u00b6 Git deps \u00b6 You can put :sha as location or tag { :deps { cljs.nodejs.shell { :git/url \"https://github.com/bolasblack/cljs.nodejs.shell\" :tag \"0.2.1\" }}} Links \u00b6 https://github.com/clojure/tools.deps.alpha https://clojure.org/guides/deps_and_cli https://clojure.org/reference/deps_and_cli See also (generated) \u00b6 <20200505124946-clj_toolkit.md>","title":"tools.deps"},{"location":"cards/20200514114627-tools_deps/#toolsdeps","text":"","title":"tools.deps"},{"location":"cards/20200514114627-tools_deps/#git-deps","text":"You can put :sha as location or tag { :deps { cljs.nodejs.shell { :git/url \"https://github.com/bolasblack/cljs.nodejs.shell\" :tag \"0.2.1\" }}}","title":"Git deps"},{"location":"cards/20200514114627-tools_deps/#links","text":"https://github.com/clojure/tools.deps.alpha https://clojure.org/guides/deps_and_cli https://clojure.org/reference/deps_and_cli","title":"Links"},{"location":"cards/20200514114627-tools_deps/#see-also-generated","text":"<20200505124946-clj_toolkit.md>","title":"See also (generated)"},{"location":"cards/20200516171955-generative_testing/","text":"Generative Testing \u00b6 Properties \u00b6 Taking from Applied Clojure We are looking for invariants \u2013 properties that are always true. [\u2026] mathematical laws, relationships between inputs and outputs, round-trip or complementing functions, and comparing action effects. Properties like identity, associativity, commutativity and idempotency are an excellent place to start. Other general properties: membership is not modified (frequencies of element still are the same), maybe distinct for sets and hash-map. Trusted implementation. Compare the results and calculation on a trusted different implementation (different language, slower/faster version). For stateful components (like database), apply same logical operation on a logical model correct implementation like hash-map or vectors (e.g. create is assoc , delete is dissoc ). Avoid to implement again the same algorithms. Commutativity of operations Hard to prove, quick to verify (e.g. path in maze to the exit). Backward properties: generate the output and think which input would have yielded this output (like in finding a key in a hash map: inserting the key first to insure the key is in the collection). Expect failures and create failure. Ask the hard questions. Create the visibility you need (for asserting that a function did what it is supposed to do). What defines success of a service? This leads to property. Hammock time leads (care and randomness). Preconditions are predicates returning if some operations are valid, given the state of object or input of the function. If the preconditions is not met, then it is a noop (no operation). Postcondition are what ought to be true after the function call (usually we check if the result coincide with a predicted model). How to specify it \u00b6 Talk about how to specify properties for pure functions. Invariant: things that ought to be always true. Optimize for correctness in the assertion, not for performance (test case are usually small). Make sure that generator are also valid. Postcondition: Asking what is the postcondition? Finding what ought to be true after the function call. If the properties requires to have the function under test, create a generator that insures that the state is consistent (for example, in a hash-map, for testing contains? , you can insert and remove key to test the properties of contains? ). Metamorphic properties: instead of predicting and test the result from an input, predict and test the relationship of result from two almost input. It is the idea of paths for getting to a final state. The relationship could be equality, size comparison. You can also check equivalence on result (as function of the result). You have to change in terms of the space of continuous functions: if input change, how will the change on the image be \\Delta f = f(x+\\delta) - f(x) \\Delta f = f(x+\\delta) - f(x) ? Some write metamorphic relations. Inductive properties: argument by induction that only the correct function can pass the test (using recursion). Double check the conformity by applying operations that should also keep the result valid. Model-based properties: similar to trusted implementation by working on a abstraction function with an abstraction operation. The assumption is you can convert your result into the abstraction and applying the same operations on the abstraction (you have an homomorphism ). Model-based properties is one of the most powerful representation. However, the model based properties can look too alike than the implementation or the function under test. If you feel you write too much code on the model based version, switch to metamorphic properties do not require on a model (and they are easier to write with good effectiveness). Invariant properties should be first because they are the most fundamental. Source \u00b6 How to specify it? , video (jump until minute 10 for start of content). Geneartive Testing, Group Theory and Category Theory \u00b6 The model based properties (as in how to specify it) are the most powerful when you can find an isomorphism between your function or system under test for a certain algebras (or structure, or restricted invariant). This is powerful because you can then apply your operation on your model space which is probably much simpler and in all time transform the result back into function space. As finding algebraic structure (or group operation) might be too restrictive, we can relax the hypothesis to category theory (as long as we still have a bijective/ismorphic map). Isomorphism spaces are useful as they equivalent and their representation might used from one space to the other for practical purposes. For practical concerns, once you find an isomorphism to the function or entity under test, you can usually find many equivalent operations from your system onto your model and can randomly apply these property in any order to insure that your implementation is correct. Property Based Testing with Proper \u00b6 Side effects can be grouped together at one end of the system, and we can keep the rest of the code as pure as possible. Targeted Properties and Simulated Annealing are cool stuff to learn about, even if you won\u2019t use Property-Based Testing that much. Don\u2019t skim over that chapter in the book. Any intelligent fool can make things bigger, more complex, and more violent. It takes a touch of genius \u2013 and a lot of courage \u2013 to move in the opposite direction. \u2013 Ernst Friedrich \u201cFritz\u201d Schumacher (in Small is Beautiful). Links \u00b6 https://fsharpforfunandprofit.com/posts/property-based-testing-2/ How to specify it? , video (jump until minute 10 for start of content). How to write test and stay sane? Jessica Kerr (midwest.io 2014) ScalaCheck (book about PBT) Fast check , quick check for javascript. Hypothesis , quick check for python. See also (generated) \u00b6 <20200430155637-applied_clojure.md> <20200430235013-specs.md>","title":"Generative Testing"},{"location":"cards/20200516171955-generative_testing/#generative-testing","text":"","title":"Generative Testing"},{"location":"cards/20200516171955-generative_testing/#properties","text":"Taking from Applied Clojure We are looking for invariants \u2013 properties that are always true. [\u2026] mathematical laws, relationships between inputs and outputs, round-trip or complementing functions, and comparing action effects. Properties like identity, associativity, commutativity and idempotency are an excellent place to start. Other general properties: membership is not modified (frequencies of element still are the same), maybe distinct for sets and hash-map. Trusted implementation. Compare the results and calculation on a trusted different implementation (different language, slower/faster version). For stateful components (like database), apply same logical operation on a logical model correct implementation like hash-map or vectors (e.g. create is assoc , delete is dissoc ). Avoid to implement again the same algorithms. Commutativity of operations Hard to prove, quick to verify (e.g. path in maze to the exit). Backward properties: generate the output and think which input would have yielded this output (like in finding a key in a hash map: inserting the key first to insure the key is in the collection). Expect failures and create failure. Ask the hard questions. Create the visibility you need (for asserting that a function did what it is supposed to do). What defines success of a service? This leads to property. Hammock time leads (care and randomness). Preconditions are predicates returning if some operations are valid, given the state of object or input of the function. If the preconditions is not met, then it is a noop (no operation). Postcondition are what ought to be true after the function call (usually we check if the result coincide with a predicted model).","title":"Properties"},{"location":"cards/20200516171955-generative_testing/#how-to-specify-it","text":"Talk about how to specify properties for pure functions. Invariant: things that ought to be always true. Optimize for correctness in the assertion, not for performance (test case are usually small). Make sure that generator are also valid. Postcondition: Asking what is the postcondition? Finding what ought to be true after the function call. If the properties requires to have the function under test, create a generator that insures that the state is consistent (for example, in a hash-map, for testing contains? , you can insert and remove key to test the properties of contains? ). Metamorphic properties: instead of predicting and test the result from an input, predict and test the relationship of result from two almost input. It is the idea of paths for getting to a final state. The relationship could be equality, size comparison. You can also check equivalence on result (as function of the result). You have to change in terms of the space of continuous functions: if input change, how will the change on the image be \\Delta f = f(x+\\delta) - f(x) \\Delta f = f(x+\\delta) - f(x) ? Some write metamorphic relations. Inductive properties: argument by induction that only the correct function can pass the test (using recursion). Double check the conformity by applying operations that should also keep the result valid. Model-based properties: similar to trusted implementation by working on a abstraction function with an abstraction operation. The assumption is you can convert your result into the abstraction and applying the same operations on the abstraction (you have an homomorphism ). Model-based properties is one of the most powerful representation. However, the model based properties can look too alike than the implementation or the function under test. If you feel you write too much code on the model based version, switch to metamorphic properties do not require on a model (and they are easier to write with good effectiveness). Invariant properties should be first because they are the most fundamental.","title":"How to specify it"},{"location":"cards/20200516171955-generative_testing/#source","text":"How to specify it? , video (jump until minute 10 for start of content).","title":"Source"},{"location":"cards/20200516171955-generative_testing/#geneartive-testing-group-theory-and-category-theory","text":"The model based properties (as in how to specify it) are the most powerful when you can find an isomorphism between your function or system under test for a certain algebras (or structure, or restricted invariant). This is powerful because you can then apply your operation on your model space which is probably much simpler and in all time transform the result back into function space. As finding algebraic structure (or group operation) might be too restrictive, we can relax the hypothesis to category theory (as long as we still have a bijective/ismorphic map). Isomorphism spaces are useful as they equivalent and their representation might used from one space to the other for practical purposes. For practical concerns, once you find an isomorphism to the function or entity under test, you can usually find many equivalent operations from your system onto your model and can randomly apply these property in any order to insure that your implementation is correct.","title":"Geneartive Testing, Group Theory and Category Theory"},{"location":"cards/20200516171955-generative_testing/#property-based-testing-with-proper","text":"Side effects can be grouped together at one end of the system, and we can keep the rest of the code as pure as possible. Targeted Properties and Simulated Annealing are cool stuff to learn about, even if you won\u2019t use Property-Based Testing that much. Don\u2019t skim over that chapter in the book. Any intelligent fool can make things bigger, more complex, and more violent. It takes a touch of genius \u2013 and a lot of courage \u2013 to move in the opposite direction. \u2013 Ernst Friedrich \u201cFritz\u201d Schumacher (in Small is Beautiful).","title":"Property Based Testing with Proper"},{"location":"cards/20200516171955-generative_testing/#links","text":"https://fsharpforfunandprofit.com/posts/property-based-testing-2/ How to specify it? , video (jump until minute 10 for start of content). How to write test and stay sane? Jessica Kerr (midwest.io 2014) ScalaCheck (book about PBT) Fast check , quick check for javascript. Hypothesis , quick check for python.","title":"Links"},{"location":"cards/20200516171955-generative_testing/#see-also-generated","text":"<20200430155637-applied_clojure.md> <20200430235013-specs.md>","title":"See also (generated)"},{"location":"cards/20200516210112-john_hughes/","text":"John Hughes \u00b6 Creator quick check. Links \u00b6 How to specify it? , video (jump until minute 10 for start of content). How to write test and stay sane? wiki See also (generated) \u00b6 -","title":"John Hughes"},{"location":"cards/20200516210112-john_hughes/#john-hughes","text":"Creator quick check.","title":"John Hughes"},{"location":"cards/20200516210112-john_hughes/#links","text":"How to specify it? , video (jump until minute 10 for start of content). How to write test and stay sane? wiki","title":"Links"},{"location":"cards/20200516210112-john_hughes/#see-also-generated","text":"-","title":"See also (generated)"},{"location":"cards/20200517205339-clojure_zippers/","text":"Clojure Zippers \u00b6 Usually tress are of the forms of maps and vectors ( defn map-zipper [ m ] ( zip/zipper ( fn [ x ] ( or ( map? x ) # _ ( vector? x )) ( fn [ x ] ( :children x )) ( fn [ x children ] ( assoc x :children children )) m )) Links \u00b6 https://clojuredocs.org/clojure.zip https://lambdaisland.com/blog/2018-11-26-art-tree-shaping-clojure-zip http://josf.info/blog/2014/03/21/getting-acquainted-with-clojure-zippers/ http://josf.info/blog/2014/03/28/clojure-zippers-structure-editing-with-your-mind/ http://josf.info/blog/2014/04/14/seqs-of-clojure-zippers/ See also (generated) \u00b6 <../decks/clojure.md>","title":"Clojure Zippers"},{"location":"cards/20200517205339-clojure_zippers/#clojure-zippers","text":"Usually tress are of the forms of maps and vectors ( defn map-zipper [ m ] ( zip/zipper ( fn [ x ] ( or ( map? x ) # _ ( vector? x )) ( fn [ x ] ( :children x )) ( fn [ x children ] ( assoc x :children children )) m ))","title":"Clojure Zippers"},{"location":"cards/20200517205339-clojure_zippers/#links","text":"https://clojuredocs.org/clojure.zip https://lambdaisland.com/blog/2018-11-26-art-tree-shaping-clojure-zip http://josf.info/blog/2014/03/21/getting-acquainted-with-clojure-zippers/ http://josf.info/blog/2014/03/28/clojure-zippers-structure-editing-with-your-mind/ http://josf.info/blog/2014/04/14/seqs-of-clojure-zippers/","title":"Links"},{"location":"cards/20200517205339-clojure_zippers/#see-also-generated","text":"<../decks/clojure.md>","title":"See also (generated)"},{"location":"cards/20200517212936-postmortem/","text":"Postmortem \u00b6 A tiny value-oriented debugging tool for Clojure(Script), powered by transducers Links \u00b6 https://github.com/athos/postmortem See also (generated) \u00b6 <20200505124946-clj_toolkit.md>","title":"Postmortem"},{"location":"cards/20200517212936-postmortem/#postmortem","text":"A tiny value-oriented debugging tool for Clojure(Script), powered by transducers","title":"Postmortem"},{"location":"cards/20200517212936-postmortem/#links","text":"https://github.com/athos/postmortem","title":"Links"},{"location":"cards/20200517212936-postmortem/#see-also-generated","text":"<20200505124946-clj_toolkit.md>","title":"See also (generated)"},{"location":"cards/20200521223909-computer_science_interview/","text":"Computer Science Interview \u00b6 https://teachyourselfcs.com/ https://leetcode.com/problemset/all/ https://github.com/jwasham/coding-interview-university#coding-question-practice Test Yourself CS \u00b6 SICP Computer Architectures Data Structure and Algorithms: Lecture videos Source \u00b6 https://threadreaderapp.com/thread/1263309093457944576.html See also (generated) \u00b6 -","title":"Computer Science Interview"},{"location":"cards/20200521223909-computer_science_interview/#computer-science-interview","text":"https://teachyourselfcs.com/ https://leetcode.com/problemset/all/ https://github.com/jwasham/coding-interview-university#coding-question-practice","title":"Computer Science Interview"},{"location":"cards/20200521223909-computer_science_interview/#test-yourself-cs","text":"SICP Computer Architectures Data Structure and Algorithms: Lecture videos","title":"Test Yourself CS"},{"location":"cards/20200521223909-computer_science_interview/#source","text":"https://threadreaderapp.com/thread/1263309093457944576.html","title":"Source"},{"location":"cards/20200521223909-computer_science_interview/#see-also-generated","text":"-","title":"See also (generated)"},{"location":"cards/20200521232124-cljss/","text":"cljss \u00b6 Clojure Style Sheets \u2014 CSS-in-JS for ClojureScript A solution to CSS in ClojureScript. defstyle and defstyled are the key function (use the cljss.reagent ) for importing defstyled . Source \u00b6 cljss See also (generated) \u00b6 <../decks/clojure.md> <20200430154647-shadow_cljs.md>","title":"cljss"},{"location":"cards/20200521232124-cljss/#cljss","text":"Clojure Style Sheets \u2014 CSS-in-JS for ClojureScript A solution to CSS in ClojureScript. defstyle and defstyled are the key function (use the cljss.reagent ) for importing defstyled .","title":"cljss"},{"location":"cards/20200521232124-cljss/#source","text":"cljss","title":"Source"},{"location":"cards/20200521232124-cljss/#see-also-generated","text":"<../decks/clojure.md> <20200430154647-shadow_cljs.md>","title":"See also (generated)"},{"location":"cards/20200524185034-clojure_functional_programming_principles/","text":"Clojure Functional Programming Principles \u00b6 The two foundational core idea of Clojure are pure functions and immutable data structure. Pure and first class functions \u00b6 Pure functions are functions without side effects and return the same result when given the same input, at any time and any circumstance. Side effect free means that the function will not cause any logical change to the state of the program or the world (the program will consume energy). The second property (returns the same output if the function is given the same input) means a pure function internals can only depends its inputs and external information that is constant (e.g. global constant values). This does not prevent the function to use mutable data structure as long as they are internal and does not affect the outside world nor the consumer. A common pattern is to create a mutable variant of a data structure (via transient! ) at the start of the function call and return a immutable (via persistent! ). First class functions means functions are can accept functions in their inputs and hence are a value. Immutability \u00b6 Immutability is the default idiom. Immutability means that logically a variable can only be replaced and never modified. It is best understood with a comparison with python (where the default idiom is to have mutable data structure). d = { \"a\" : 3 } f ( d ) # some hypothetical function f ( def d { :a 3 }) ( f d ) ;; some hypothetical function f ;; what is d? In python, you can not know the value of d , as the function f might change its content and has repercussion on the global d . Whereas in the Clojure, d kept its original value {:a 3} . This allows to dramatically simplify the task of reasoning about code behavior, especially in concurrent environment where operations are non deterministic. Immutability is achieved through persistent data structure which efficiently models the replacement of variables. Obviously, other languages can emulate the behavior, but the difference it is not the default idiom and hence require conventions and focus to not fall in the pitfall of mutability. Dynamic emphasis, data and values \u00b6 We code in data and values, that is generic types are left as is and no artificial types is generally not enforced. There are only few generic types and values: Atomic: nil , booleans, integers, floats, string, characters, dates, keywords, symbols (maybe a few other) Composite: vectors, maps, sets, list, sorted-map. We respect this fact and try to code as much as possible with values. The language is dynamic, hence it handles heterogeneous collections and return types and polymorphism. Links \u00b6 Clojure rationale edn transit See also (generated) \u00b6 <../decks/clojure.md> <20200430154647-shadow_cljs.md>","title":"Clojure Functional Programming Principles"},{"location":"cards/20200524185034-clojure_functional_programming_principles/#clojure-functional-programming-principles","text":"The two foundational core idea of Clojure are pure functions and immutable data structure.","title":"Clojure Functional Programming Principles"},{"location":"cards/20200524185034-clojure_functional_programming_principles/#pure-and-first-class-functions","text":"Pure functions are functions without side effects and return the same result when given the same input, at any time and any circumstance. Side effect free means that the function will not cause any logical change to the state of the program or the world (the program will consume energy). The second property (returns the same output if the function is given the same input) means a pure function internals can only depends its inputs and external information that is constant (e.g. global constant values). This does not prevent the function to use mutable data structure as long as they are internal and does not affect the outside world nor the consumer. A common pattern is to create a mutable variant of a data structure (via transient! ) at the start of the function call and return a immutable (via persistent! ). First class functions means functions are can accept functions in their inputs and hence are a value.","title":"Pure and first class functions"},{"location":"cards/20200524185034-clojure_functional_programming_principles/#immutability","text":"Immutability is the default idiom. Immutability means that logically a variable can only be replaced and never modified. It is best understood with a comparison with python (where the default idiom is to have mutable data structure). d = { \"a\" : 3 } f ( d ) # some hypothetical function f ( def d { :a 3 }) ( f d ) ;; some hypothetical function f ;; what is d? In python, you can not know the value of d , as the function f might change its content and has repercussion on the global d . Whereas in the Clojure, d kept its original value {:a 3} . This allows to dramatically simplify the task of reasoning about code behavior, especially in concurrent environment where operations are non deterministic. Immutability is achieved through persistent data structure which efficiently models the replacement of variables. Obviously, other languages can emulate the behavior, but the difference it is not the default idiom and hence require conventions and focus to not fall in the pitfall of mutability.","title":"Immutability"},{"location":"cards/20200524185034-clojure_functional_programming_principles/#dynamic-emphasis-data-and-values","text":"We code in data and values, that is generic types are left as is and no artificial types is generally not enforced. There are only few generic types and values: Atomic: nil , booleans, integers, floats, string, characters, dates, keywords, symbols (maybe a few other) Composite: vectors, maps, sets, list, sorted-map. We respect this fact and try to code as much as possible with values. The language is dynamic, hence it handles heterogeneous collections and return types and polymorphism.","title":"Dynamic emphasis, data and values"},{"location":"cards/20200524185034-clojure_functional_programming_principles/#links","text":"Clojure rationale edn transit","title":"Links"},{"location":"cards/20200524185034-clojure_functional_programming_principles/#see-also-generated","text":"<../decks/clojure.md> <20200430154647-shadow_cljs.md>","title":"See also (generated)"},{"location":"cards/202005291001-starting_scripting_clojure/","text":"Starting Scripting Clojure \u00b6 How to enjoy scripting in Clojure? I am describing my small Clojure setup to let me experiment with the language and solve many of my tasks. I am trying to explain how you could (and understand how to) start a REPL Driven Development in most folder location with low ceremony and with your (hopefully) favorite text editor What is the problem? \u00b6 Setting the environment in Clojure is notoriously hard. When I started learning Clojure, we had to use leinigen, set the project.clj file with all the java/clojure options (I honestly still don\u2019t know them since I am using deps.edn now). My annoyance was for many of my tasks, I just wanted to launch a REPL in a given folder, create a new .clj file, build a connection between the REPL and my text editor (Emacs obviously), and start to code and send forms to the REPL (REPL driven development). When do this occasions arise? Usually, you just want to rename files in your tree, to work on some of your colleagues inputs and use Clojure for making the data transformation, or to create some command line scripts, or to solve online problems for training your Clojure skills. Why does it matter? I used R and python previously. In both languages, I really appreciated the ability to just create a .r or .py file, open a REPL from Emacs and start to code interactively. It felt easy and lowered my cognitive load to experiment with the languages and learn them. I think my appreciation of Clojure changed the day I managed to get the same workflow working in many context and it might help many. Goals \u00b6 Ability to start scripting and a repl with your text editor in any folder with low ceremony. Quick start of scripts in Clojure which can be converted into bigger project. Too long don\u2019t read \u00b6 First, insure your text editor support nrepl (emacs, vim, IntelliJ, VS Code and Atom support it) and download the required package to support your Clojure development. Then, two solutions Install clojure, and then for a clojure For super fast startup and for shell scripting you can install babashka. Then start the repl with bb --nrepl-server 1667 Setting up your machines \u00b6 nrepl Brew install clojure, download babhaska. Adding dependencies \u00b6 You can add deps. If you use babashka, it has its own methods for adding dependencies (read here). Generality of the solution \u00b6 So can we use the same process for real projects? Yes. Ironically, I found my solution while working on big projects. How do you start a bigger project? Create deps.edn in the root directory of your project, create your src folder, add the :paths (usually [\"src\"] ) and :deps and you can start organizing your code. This workflow helped me tremendously when coding in ClojureScript. I use shadow-cljs and the typical workflow is to start it on the command line for compiling and watching change of your source code. I spent a bit of time understanding how I could connect Emacs to the REPL ( M-x cider-connect-cljs ) which was different than the typical cider-jack-in function. ClojureScript, other targets and considerations \u00b6 I describe my workflow for writing quick script with Clojure JVM. Obviously, there are alternatives with other costs/benefits attributes. lumo and plank for leveraging the node and the javascript environment. joker, an Clojure implementation in Go. That being said, I know many expert Clojurian have a single REPL process running for weeks, hence the start of a REPL might not matter after some level of expertise. I still like the ability to launch a REPL in any folder, without thinking too much. In some situation, nrepl might be a too high requirement for your project (because the library does a lot under the hood). In this case, look at the socket REPL (insert link). I don\u2019t have a lot of experience with the socket REPL, except that emacs use the inf-clojure mode to interact with it. Steps summary \u00b6 Find a text editor/IDE that supports the nrepl (it should not be that hard). Write a simple command line that can launch a nrepl server in the root directory where you want to work. It can be as easy as calling bb --nrepl-server or clojure -A:nrepl after defining the :nrepl alias in .clojure/deps.edn . Note the port or set it to a fix value. Create a .clj (anywhere) Connect your text editor to the REPL and start sending forms from your file. Once you feel comfortable with this workflow, see how you can adapt it to other situations (e.g. ClojureScript, react native, server repl, server vm). Conclusion \u00b6 The goal of the post is to give you a straightforward plan for kick start repl driven development. You achieve this by having a compatible editor, launching a nrepl server with clojure or bb , connecting your editor to the REPL. I hope this simple workflow will allow to experiment much more with Clojure and have fun with it. See also (generated) \u00b6 -","title":"Starting Scripting Clojure"},{"location":"cards/202005291001-starting_scripting_clojure/#starting-scripting-clojure","text":"How to enjoy scripting in Clojure? I am describing my small Clojure setup to let me experiment with the language and solve many of my tasks. I am trying to explain how you could (and understand how to) start a REPL Driven Development in most folder location with low ceremony and with your (hopefully) favorite text editor","title":"Starting Scripting Clojure"},{"location":"cards/202005291001-starting_scripting_clojure/#what-is-the-problem","text":"Setting the environment in Clojure is notoriously hard. When I started learning Clojure, we had to use leinigen, set the project.clj file with all the java/clojure options (I honestly still don\u2019t know them since I am using deps.edn now). My annoyance was for many of my tasks, I just wanted to launch a REPL in a given folder, create a new .clj file, build a connection between the REPL and my text editor (Emacs obviously), and start to code and send forms to the REPL (REPL driven development). When do this occasions arise? Usually, you just want to rename files in your tree, to work on some of your colleagues inputs and use Clojure for making the data transformation, or to create some command line scripts, or to solve online problems for training your Clojure skills. Why does it matter? I used R and python previously. In both languages, I really appreciated the ability to just create a .r or .py file, open a REPL from Emacs and start to code interactively. It felt easy and lowered my cognitive load to experiment with the languages and learn them. I think my appreciation of Clojure changed the day I managed to get the same workflow working in many context and it might help many.","title":"What is the problem?"},{"location":"cards/202005291001-starting_scripting_clojure/#goals","text":"Ability to start scripting and a repl with your text editor in any folder with low ceremony. Quick start of scripts in Clojure which can be converted into bigger project.","title":"Goals"},{"location":"cards/202005291001-starting_scripting_clojure/#too-long-dont-read","text":"First, insure your text editor support nrepl (emacs, vim, IntelliJ, VS Code and Atom support it) and download the required package to support your Clojure development. Then, two solutions Install clojure, and then for a clojure For super fast startup and for shell scripting you can install babashka. Then start the repl with bb --nrepl-server 1667","title":"Too long don&rsquo;t read"},{"location":"cards/202005291001-starting_scripting_clojure/#setting-up-your-machines","text":"nrepl Brew install clojure, download babhaska.","title":"Setting up your machines"},{"location":"cards/202005291001-starting_scripting_clojure/#adding-dependencies","text":"You can add deps. If you use babashka, it has its own methods for adding dependencies (read here).","title":"Adding dependencies"},{"location":"cards/202005291001-starting_scripting_clojure/#generality-of-the-solution","text":"So can we use the same process for real projects? Yes. Ironically, I found my solution while working on big projects. How do you start a bigger project? Create deps.edn in the root directory of your project, create your src folder, add the :paths (usually [\"src\"] ) and :deps and you can start organizing your code. This workflow helped me tremendously when coding in ClojureScript. I use shadow-cljs and the typical workflow is to start it on the command line for compiling and watching change of your source code. I spent a bit of time understanding how I could connect Emacs to the REPL ( M-x cider-connect-cljs ) which was different than the typical cider-jack-in function.","title":"Generality of the solution"},{"location":"cards/202005291001-starting_scripting_clojure/#clojurescript-other-targets-and-considerations","text":"I describe my workflow for writing quick script with Clojure JVM. Obviously, there are alternatives with other costs/benefits attributes. lumo and plank for leveraging the node and the javascript environment. joker, an Clojure implementation in Go. That being said, I know many expert Clojurian have a single REPL process running for weeks, hence the start of a REPL might not matter after some level of expertise. I still like the ability to launch a REPL in any folder, without thinking too much. In some situation, nrepl might be a too high requirement for your project (because the library does a lot under the hood). In this case, look at the socket REPL (insert link). I don\u2019t have a lot of experience with the socket REPL, except that emacs use the inf-clojure mode to interact with it.","title":"ClojureScript, other targets and considerations"},{"location":"cards/202005291001-starting_scripting_clojure/#steps-summary","text":"Find a text editor/IDE that supports the nrepl (it should not be that hard). Write a simple command line that can launch a nrepl server in the root directory where you want to work. It can be as easy as calling bb --nrepl-server or clojure -A:nrepl after defining the :nrepl alias in .clojure/deps.edn . Note the port or set it to a fix value. Create a .clj (anywhere) Connect your text editor to the REPL and start sending forms from your file. Once you feel comfortable with this workflow, see how you can adapt it to other situations (e.g. ClojureScript, react native, server repl, server vm).","title":"Steps summary"},{"location":"cards/202005291001-starting_scripting_clojure/#conclusion","text":"The goal of the post is to give you a straightforward plan for kick start repl driven development. You achieve this by having a compatible editor, launching a nrepl server with clojure or bb , connecting your editor to the REPL. I hope this simple workflow will allow to experiment much more with Clojure and have fun with it.","title":"Conclusion"},{"location":"cards/202005291001-starting_scripting_clojure/#see-also-generated","text":"-","title":"See also (generated)"},{"location":"cards/20200823205222-datascript/","text":"datascript \u00b6 First step with datascript. \u00b6 Transformation of the input is required, and transactions are not for free. Usually, it requires setting a schema and wrapping the keys for external entities into a datascript representation. Quote the queries in d/q . You can use the vector form ( [:db/add] , [:db/retract] ) or the map form ( {:user/id \"my name\"} , see datascript test for more example. re-frame and datascript \u00b6 Re-frame is one of the common state management library in ClojureScript. It is an event with publisher subscriber system. The advantage of adding datascript to re-frame is the ability to exploit the query language and the normalization layer. There exist multiple package to couple the language but I found that the easiest way to leverage on datascript is to create immutable datascript database inside the re-frame database and to refer to them through subscription and us datascript.api/db-with to perform transactions. Since the database is immutable, the subscription will react on any change to the datastore. ( require ' [ datascript.core :as d ]) ( require ' [ re-frame.core :as rf ]) ( def schema { :user/id { :db/unique :db.unique/identity }}) ( def db-init { :ds ( d/empty-db schema )}) ( rf/reg-event-db :init ( fn [ _ _ ] db-init )) ( rf/reg-event-db :ds-transact ( fn [ db [ _ tx-data ]] ( update db :ds d/db-with tx-data ))) ( rf/reg-sub :ds ( fn [ db ] ( :ds db ))) ( rf/reg-sub :users :<- [ :ds ] ( fn [ ds ] ( d/q ' [ :find ( pull ?e [ * ]) :where [ ?e :user/id ]] ds ))) The users subscriptions will now be updated every time we transact a new users. ( rf/dispatch [ :init ]) ;; initialize the database ( rf/dispatch [ :ds-transact [{ :user/id \"jean\" }]]) @ ( rf/subscribe [ :users ]) ;; => ([{:db/id 1, :user/id \"jean\"}]) ( rf/dispatch [ :ds-transact [{ :user/id \"logan\" }]]) @ ( rf/subscribe [ :users ]) ;; => ([{:db/id 1, :user/id \"jean\"}] [{:db/id 2, :user/id \"logan\"}]) The advantage of this methods is that we keep re-frame and datascript concepts separate: Re-frame events and subscriptions are the same as before (in contrast to posh/re-posh), and datascript queries and transactions are performed against an actual datascript database. Caveat \u00b6 When queries are time expensive and multiple queries exist within a single view, all the subscription queries will run after any change in the datascript db. To avoid this, one can/should use posh/re-posh. The library detects the data required for queries and rerun them only when the underlying data has been modified by the transaction. The advantage of the library is obviously speed. The disadvantage is a new layer of complexity in the web app, as re-posh does not integrate seamlessly with re-frame. The performance issue without re-posh, might be a concern in some context [e.g. live streaming or live data updating, and chatting], but these can be avoided by creating multiple store inside re-frame and also transacting data smartly. Links \u00b6 https://github.com/tonsky/datascript See also (generated) \u00b6 -","title":"datascript"},{"location":"cards/20200823205222-datascript/#datascript","text":"","title":"datascript"},{"location":"cards/20200823205222-datascript/#first-step-with-datascript","text":"Transformation of the input is required, and transactions are not for free. Usually, it requires setting a schema and wrapping the keys for external entities into a datascript representation. Quote the queries in d/q . You can use the vector form ( [:db/add] , [:db/retract] ) or the map form ( {:user/id \"my name\"} , see datascript test for more example.","title":"First step with datascript."},{"location":"cards/20200823205222-datascript/#re-frame-and-datascript","text":"Re-frame is one of the common state management library in ClojureScript. It is an event with publisher subscriber system. The advantage of adding datascript to re-frame is the ability to exploit the query language and the normalization layer. There exist multiple package to couple the language but I found that the easiest way to leverage on datascript is to create immutable datascript database inside the re-frame database and to refer to them through subscription and us datascript.api/db-with to perform transactions. Since the database is immutable, the subscription will react on any change to the datastore. ( require ' [ datascript.core :as d ]) ( require ' [ re-frame.core :as rf ]) ( def schema { :user/id { :db/unique :db.unique/identity }}) ( def db-init { :ds ( d/empty-db schema )}) ( rf/reg-event-db :init ( fn [ _ _ ] db-init )) ( rf/reg-event-db :ds-transact ( fn [ db [ _ tx-data ]] ( update db :ds d/db-with tx-data ))) ( rf/reg-sub :ds ( fn [ db ] ( :ds db ))) ( rf/reg-sub :users :<- [ :ds ] ( fn [ ds ] ( d/q ' [ :find ( pull ?e [ * ]) :where [ ?e :user/id ]] ds ))) The users subscriptions will now be updated every time we transact a new users. ( rf/dispatch [ :init ]) ;; initialize the database ( rf/dispatch [ :ds-transact [{ :user/id \"jean\" }]]) @ ( rf/subscribe [ :users ]) ;; => ([{:db/id 1, :user/id \"jean\"}]) ( rf/dispatch [ :ds-transact [{ :user/id \"logan\" }]]) @ ( rf/subscribe [ :users ]) ;; => ([{:db/id 1, :user/id \"jean\"}] [{:db/id 2, :user/id \"logan\"}]) The advantage of this methods is that we keep re-frame and datascript concepts separate: Re-frame events and subscriptions are the same as before (in contrast to posh/re-posh), and datascript queries and transactions are performed against an actual datascript database.","title":"re-frame and datascript"},{"location":"cards/20200823205222-datascript/#caveat","text":"When queries are time expensive and multiple queries exist within a single view, all the subscription queries will run after any change in the datascript db. To avoid this, one can/should use posh/re-posh. The library detects the data required for queries and rerun them only when the underlying data has been modified by the transaction. The advantage of the library is obviously speed. The disadvantage is a new layer of complexity in the web app, as re-posh does not integrate seamlessly with re-frame. The performance issue without re-posh, might be a concern in some context [e.g. live streaming or live data updating, and chatting], but these can be avoided by creating multiple store inside re-frame and also transacting data smartly.","title":"Caveat"},{"location":"cards/20200823205222-datascript/#links","text":"https://github.com/tonsky/datascript","title":"Links"},{"location":"cards/20200823205222-datascript/#see-also-generated","text":"-","title":"See also (generated)"},{"location":"cards/continuing_education/","text":"Continuing Education \u00b6 TODO FRM \u00b6 Read and do the exams for the two tests. TODO CFA \u00b6 Level 2 \u00b6 [X] Register [ ] Study TODO CQF \u00b6 TODO Udacity Nanodegree \u00b6 TODO Fullstack \u00b6 TODO Data Streaming \u00b6 DONE Front-end \u00b6 Not necessary thanks to ClojureScript. DONE Deep learning \u00b6 DONE Machine learning \u00b6 TODO Edx \u00b6 Finish Micro Master in statistics and Data Science. See also (generated) \u00b6 -","title":"Continuing Education"},{"location":"cards/continuing_education/#continuing-education","text":"","title":"Continuing Education"},{"location":"cards/continuing_education/#todo-frm","text":"Read and do the exams for the two tests.","title":"TODO FRM"},{"location":"cards/continuing_education/#todo-cfa","text":"","title":"TODO CFA"},{"location":"cards/continuing_education/#level-2","text":"[X] Register [ ] Study","title":"Level 2"},{"location":"cards/continuing_education/#todo-cqf","text":"","title":"TODO CQF"},{"location":"cards/continuing_education/#todo-udacity-nanodegree","text":"","title":"TODO Udacity Nanodegree"},{"location":"cards/continuing_education/#todo-fullstack","text":"","title":"TODO Fullstack"},{"location":"cards/continuing_education/#todo-data-streaming","text":"","title":"TODO Data Streaming"},{"location":"cards/continuing_education/#done-front-end","text":"Not necessary thanks to ClojureScript.","title":"DONE Front-end"},{"location":"cards/continuing_education/#done-deep-learning","text":"","title":"DONE Deep learning"},{"location":"cards/continuing_education/#done-machine-learning","text":"","title":"DONE Machine learning"},{"location":"cards/continuing_education/#todo-edx","text":"Finish Micro Master in statistics and Data Science.","title":"TODO Edx"},{"location":"cards/continuing_education/#see-also-generated","text":"-","title":"See also (generated)"},{"location":"cards/cpp/","text":"C/C++ \u00b6 [ ] Learn C the hard way [ ] Use Cling , the C++ interpreter [X] Learn CUDA <-> Udacity [ ] Read a tour of C++ [ ] Modern C++ (Scott Meyer) [ ] Redo the cpp exercise [ ] Reread Google Style Guide in C++ See also (generated) \u00b6 -","title":"C/C++"},{"location":"cards/cpp/#cc","text":"[ ] Learn C the hard way [ ] Use Cling , the C++ interpreter [X] Learn CUDA <-> Udacity [ ] Read a tour of C++ [ ] Modern C++ (Scott Meyer) [ ] Redo the cpp exercise [ ] Reread Google Style Guide in C++","title":"C/C++"},{"location":"cards/cpp/#see-also-generated","text":"-","title":"See also (generated)"},{"location":"cards/devops/","text":"Docker and Kubernete \u00b6 Docker are containers/processes which can be considered as lightweight VMs. Kuberenetes (K8s) are container orchestration. They allow for load balancing (2 level with ingress (external load balancing) and service (internal load balancer)) on pods (docker containers). They allow for recover from failure for resource, and rolling update. DevOPS \u00b6 Learn about ansible (again). Ubuntu Server/Install Starting Projects \u00b6 DONE Git [3/3] \u00b6 Remains to test in practice, but the project is pretty stable now. [X] Create a python file that writes the makefile automatically [X] Create README.md where appropriate. [X] Test the application See also (generated) \u00b6 <20200505093126-multipass.md> <20200505093245-ansible.md> <20200505112918-nginx.md>","title":"Docker and Kubernete"},{"location":"cards/devops/#docker-and-kubernete","text":"Docker are containers/processes which can be considered as lightweight VMs. Kuberenetes (K8s) are container orchestration. They allow for load balancing (2 level with ingress (external load balancing) and service (internal load balancer)) on pods (docker containers). They allow for recover from failure for resource, and rolling update.","title":"Docker and Kubernete"},{"location":"cards/devops/#devops","text":"Learn about ansible (again).","title":"DevOPS"},{"location":"cards/devops/#ubuntu-serverinstall-starting-projects","text":"","title":"Ubuntu Server/Install Starting Projects"},{"location":"cards/devops/#done-git-33","text":"Remains to test in practice, but the project is pretty stable now. [X] Create a python file that writes the makefile automatically [X] Create README.md where appropriate. [X] Test the application","title":"DONE Git [3/3]"},{"location":"cards/devops/#see-also-generated","text":"<20200505093126-multipass.md> <20200505093245-ansible.md> <20200505112918-nginx.md>","title":"See also (generated)"},{"location":"cards/general/","text":"General \u00b6 Learn with https://www.hackerrank.com/ (especially Clojure). Complete some harder problems in functional programming. www.pythonchallenge.com Exercise TODO Read introduction to elisp \u00b6 TODO Diff, ediff \u00b6 a or b to select which version is correct. Append x for saving. In magit, use e for diffing with ediff. magit and git, gitimmersion \u00b6 [X] Revert file in magit [ ] Read introduction Master/read manual org-mode \u00b6 org-mode easy template (e.g. <s[tab] ) allows to easily include org syntax. C-c C-, to open the shortcut window. C-c C-q (insert tags), C-c / (filter org-file by). Rewrite emacs.d through org-mode and usepackage. \u00b6 It would be good to get a unified version of my .emacs.d with org files and usepackage. Dired mode \u00b6 Find files with grep Still have to learn the new shortcuts. Most important are R , C , D , ( , % m and =% g0. Using Q , empower the user to query and replace in files. Using * u to select all non-saved buffer to close them all. Perfect use of keyboard [2/2] \u00b6 [X] The comma should be hit with the middle finger. [X] Emacs keybindings should be used using both hands, this has to be set with key-bindings. Tip: use the hand palm for reaching the CTRL keys. [ ]: balance the space between the hand. Especially the right thumb as most words in english finish with the left hand letters. Write a script to update my-emacs-config automatically. \u00b6 Best way would be to use git. Used a fork of emacs-live. DONE Remap C-c C-z to C-c C-y for Swiss Keyboards, for terminal switching. \u00b6 DONE Emmet in Emacs, with HAML filter in the json snippet. \u00b6 HAML is automatic in emacs. However, the key bindings need to be remapped as the usage of `C-j` is too much widespread. DONE Cppcheck \u00b6 wget https://raw.githubusercontent.com/google/styleguide/gh-pages/cpplint/cpplint.py sudo mv cpplint.py /usr/local/bin/cpplint.py sudo chmod 755 /usr/local/bin/cpplint.py Also uncomment the following ( custom-set-variables ' ( flycheck-c/c++-googlelint-executable \"/usr/local/bin/cpplint.py\" )) in cpp-settings.el . DONE Aspell \u00b6 Set dictionary in French and German. sudo apt-get install aspell-fr aspell-de Go to char (avy-goto-word-or-subword-1) \u00b6 In prelude \"C-c j\" and then char jumps to a given character in the buffer. Deft ignore file regex \u00b6 Set deft-ignore-file-regexp [2020-05-06 Wed] . Regex in search \u00b6 For grouping you need to escape the parenthesis. Documentation on regex Escape characters See also (generated) \u00b6 <20200430154352-cli_arguments.md> <20200430154528-multiple_environment.md> <20200503165952-materiala.md> <20200505164639-cider.md>","title":"General"},{"location":"cards/general/#general","text":"Learn with https://www.hackerrank.com/ (especially Clojure). Complete some harder problems in functional programming. www.pythonchallenge.com Exercise","title":"General"},{"location":"cards/general/#todo-read-introduction-to-elisp","text":"","title":"TODO Read introduction to elisp"},{"location":"cards/general/#todo-diff-ediff","text":"a or b to select which version is correct. Append x for saving. In magit, use e for diffing with ediff.","title":"TODO Diff, ediff"},{"location":"cards/general/#magit-and-git-gitimmersion","text":"[X] Revert file in magit [ ] Read introduction","title":"magit and git, gitimmersion"},{"location":"cards/general/#masterread-manual-org-mode","text":"org-mode easy template (e.g. <s[tab] ) allows to easily include org syntax. C-c C-, to open the shortcut window. C-c C-q (insert tags), C-c / (filter org-file by).","title":"Master/read manual org-mode"},{"location":"cards/general/#rewrite-emacsd-through-org-mode-and-usepackage","text":"It would be good to get a unified version of my .emacs.d with org files and usepackage.","title":"Rewrite emacs.d through org-mode and usepackage."},{"location":"cards/general/#dired-mode","text":"Find files with grep Still have to learn the new shortcuts. Most important are R , C , D , ( , % m and =% g0. Using Q , empower the user to query and replace in files. Using * u to select all non-saved buffer to close them all.","title":"Dired mode"},{"location":"cards/general/#perfect-use-of-keyboard-22","text":"[X] The comma should be hit with the middle finger. [X] Emacs keybindings should be used using both hands, this has to be set with key-bindings. Tip: use the hand palm for reaching the CTRL keys. [ ]: balance the space between the hand. Especially the right thumb as most words in english finish with the left hand letters.","title":"Perfect use of keyboard [2/2]"},{"location":"cards/general/#write-a-script-to-update-my-emacs-config-automatically","text":"Best way would be to use git. Used a fork of emacs-live.","title":"Write a script to update my-emacs-config automatically."},{"location":"cards/general/#done-remap-c-c-c-z-to-c-c-c-y-for-swiss-keyboards-for-terminal-switching","text":"","title":"DONE Remap C-c C-z to C-c C-y for Swiss Keyboards, for terminal switching."},{"location":"cards/general/#done-emmet-in-emacs-with-haml-filter-in-the-json-snippet","text":"HAML is automatic in emacs. However, the key bindings need to be remapped as the usage of `C-j` is too much widespread.","title":"DONE Emmet in Emacs, with HAML filter in the json snippet."},{"location":"cards/general/#done-cppcheck","text":"wget https://raw.githubusercontent.com/google/styleguide/gh-pages/cpplint/cpplint.py sudo mv cpplint.py /usr/local/bin/cpplint.py sudo chmod 755 /usr/local/bin/cpplint.py Also uncomment the following ( custom-set-variables ' ( flycheck-c/c++-googlelint-executable \"/usr/local/bin/cpplint.py\" )) in cpp-settings.el .","title":"DONE Cppcheck"},{"location":"cards/general/#done-aspell","text":"Set dictionary in French and German. sudo apt-get install aspell-fr aspell-de","title":"DONE Aspell"},{"location":"cards/general/#go-to-char-avy-goto-word-or-subword-1","text":"In prelude \"C-c j\" and then char jumps to a given character in the buffer.","title":"Go to char (avy-goto-word-or-subword-1)"},{"location":"cards/general/#deft-ignore-file-regex","text":"Set deft-ignore-file-regexp [2020-05-06 Wed] .","title":"Deft ignore file regex"},{"location":"cards/general/#regex-in-search","text":"For grouping you need to escape the parenthesis. Documentation on regex Escape characters","title":"Regex in search"},{"location":"cards/general/#see-also-generated","text":"<20200430154352-cli_arguments.md> <20200430154528-multiple_environment.md> <20200503165952-materiala.md> <20200505164639-cider.md>","title":"See also (generated)"},{"location":"cards/python/","text":"Python \u00b6 [X] IPython [X] Jupyter Noteboks jupyter notebooks [ ] scikit, read documentation. [X] pylint pylintrc to determine which mistakes to solve. One can also use # pylint header in python files, e.g. pandas source code. you can use disable [X] pyflakes [ ] nose2 and automatic test. [X] Google Tensorflow . [ ] pytorch See also (generated) \u00b6 <20200430153912-ethz.md> <20200505111243-learning_tips.md>","title":"Python"},{"location":"cards/python/#python","text":"[X] IPython [X] Jupyter Noteboks jupyter notebooks [ ] scikit, read documentation. [X] pylint pylintrc to determine which mistakes to solve. One can also use # pylint header in python files, e.g. pandas source code. you can use disable [X] pyflakes [ ] nose2 and automatic test. [X] Google Tensorflow . [ ] pytorch","title":"Python"},{"location":"cards/python/#see-also-generated","text":"<20200430153912-ethz.md> <20200505111243-learning_tips.md>","title":"See also (generated)"},{"location":"cards/r_cran/","text":"R \u00b6 [X] Do the empirical stuff, start MSc Thesis. [X] Go through base R functions to discover new functions. [ ] Rcpp after revising C++. [X] Shiny. [ ] Set lintr on Emacs. See also (generated) \u00b6 <20200430153912-ethz.md>","title":"R"},{"location":"cards/r_cran/#r","text":"[X] Do the empirical stuff, start MSc Thesis. [X] Go through base R functions to discover new functions. [ ] Rcpp after revising C++. [X] Shiny. [ ] Set lintr on Emacs.","title":"R"},{"location":"cards/r_cran/#see-also-generated","text":"<20200430153912-ethz.md>","title":"See also (generated)"},{"location":"cards/readings/","text":"Books \u00b6 DONE How Google works \u00b6 Culture is the one thing to get right. Smart creatives are the core of the company. These are monsters, who can do everything and are social people. Hiring is vital, colleagues must be learning animals and smarter than you are. Consensus brings opposite point of view. Design someone as owner of meetings, transparency (about objectives, results and key results for all employees), manager sets deadlines. Innovation: shoot for the moon. Default to open for your technology. Quality of a product is the only dimension on which on should focus. Create new products because of technical insight. TODO Work rules from Google \u00b6 Culture makes it right. Vision. Openess. Hire smarter than you (in some meaningful way). Committee hiring. Trust your employees, managers to decide about deadlines and conflict. Performance review: 5 rank OKR: objectives, key, results and transparency about OKR. Manager Gives actionable feedback that helps improve performance No micromanagement Consideration as a person Keeps team focused on priority results/deliverable. Share relevant information from his manager and senior leadership. Meaningful discussion about career development every six months. Comminucates clear goals. Has techincal expertise required to effectively manage. Should be recommended to other coworkers. Learning: focus on learning few things but well. Repetition and internalization concepts or teaching material. TODO When To Rob A Bank. \u00b6 Culture Code. \u00b6 TODO The Art of Unix Programming \u00b6 Philosophy of linux. TODO Principles of financial engineering \u00b6 TODO Becoming a better programmer, Pete Goodliffe \u00b6 You.write(code) Favor common convention in style, strive for consistency and clarity, good design is better that good presentation. Write less code (elegance is paramount, DRY). Pay attention to logic operator to avoid if-else construct, use existing code to avoid bugs, delete dead code (never called function, never read variable, unused parameters and other types). Comments should explain the why . Try to use ternary operator as much as possible. Take responsibility of code removal and leave code a little better than it was. Improve code by remove it. Do not write code that you do not need now . A system can improve by removing code. It is inevitable that dead code arises. Zombie code makes your life harder. TODO Code Craft, Pete Goodliffe \u00b6 TODO Why I left Goldman Sachs \u00b6 TODO Lords of Finance \u00b6 TODO The Finance Curse: How global finance is making us all poorer \u00b6 SICP \u00b6 See also (generated) \u00b6 <../README.md>","title":"Books"},{"location":"cards/readings/#books","text":"","title":"Books"},{"location":"cards/readings/#done-how-google-works","text":"Culture is the one thing to get right. Smart creatives are the core of the company. These are monsters, who can do everything and are social people. Hiring is vital, colleagues must be learning animals and smarter than you are. Consensus brings opposite point of view. Design someone as owner of meetings, transparency (about objectives, results and key results for all employees), manager sets deadlines. Innovation: shoot for the moon. Default to open for your technology. Quality of a product is the only dimension on which on should focus. Create new products because of technical insight.","title":"DONE How Google works"},{"location":"cards/readings/#todo-work-rules-from-google","text":"Culture makes it right. Vision. Openess. Hire smarter than you (in some meaningful way). Committee hiring. Trust your employees, managers to decide about deadlines and conflict. Performance review: 5 rank OKR: objectives, key, results and transparency about OKR. Manager Gives actionable feedback that helps improve performance No micromanagement Consideration as a person Keeps team focused on priority results/deliverable. Share relevant information from his manager and senior leadership. Meaningful discussion about career development every six months. Comminucates clear goals. Has techincal expertise required to effectively manage. Should be recommended to other coworkers. Learning: focus on learning few things but well. Repetition and internalization concepts or teaching material.","title":"TODO Work rules from Google"},{"location":"cards/readings/#todo-when-to-rob-a-bank","text":"","title":"TODO When To Rob A Bank."},{"location":"cards/readings/#culture-code","text":"","title":"Culture Code."},{"location":"cards/readings/#todo-the-art-of-unix-programming","text":"Philosophy of linux.","title":"TODO The Art of Unix Programming"},{"location":"cards/readings/#todo-principles-of-financial-engineering","text":"","title":"TODO Principles of financial engineering"},{"location":"cards/readings/#todo-becoming-a-better-programmer-pete-goodliffe","text":"You.write(code) Favor common convention in style, strive for consistency and clarity, good design is better that good presentation. Write less code (elegance is paramount, DRY). Pay attention to logic operator to avoid if-else construct, use existing code to avoid bugs, delete dead code (never called function, never read variable, unused parameters and other types). Comments should explain the why . Try to use ternary operator as much as possible. Take responsibility of code removal and leave code a little better than it was. Improve code by remove it. Do not write code that you do not need now . A system can improve by removing code. It is inevitable that dead code arises. Zombie code makes your life harder.","title":"TODO Becoming a better programmer, Pete Goodliffe"},{"location":"cards/readings/#todo-code-craft-pete-goodliffe","text":"","title":"TODO Code Craft, Pete Goodliffe"},{"location":"cards/readings/#todo-why-i-left-goldman-sachs","text":"","title":"TODO Why I left Goldman Sachs"},{"location":"cards/readings/#todo-lords-of-finance","text":"","title":"TODO Lords of Finance"},{"location":"cards/readings/#todo-the-finance-curse-how-global-finance-is-making-us-all-poorer","text":"","title":"TODO The Finance Curse: How global finance is making us all poorer"},{"location":"cards/readings/#sicp","text":"","title":"SICP"},{"location":"cards/readings/#see-also-generated","text":"<../README.md>","title":"See also (generated)"},{"location":"cards/unix/","text":"Unix command learning \u00b6 [X] find command: options are: -name (\"*.cpp\" or \".c\") , -type (f, d) , -mtime , use +/-[:digit:] for saying \u201cmore or less [:digit:] time\u201d, escaped parentheses \\( \\) , -a(nd) or -o(r) ! (negation) . The -exec option passes the result to the following instruction (like ls -s) with {} \\; for the place holder of the find results. [ ] Grep [ ] cron (scheduling). See also (generated) \u00b6 -","title":"Unix command learning"},{"location":"cards/unix/#unix-command-learning","text":"[X] find command: options are: -name (\"*.cpp\" or \".c\") , -type (f, d) , -mtime , use +/-[:digit:] for saying \u201cmore or less [:digit:] time\u201d, escaped parentheses \\( \\) , -a(nd) or -o(r) ! (negation) . The -exec option passes the result to the following instruction (like ls -s) with {} \\; for the place holder of the find results. [ ] Grep [ ] cron (scheduling).","title":"Unix command learning"},{"location":"cards/unix/#see-also-generated","text":"-","title":"See also (generated)"},{"location":"cards/website/","text":"Website [3/3] Recreate online cv with middleman and org for blog See also (generated) Website [3/3] \u00b6 [X] Learn html and css (udacity). [X] middleman (ruby) for static page generation. [3/3] [X] HAML, partial and filters. [X] Bootrstrap inteegration [X] Use the following to deploy interactively with live-reload. bundle exec middleman [X] Write about codemirror and mathjax in codemirror Recreate online cv with middleman and org for blog \u00b6 [X] Online cv done. [ ] Understand middleman gh-page for blog. [ ] Links org files. [ ] Publish summaries. See also (generated) \u00b6 -","title":"Website"},{"location":"cards/website/#website-33","text":"[X] Learn html and css (udacity). [X] middleman (ruby) for static page generation. [3/3] [X] HAML, partial and filters. [X] Bootrstrap inteegration [X] Use the following to deploy interactively with live-reload. bundle exec middleman [X] Write about codemirror and mathjax in codemirror","title":"Website [3/3]"},{"location":"cards/website/#recreate-online-cv-with-middleman-and-org-for-blog","text":"[X] Online cv done. [ ] Understand middleman gh-page for blog. [ ] Links org files. [ ] Publish summaries.","title":"Recreate online cv with middleman and org for blog"},{"location":"cards/website/#see-also-generated","text":"-","title":"See also (generated)"},{"location":"decks/","text":"See also (generated) See also (generated) \u00b6 -","title":"Index"},{"location":"decks/#see-also-generated","text":"-","title":"See also (generated)"},{"location":"decks/clojure/","text":"Clojure \u00b6 General \u00b6 [X] Check flycheck with clojure (if useful, use clj-kondo). Concepts \u00b6 [ ] specs: write about the principal functions. Test and use generative testing with specs. [ ] Create generators using asnyc and neanderthal. [ ] transducers: use them more extensively. [ ] core.async: find excuses to use them. [ ] Integrant [ ] aero/enviro [whatever works with cljs] [ ] Datomic [ ] Webworkers TODO Web Development with Clojure \u00b6 A handler is a function that receive a request map (and response callaback and raise callback) and returns a response map or calls the reponse callback on the response map. A middleware is a function that whose first argument is a handler and should return a handler. Clojurescript \u00b6 [X] https://github.com/bhauman/lein-figwheel [shadow-cljs is more useful] [ ] tools.deps, read more about arguments. [X] Understand how to wrap javascript code into Clojure. Use NPM. How to communicate between clojure and clojurescript (cljc) or sente. [ ] https://funcool.github.io/clojurescript-unraveled/ [ ] Make a summary of core.async chapter. Udemy [core.async] Elements of Clojure \u00b6 Naming \u00b6 There is a difference between the sign (the symbols or letters) and the referent (the thing/value to which the sign refers). Consistency is one of the feature that allow to grow. Precision is a trade-off with generality. synthetic allow precision, natural allows beginners to understand (trade off wit how much to learn before being productive). Idioms \u00b6 Indirection \u00b6 Indirection is the process of separating the how from the what . It useful when answering the question How does it work is answered best with it depends . Reference and conditionals are two tools to perform indirection. Getting the referent from a reference is called dereferencing . Reference are open, while conditional are closed (which could be a feature). Another difference is the order matters in conditional (like cond ). Dispatch happens in two context runtime ( dynamic ) and compile time ( static dispatching). Best to avoid hierarchies. Abstraction should be simplest model that satisfies the context requirements and self consistent. It depends on the context which sets the minimal set of constraints to pay attention to. As such it lives in a bubble/context. Hence, we should ask, what are the assumptions of the code? There are the two distinction for abstraction Principled vs Adaptable. Principled allows to create big architecture artifacts, but they are not adaptable (castle cards or sky scrapper, changing a room are hard). We should thrive for complex adaptable network, that is small components that are principled but in an adaptable network (pieces can be removed and substituted). How to gather code to create principled component? If code have the same set of assumption, then good place to gather them. Change is constant. Blogs \u00b6 Agile is an attitude - Russ Olsen Cognitect [2017] \u00b6 The Monkey wrench of agile is the following: To get the job done you need to focus on the goal and the people who will get you there. There is no magic recipe, no set of practices that will guarantee success You need to be ready to throw away the rule book and bob and weave and flex with whatever comes next. You need to improvise, adapt and overcome. Above all, agile means keeping your eye on the fundamentals: What are the goals? And how are we going to get there? You need to be ready to throw away the rule book and bob and weave and flex with whatever comes next. You need to improvise, adapt and overcome . Above all, agile means keeping your eye on the fundamentals: What are the goals? And how are we going to get there? . You need to improvise, adapt and overcome. What are the goals, and how are we going to get there? When agile processes make sense, use them. When they don\u2019t, let them go without regret. Iteration Zero - Naoko Higashide Cognitect [2017] \u00b6 The framework is about people first, conversations, realizations, and shared understanding. Bring people who will participate (not attend). First is to define responsibilities. will for . Finishing lines. The project will be complete when\u2026 Winning condition. Of the following choose three and describe: Schedule Scope Quality Budget Customer Satisfaction Teamwork / Learning Make sure that project\u2019s sponsor is aligned with those of the team. Talks \u00b6 Maybe not - Rich Hickey [2018] \u00b6 The talk is about clojure.spec and about the optionality in requirements. Static typing proponents will always talks about the benefits of types without ever mentioning the costs. In non breaking changes of API (requiring less, providing more), static typing will break APIs callers. Records in contrast to maps (open sets of keys and values) are PLOP. Because you need to place something in the slot where they contain data, and hence options. Clojure will always forbid to create brittle system with closed specifications. In Clojure, when an field of information (the value of a key in map) in unknown, the key is removed from the map (and avoid keys with nil value). Because if the value is nil , we don\u2019t know if we should be worried if the value is nil or if it is valid. In contrast, if the key is not in the map we can safely ignore it. Data aggregates are herd of information and is moving from one process to another. The solution is to define herd is to split the specifications into two: a schema describing the aggregate (and its tree) and a context whenever in function calls and returns. Specs Leverage/Testing/Custom Generators, Screencast- Stuart Halloway [2016] \u00b6 The advantage are validation, conformance, destructuring, error message, composition, example data generation, assertion, documentation, generative testing, instrumentation. It is about specs. Specs allows to define attributes, composites and function specs. A function specs takes three keys :args , :ret and :fn (which takes the specs as argument). The most interesting is the fn which is describe properties of the function returns. Specs allows to use regular expression on data structure for creating your specs. You can use s/exercise for generating sample of your spec and (test/check `my-fn) and test/summarize-result for checking your function specs. The function s/valid? and s/explain-data allows to validate and to get data for our mistakes. Whenever testing, you also can use test/instrument to instrument your function for better error message. s/alt for alternative, s/and for predicates aggregation, s/or for or predicate composition. Maybe s/& . The function gen/fmap takes a value from a generate and returns a value, while gen/let and gen/bind takes a generator and return a generator. Usually these are wrapped into functions and called with ( s/exercise ::s { ::s wrapper-around-fmap }) ;; or ( s/def ::s ( s/spec pred? :gen wrapper-around-fmap )) Usually, gen/let and gen/bind are used in conjunction with a model for representing the input data. The model acts as generator of test input, helping to conceptualize the expected inputs. For example ( def model ( s/cat :prefix string? :match string? :suffix string? )) when testing a index-of function for string. Write about s/fspec . The trick in using s/fspec is to provide reasonable generators. Using the gen/return allows to wrap a high order function as a generator . Read test.check.generator for more details . Design, Composition and Performance [2013] \u00b6 Design card. See also (generated) \u00b6 <../cards/20200430141226-life_in_dynamic_typing.md> <../cards/20200430141609-david_nolen.md> <../cards/20200430154352-cli_arguments.md> <../cards/20200430154528-multiple_environment.md> <../cards/20200430154647-shadow_cljs.md> <../cards/20200430155438-mastering_clojure_macro.md> <../cards/20200430155637-applied_clojure.md> <../cards/20200430155819-core_async.md> <../cards/20200430160432-clojure_for_the_brave_and_the_true.md> <../cards/20200430190921-design.md> <../cards/20200430235013-specs.md> <../cards/20200501201607-quotes.md> <../cards/20200502122138-simple_made_easy.md> <../cards/20200503222619-org_roam_clj.md> <../cards/20200504204808-why_clojure.md> <../cards/20200504212017-edn_and_transit.md> <../cards/20200505112138-clojure_reducers.md> <../cards/20200505113402-high_performance_clojurescript.md> <../cards/20200505124708-potemkin.md> <../cards/20200505124946-clj_toolkit.md> <../cards/20200517205339-clojure_zippers.md> <../cards/20200521232124-cljss.md> <../cards/20200524185034-clojure_functional_programming_principles.md> <../README.md>","title":"Clojure"},{"location":"decks/clojure/#clojure","text":"","title":"Clojure"},{"location":"decks/clojure/#general","text":"[X] Check flycheck with clojure (if useful, use clj-kondo).","title":"General"},{"location":"decks/clojure/#concepts","text":"[ ] specs: write about the principal functions. Test and use generative testing with specs. [ ] Create generators using asnyc and neanderthal. [ ] transducers: use them more extensively. [ ] core.async: find excuses to use them. [ ] Integrant [ ] aero/enviro [whatever works with cljs] [ ] Datomic [ ] Webworkers","title":"Concepts"},{"location":"decks/clojure/#todo-web-development-with-clojure","text":"A handler is a function that receive a request map (and response callaback and raise callback) and returns a response map or calls the reponse callback on the response map. A middleware is a function that whose first argument is a handler and should return a handler.","title":"TODO Web Development with Clojure"},{"location":"decks/clojure/#clojurescript","text":"[X] https://github.com/bhauman/lein-figwheel [shadow-cljs is more useful] [ ] tools.deps, read more about arguments. [X] Understand how to wrap javascript code into Clojure. Use NPM. How to communicate between clojure and clojurescript (cljc) or sente. [ ] https://funcool.github.io/clojurescript-unraveled/ [ ] Make a summary of core.async chapter. Udemy [core.async]","title":"Clojurescript"},{"location":"decks/clojure/#elements-of-clojure","text":"","title":"Elements of Clojure"},{"location":"decks/clojure/#naming","text":"There is a difference between the sign (the symbols or letters) and the referent (the thing/value to which the sign refers). Consistency is one of the feature that allow to grow. Precision is a trade-off with generality. synthetic allow precision, natural allows beginners to understand (trade off wit how much to learn before being productive).","title":"Naming"},{"location":"decks/clojure/#idioms","text":"","title":"Idioms"},{"location":"decks/clojure/#indirection","text":"Indirection is the process of separating the how from the what . It useful when answering the question How does it work is answered best with it depends . Reference and conditionals are two tools to perform indirection. Getting the referent from a reference is called dereferencing . Reference are open, while conditional are closed (which could be a feature). Another difference is the order matters in conditional (like cond ). Dispatch happens in two context runtime ( dynamic ) and compile time ( static dispatching). Best to avoid hierarchies. Abstraction should be simplest model that satisfies the context requirements and self consistent. It depends on the context which sets the minimal set of constraints to pay attention to. As such it lives in a bubble/context. Hence, we should ask, what are the assumptions of the code? There are the two distinction for abstraction Principled vs Adaptable. Principled allows to create big architecture artifacts, but they are not adaptable (castle cards or sky scrapper, changing a room are hard). We should thrive for complex adaptable network, that is small components that are principled but in an adaptable network (pieces can be removed and substituted). How to gather code to create principled component? If code have the same set of assumption, then good place to gather them. Change is constant.","title":"Indirection"},{"location":"decks/clojure/#blogs","text":"","title":"Blogs"},{"location":"decks/clojure/#agile-is-an-attitude-russ-olsen-cognitect-2017","text":"The Monkey wrench of agile is the following: To get the job done you need to focus on the goal and the people who will get you there. There is no magic recipe, no set of practices that will guarantee success You need to be ready to throw away the rule book and bob and weave and flex with whatever comes next. You need to improvise, adapt and overcome. Above all, agile means keeping your eye on the fundamentals: What are the goals? And how are we going to get there? You need to be ready to throw away the rule book and bob and weave and flex with whatever comes next. You need to improvise, adapt and overcome . Above all, agile means keeping your eye on the fundamentals: What are the goals? And how are we going to get there? . You need to improvise, adapt and overcome. What are the goals, and how are we going to get there? When agile processes make sense, use them. When they don\u2019t, let them go without regret.","title":"Agile is an attitude - Russ Olsen Cognitect [2017]"},{"location":"decks/clojure/#iteration-zero-naoko-higashide-cognitect-2017","text":"The framework is about people first, conversations, realizations, and shared understanding. Bring people who will participate (not attend). First is to define responsibilities. will for . Finishing lines. The project will be complete when\u2026 Winning condition. Of the following choose three and describe: Schedule Scope Quality Budget Customer Satisfaction Teamwork / Learning Make sure that project\u2019s sponsor is aligned with those of the team.","title":"Iteration Zero - Naoko Higashide Cognitect [2017]"},{"location":"decks/clojure/#talks","text":"","title":"Talks"},{"location":"decks/clojure/#maybe-not-rich-hickey-2018","text":"The talk is about clojure.spec and about the optionality in requirements. Static typing proponents will always talks about the benefits of types without ever mentioning the costs. In non breaking changes of API (requiring less, providing more), static typing will break APIs callers. Records in contrast to maps (open sets of keys and values) are PLOP. Because you need to place something in the slot where they contain data, and hence options. Clojure will always forbid to create brittle system with closed specifications. In Clojure, when an field of information (the value of a key in map) in unknown, the key is removed from the map (and avoid keys with nil value). Because if the value is nil , we don\u2019t know if we should be worried if the value is nil or if it is valid. In contrast, if the key is not in the map we can safely ignore it. Data aggregates are herd of information and is moving from one process to another. The solution is to define herd is to split the specifications into two: a schema describing the aggregate (and its tree) and a context whenever in function calls and returns.","title":"Maybe not - Rich Hickey [2018]"},{"location":"decks/clojure/#specs-leveragetestingcustom-generators-screencast-stuart-halloway-2016","text":"The advantage are validation, conformance, destructuring, error message, composition, example data generation, assertion, documentation, generative testing, instrumentation. It is about specs. Specs allows to define attributes, composites and function specs. A function specs takes three keys :args , :ret and :fn (which takes the specs as argument). The most interesting is the fn which is describe properties of the function returns. Specs allows to use regular expression on data structure for creating your specs. You can use s/exercise for generating sample of your spec and (test/check `my-fn) and test/summarize-result for checking your function specs. The function s/valid? and s/explain-data allows to validate and to get data for our mistakes. Whenever testing, you also can use test/instrument to instrument your function for better error message. s/alt for alternative, s/and for predicates aggregation, s/or for or predicate composition. Maybe s/& . The function gen/fmap takes a value from a generate and returns a value, while gen/let and gen/bind takes a generator and return a generator. Usually these are wrapped into functions and called with ( s/exercise ::s { ::s wrapper-around-fmap }) ;; or ( s/def ::s ( s/spec pred? :gen wrapper-around-fmap )) Usually, gen/let and gen/bind are used in conjunction with a model for representing the input data. The model acts as generator of test input, helping to conceptualize the expected inputs. For example ( def model ( s/cat :prefix string? :match string? :suffix string? )) when testing a index-of function for string. Write about s/fspec . The trick in using s/fspec is to provide reasonable generators. Using the gen/return allows to wrap a high order function as a generator . Read test.check.generator for more details .","title":"Specs Leverage/Testing/Custom Generators, Screencast- Stuart Halloway [2016]"},{"location":"decks/clojure/#design-composition-and-performance-2013","text":"Design card.","title":"Design, Composition and Performance [2013]"},{"location":"decks/clojure/#see-also-generated","text":"<../cards/20200430141226-life_in_dynamic_typing.md> <../cards/20200430141609-david_nolen.md> <../cards/20200430154352-cli_arguments.md> <../cards/20200430154528-multiple_environment.md> <../cards/20200430154647-shadow_cljs.md> <../cards/20200430155438-mastering_clojure_macro.md> <../cards/20200430155637-applied_clojure.md> <../cards/20200430155819-core_async.md> <../cards/20200430160432-clojure_for_the_brave_and_the_true.md> <../cards/20200430190921-design.md> <../cards/20200430235013-specs.md> <../cards/20200501201607-quotes.md> <../cards/20200502122138-simple_made_easy.md> <../cards/20200503222619-org_roam_clj.md> <../cards/20200504204808-why_clojure.md> <../cards/20200504212017-edn_and_transit.md> <../cards/20200505112138-clojure_reducers.md> <../cards/20200505113402-high_performance_clojurescript.md> <../cards/20200505124708-potemkin.md> <../cards/20200505124946-clj_toolkit.md> <../cards/20200517205339-clojure_zippers.md> <../cards/20200521232124-cljss.md> <../cards/20200524185034-clojure_functional_programming_principles.md> <../README.md>","title":"See also (generated)"}]}