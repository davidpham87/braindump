{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Why? \u00b6 Using org-roam , mkdocs-material , I can generate a website to search for my idea, using the zettelkasten methods. Org mode is great for authoring, but I do prefer some nice font and a good navigation, search navigation. mkdocs-material offered a great compromise and orgmk allowed me to have a command line conversion. Clojure allowed to handle all the files systems, interaction with the sqlite database, the parsing and the concurrency. I came up with my own set up, cards for writing anything that goes into my minds, links them and decks for writing summaries. Blog posts are a place where I can write some ideas and opinions to share them. Technical challenge \u00b6 I created some functions to leverage the org-roam.db sqlite data base. With my own starting template, the code reads the tags and the links, such that automatic see also are created at the end of each page. See org-roam-clj on how to use the library. Small index for quick accessa \u00b6 Programming \u00b6 clj , core.async , See also (generated) \u00b6 First blog ticket org mode Readings","title":"Why?"},{"location":"#why","text":"Using org-roam , mkdocs-material , I can generate a website to search for my idea, using the zettelkasten methods. Org mode is great for authoring, but I do prefer some nice font and a good navigation, search navigation. mkdocs-material offered a great compromise and orgmk allowed me to have a command line conversion. Clojure allowed to handle all the files systems, interaction with the sqlite database, the parsing and the concurrency. I came up with my own set up, cards for writing anything that goes into my minds, links them and decks for writing summaries. Blog posts are a place where I can write some ideas and opinions to share them.","title":"Why?"},{"location":"#technical-challenge","text":"I created some functions to leverage the org-roam.db sqlite data base. With my own starting template, the code reads the tags and the links, such that automatic see also are created at the end of each page. See org-roam-clj on how to use the library.","title":"Technical challenge"},{"location":"#small-index-for-quick-accessa","text":"","title":"Small index for quick accessa"},{"location":"#programming","text":"clj , core.async ,","title":"Programming"},{"location":"#see-also-generated","text":"First blog ticket org mode Readings","title":"See also (generated)"},{"location":"todo/","text":"TOOD List \u00b6 This Todo file is a simple example of what I still have to learn or do. These are the goals I would like to reach or interest me. Highly important \u00b6 Goals \u00b6 specs, core async, datomic, testing. Webworkers and websockets. GPU computing GraphQL Spark Kafka Kubernetes, container technology. Learn about databases (postgres, elastic search and datomic). TODO Read Advanced Data Analysis from an elementary point of view \u00b6 Advanced data analysis from an elementary point of view Multipass and Ansible \u00b6 Use multipass and Ansible to simulate networks and kubernetes Learn CSS \u00b6 Write a summary (check create of Bulma) garden-cljs. Leverage indices and org-parser \u00b6 Check whether we can use indices to create better indexing. Idea \u00b6 Download clojure.core and use materiala. See also (generated) \u00b6 Applied Clojure Clojure for the brave and the true core.async Goals specs","title":"TOOD List"},{"location":"todo/#tood-list","text":"This Todo file is a simple example of what I still have to learn or do. These are the goals I would like to reach or interest me.","title":"TOOD List"},{"location":"todo/#highly-important","text":"","title":"Highly important"},{"location":"todo/#goals","text":"specs, core async, datomic, testing. Webworkers and websockets. GPU computing GraphQL Spark Kafka Kubernetes, container technology. Learn about databases (postgres, elastic search and datomic).","title":"Goals"},{"location":"todo/#todo-read-advanced-data-analysis-from-an-elementary-point-of-view","text":"Advanced data analysis from an elementary point of view","title":"TODO Read Advanced Data Analysis from an elementary point of view"},{"location":"todo/#multipass-and-ansible","text":"Use multipass and Ansible to simulate networks and kubernetes","title":"Multipass and Ansible"},{"location":"todo/#learn-css","text":"Write a summary (check create of Bulma) garden-cljs.","title":"Learn CSS"},{"location":"todo/#leverage-indices-and-org-parser","text":"Check whether we can use indices to create better indexing.","title":"Leverage indices and org-parser"},{"location":"todo/#idea","text":"Download clojure.core and use materiala.","title":"Idea"},{"location":"todo/#see-also-generated","text":"Applied Clojure Clojure for the brave and the true core.async Goals specs","title":"See also (generated)"},{"location":"blog/20200502171331-first_blog_ticket/","text":"First blog ticket \u00b6 Voil\u00e0! The start of a new blog! Probably like all blogs, this one will remain probably empty, without a lot of content. I just created this website to gather my notes and find a system that can make leverage of all the ideas. I think the zettelkasten method is interesting and I decided to try it. Please read the README for more details! See also (generated) \u00b6 Home for ideas for my Zettelkasten","title":"First blog ticket"},{"location":"blog/20200502171331-first_blog_ticket/#first-blog-ticket","text":"Voil\u00e0! The start of a new blog! Probably like all blogs, this one will remain probably empty, without a lot of content. I just created this website to gather my notes and find a system that can make leverage of all the ideas. I think the zettelkasten method is interesting and I decided to try it. Please read the README for more details!","title":"First blog ticket"},{"location":"blog/20200502171331-first_blog_ticket/#see-also-generated","text":"Home for ideas for my Zettelkasten","title":"See also (generated)"},{"location":"cards/20200430141226-life_in_dynamic_typing/","text":"Life In Dynamic Typing \u00b6 tags: Clojure In dynamic typed language, assertions are used often to check assumption of your input data. In Clojure the :pre and :post conditions can be used effectively to fill this purpose. ( defn f [ x ] { :pre [( integer? x )] :post string? } ( str x )) {:elide-asserts true} in production build compiler options to remove :pre and :post assertions in your code. See also (generated) \u00b6 Applied Clojure Clojure Clojure for the brave and the true David Nolen Mastering Clojure Macro specs","title":"Life In Dynamic Typing"},{"location":"cards/20200430141226-life_in_dynamic_typing/#life-in-dynamic-typing","text":"tags: Clojure In dynamic typed language, assertions are used often to check assumption of your input data. In Clojure the :pre and :post conditions can be used effectively to fill this purpose. ( defn f [ x ] { :pre [( integer? x )] :post string? } ( str x )) {:elide-asserts true} in production build compiler options to remove :pre and :post assertions in your code.","title":"Life In Dynamic Typing"},{"location":"cards/20200430141226-life_in_dynamic_typing/#see-also-generated","text":"Applied Clojure Clojure Clojure for the brave and the true David Nolen Mastering Clojure Macro specs","title":"See also (generated)"},{"location":"cards/20200430141609-david_nolen/","text":"David Nolen \u00b6 tags: Clojure ClojureScript (cljs) lead developer See also (generated) \u00b6 Applied Clojure Clojure Clojure for the brave and the true Life In Dynamic Typing Mastering Clojure Macro shadow-cljs","title":"David Nolen"},{"location":"cards/20200430141609-david_nolen/#david-nolen","text":"tags: Clojure ClojureScript (cljs) lead developer","title":"David Nolen"},{"location":"cards/20200430141609-david_nolen/#see-also-generated","text":"Applied Clojure Clojure Clojure for the brave and the true Life In Dynamic Typing Mastering Clojure Macro shadow-cljs","title":"See also (generated)"},{"location":"cards/20200430153912-ethz/","text":"ETHZ \u00b6 tags: studies statistics ethz Lectures \u00b6 DONE Projects [3/3] \u00b6 [X] Semester paper in economics : Public Employment [X] Write e-mail. [X] Decide subject and write about it. [X] Read papers [X] Do the regression [X] Semester paper in statistics: Missing data [X] Read introduction missing data. [X] Play with mi. [X] Use Digital Ocean API in R. [X] Master thesis [X] Webapp to teach math in clojure and middleman yaml DONE Causality [2/2] \u00b6 I had 5.75 (kind of deserved). PDAG: Partially means no directed cycle whereas DAG means no cycle at all. CPDAG (Markov Equivalent Graphs): for every directed node, all graph have the same edge. For undirected edges, there exist at least two graphs with opposite direction of the edge. Markov equivalent if they have the same skeleton and immoralities (v-struct). D-separation \\to \\to Blocked Reverse engineer the definition by thinking about the independence Markov blanket M M : for a target node Y Y , it is smallest set M M of nodes in the graphs that make Y Y independent of all the other nodes given M M . In DAG: for X X it contains its parents, its children and the parents of children. Causal minimality: P^X P^X is not markov to any proper subgraph of \\mathcal{G} \\mathcal{G} if and only if there are no useless edge. Markov: conditional d-sep \\Rightarrow \\Rightarrow independence, faithfulness is the converse. Local: X X is independent of any non descendent given its parnets. Adjustment formula (tautology): the conditional probability given the parents remains the same under the interventions. The goal adjustment set: evaluate interventions or causality with observational data. Valid adjustment set Z Z : p_{\\mathcal{S}, do(X=x)}(y) = \\sum_{z \\in Z} p_{\\mathcal{S}}(y \\vert X=x, z) p(z) p_{\\mathcal{S}, do(X=x)}(y) = \\sum_{z \\in Z} p_{\\mathcal{S}}(y \\vert X=x, z) p(z) for y y not in the parent of x x and x, y \\notin Z x, y \\notin Z . Backdoor criterion: S S blocks all paths from X X to Y Y that come \\emph{into} X X (backward path) and S S contains no descendant of X X . DONE QRM [3/3] \u00b6 <2015-08-18 Tue> Know the main theorems by heart: Fisher-Tippet, Pickands-Balkema-de Hann, Sklar. 5.5/6 [X] Read slides [X] Learn slides by heart [X] Do past exams DONE Multivariate Statistics [2/2] \u00b6 I had 4.5/6 (which was not deserved at all). [X] Do exercises [X] Serie 1 [X] Serie 2 [X] Serie 3 [X] Serie 4 [X] Serie 5 [X] Read scripts DONE Computational Statistics, finish the series [2/2] \u00b6 <2015-08-18 Tue> I got 6 (was a little bit easy, thanks to emacs and R-help). [X] Do Series [X] Read script DONE Economics Cycle [2/2] \u00b6 <2015-06-09 Tue> I had 4.75/6 at the exam. [X] Read scripts [X] Do Exercise See also (generated) \u00b6 Python R CRAN","title":"ETHZ"},{"location":"cards/20200430153912-ethz/#ethz","text":"tags: studies statistics ethz","title":"ETHZ"},{"location":"cards/20200430153912-ethz/#lectures","text":"","title":"Lectures"},{"location":"cards/20200430153912-ethz/#done-projects-33","text":"[X] Semester paper in economics : Public Employment [X] Write e-mail. [X] Decide subject and write about it. [X] Read papers [X] Do the regression [X] Semester paper in statistics: Missing data [X] Read introduction missing data. [X] Play with mi. [X] Use Digital Ocean API in R. [X] Master thesis [X] Webapp to teach math in clojure and middleman yaml","title":"DONE Projects [3/3]"},{"location":"cards/20200430153912-ethz/#done-causality-22","text":"I had 5.75 (kind of deserved). PDAG: Partially means no directed cycle whereas DAG means no cycle at all. CPDAG (Markov Equivalent Graphs): for every directed node, all graph have the same edge. For undirected edges, there exist at least two graphs with opposite direction of the edge. Markov equivalent if they have the same skeleton and immoralities (v-struct). D-separation \\to \\to Blocked Reverse engineer the definition by thinking about the independence Markov blanket M M : for a target node Y Y , it is smallest set M M of nodes in the graphs that make Y Y independent of all the other nodes given M M . In DAG: for X X it contains its parents, its children and the parents of children. Causal minimality: P^X P^X is not markov to any proper subgraph of \\mathcal{G} \\mathcal{G} if and only if there are no useless edge. Markov: conditional d-sep \\Rightarrow \\Rightarrow independence, faithfulness is the converse. Local: X X is independent of any non descendent given its parnets. Adjustment formula (tautology): the conditional probability given the parents remains the same under the interventions. The goal adjustment set: evaluate interventions or causality with observational data. Valid adjustment set Z Z : p_{\\mathcal{S}, do(X=x)}(y) = \\sum_{z \\in Z} p_{\\mathcal{S}}(y \\vert X=x, z) p(z) p_{\\mathcal{S}, do(X=x)}(y) = \\sum_{z \\in Z} p_{\\mathcal{S}}(y \\vert X=x, z) p(z) for y y not in the parent of x x and x, y \\notin Z x, y \\notin Z . Backdoor criterion: S S blocks all paths from X X to Y Y that come \\emph{into} X X (backward path) and S S contains no descendant of X X .","title":"DONE Causality [2/2]"},{"location":"cards/20200430153912-ethz/#done-qrm-33","text":"<2015-08-18 Tue> Know the main theorems by heart: Fisher-Tippet, Pickands-Balkema-de Hann, Sklar. 5.5/6 [X] Read slides [X] Learn slides by heart [X] Do past exams","title":"DONE QRM [3/3]"},{"location":"cards/20200430153912-ethz/#done-multivariate-statistics-22","text":"I had 4.5/6 (which was not deserved at all). [X] Do exercises [X] Serie 1 [X] Serie 2 [X] Serie 3 [X] Serie 4 [X] Serie 5 [X] Read scripts","title":"DONE Multivariate Statistics [2/2]"},{"location":"cards/20200430153912-ethz/#done-computational-statistics-finish-the-series-22","text":"<2015-08-18 Tue> I got 6 (was a little bit easy, thanks to emacs and R-help). [X] Do Series [X] Read script","title":"DONE Computational Statistics, finish the series [2/2]"},{"location":"cards/20200430153912-ethz/#done-economics-cycle-22","text":"<2015-06-09 Tue> I had 4.75/6 at the exam. [X] Read scripts [X] Do Exercise","title":"DONE Economics Cycle [2/2]"},{"location":"cards/20200430153912-ethz/#see-also-generated","text":"Python R CRAN","title":"See also (generated)"},{"location":"cards/20200430154352-cli_arguments/","text":"CLI Arguments \u00b6 Check how to use cli arguments for release scripts. ( require ' [ clojure.tools.cli :refer [ parse-opts ]]) ( def cli-options ;; An option with a required argument [[ \"-p\" \"--port PORT\" \"Port number\" :default 80 :parse-fn # ( Integer/parseInt % ) :validate [ # ( < 0 % 0 x10000 ) \"Must be a number between 0 and 65536\" ]] [ \"-h\" \"--help\" ]]) ( :options ( parse-opts *command-line-args* cli-options )) See also (generated) \u00b6 Applied Clojure Clojure Clojure for the brave and the true Mastering Clojure Macro Materiala Multiple Environment","title":"CLI Arguments"},{"location":"cards/20200430154352-cli_arguments/#cli-arguments","text":"Check how to use cli arguments for release scripts. ( require ' [ clojure.tools.cli :refer [ parse-opts ]]) ( def cli-options ;; An option with a required argument [[ \"-p\" \"--port PORT\" \"Port number\" :default 80 :parse-fn # ( Integer/parseInt % ) :validate [ # ( < 0 % 0 x10000 ) \"Must be a number between 0 and 65536\" ]] [ \"-h\" \"--help\" ]]) ( :options ( parse-opts *command-line-args* cli-options ))","title":"CLI Arguments"},{"location":"cards/20200430154352-cli_arguments/#see-also-generated","text":"Applied Clojure Clojure Clojure for the brave and the true Mastering Clojure Macro Materiala Multiple Environment","title":"See also (generated)"},{"location":"cards/20200430154528-multiple_environment/","text":"Multiple environments \u00b6 We can have different class paths for configuration with clj and alias in deps.edn to manage them. Proxies: you add in ~.shadow-cljs/config.edn or in the config file { :maven { :proxy { :host \"proxy.host.com\" :port 8080 }}} tags: clj build See also (generated) \u00b6 Applied Clojure CLI Arguments Clojure Clojure for the brave and the true General Skills Mastering Clojure Macro Materiala","title":"Multiple environments"},{"location":"cards/20200430154528-multiple_environment/#multiple-environments","text":"We can have different class paths for configuration with clj and alias in deps.edn to manage them. Proxies: you add in ~.shadow-cljs/config.edn or in the config file { :maven { :proxy { :host \"proxy.host.com\" :port 8080 }}} tags: clj build","title":"Multiple environments"},{"location":"cards/20200430154528-multiple_environment/#see-also-generated","text":"Applied Clojure CLI Arguments Clojure Clojure for the brave and the true General Skills Mastering Clojure Macro Materiala","title":"See also (generated)"},{"location":"cards/20200430154647-shadow_cljs/","text":"shadow-cljs \u00b6 NGINX Configuration for developping locally \u00b6 server { listen 80 default_server; listen [::]:80 default_server; root /var/www/html; server_name _; location / { proxy_pass http://localhost:8080/; try_files $uri $uri/a 404; } location /shadow-cljs/ { # upgrade to websocket proxy_pass http://localhost:9630/; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"Upgrade\"; proxy_set_header Host $host; } } Links \u00b6 shadow-cljs cljs See also (generated) \u00b6 Clojure David Nolen","title":"shadow-cljs"},{"location":"cards/20200430154647-shadow_cljs/#shadow-cljs","text":"","title":"shadow-cljs"},{"location":"cards/20200430154647-shadow_cljs/#nginx-configuration-for-developping-locally","text":"server { listen 80 default_server; listen [::]:80 default_server; root /var/www/html; server_name _; location / { proxy_pass http://localhost:8080/; try_files $uri $uri/a 404; } location /shadow-cljs/ { # upgrade to websocket proxy_pass http://localhost:9630/; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"Upgrade\"; proxy_set_header Host $host; } }","title":"NGINX Configuration for developping locally"},{"location":"cards/20200430154647-shadow_cljs/#links","text":"shadow-cljs cljs","title":"Links"},{"location":"cards/20200430154647-shadow_cljs/#see-also-generated","text":"Clojure David Nolen","title":"See also (generated)"},{"location":"cards/20200430155438-mastering_clojure_macro/","text":"Mastering Clojure Macro \u00b6 Macro is about manipulating the arguments of your functions before they get evaluated. We should think about templating when thinking about macros. The macro returns a S-Expression which should be valid Clojure code. Use ` for namespace quoting everything after the backquote (usually a list). Unquote is done through ~ . Unquote splicing ~@ allows to remove the parenthesis in a list and put them at the same level as the parent S-Expression. For example the following `(1 2 ~@(3 4) 5)` returns (1 2 3 4 5) . Whenever we need to bind a symbol in a macro (e.g fn and let ), the argument should be gensym, or symbol appended of a # , e.g x# . &form [the calling expression] and &env [the binding environment] are special values only available in macros. Disadvantage with macros. Macros are not values (as they are not functions). So we can\u2019t use map or any other function on them. Macros can be contagious as they can leak force your user to also write macros to use your library. They can be tough to get right (mainly because of side effect and computation time). We should avoid doing a mess in our user namespace whenever writing macros. Macros are useful to evaluate code in Context. When using dynamic binding, ( declare ^ :dynamic *radius* ) ( defn circle-area [] ( * Math/PI ( * *radius* *radius* ))) ( binding [ *radius* 10 ] ( circle-area )) it can be useful to abstract the binding step with a macro. Most common bindings are for *out* . In general, we should have the core of the manipulation of a macro written in a function, and have the smallest possible amount of lines of code into a the macro. ( defn with-out-file-fn [ file body-fn ] ( with-open [ writer ( clojure.java.io/writer file :append true )] ( binding [ *out* writer ] ( body-fn )))) ( defn with-out-file [ file & body ] ` ( with-out-file-fn ~ file ( fn [] ~@ body ))) Macro can also decide how we evaluate (or not) the input, e.g. comment . A cool trick for a function that should be executed only once ( let [ x :a f ( ^ :once fn* [] ( println x ))] ( f ) ;; prints :a ( f )) ;; prints nil Macros can also rescuing errors and clean up resources. The main point is macros allow to eliminate noisy details of cleaning up an open resource, rescuing errors, or setting up dynamic bindings or other context for evaluation. It allows to abstract away the contextual details and core operations can be clarified to make the purpose of the code more obvious. - Optimization. Before optimizing, we should know how to benchmark. criterium.core is a nice solution for that. Macros can let write type hinting without the users being noticed and as the computation is done at compile time, they allow optimization of operations or functions which does not depend on user input. - Macro can build apis that say what they mean. It allows to avoid unnecessary intermediary steps for the users to know, especially ones that require forms that are not essentials to the API. For example, building resources or calling functions. In this case, we should try to have as much operations in functions, to avoid bugs but also to offer the choice to the user to call functions (which are values) or macros. - As macro execute the logic of its body before executing its arguments, we can bend the control flow of our code. The lowest level of looping in Clojure is the loop/recur construction and most control flow in Clojure are derived from this. This is a special case of creating languages features. Links \u00b6 Mastering Clojure Macros tags: clj See also (generated) \u00b6 Applied Clojure CLI Arguments Clojure Clojure for the brave and the true core.async David Nolen edn and transit Life In Dynamic Typing Multiple Environment Org-roam-clj: Org-roam extension with Clojure Simple Made Easy specs Why Clojure?","title":"Mastering Clojure Macro"},{"location":"cards/20200430155438-mastering_clojure_macro/#mastering-clojure-macro","text":"Macro is about manipulating the arguments of your functions before they get evaluated. We should think about templating when thinking about macros. The macro returns a S-Expression which should be valid Clojure code. Use ` for namespace quoting everything after the backquote (usually a list). Unquote is done through ~ . Unquote splicing ~@ allows to remove the parenthesis in a list and put them at the same level as the parent S-Expression. For example the following `(1 2 ~@(3 4) 5)` returns (1 2 3 4 5) . Whenever we need to bind a symbol in a macro (e.g fn and let ), the argument should be gensym, or symbol appended of a # , e.g x# . &form [the calling expression] and &env [the binding environment] are special values only available in macros. Disadvantage with macros. Macros are not values (as they are not functions). So we can\u2019t use map or any other function on them. Macros can be contagious as they can leak force your user to also write macros to use your library. They can be tough to get right (mainly because of side effect and computation time). We should avoid doing a mess in our user namespace whenever writing macros. Macros are useful to evaluate code in Context. When using dynamic binding, ( declare ^ :dynamic *radius* ) ( defn circle-area [] ( * Math/PI ( * *radius* *radius* ))) ( binding [ *radius* 10 ] ( circle-area )) it can be useful to abstract the binding step with a macro. Most common bindings are for *out* . In general, we should have the core of the manipulation of a macro written in a function, and have the smallest possible amount of lines of code into a the macro. ( defn with-out-file-fn [ file body-fn ] ( with-open [ writer ( clojure.java.io/writer file :append true )] ( binding [ *out* writer ] ( body-fn )))) ( defn with-out-file [ file & body ] ` ( with-out-file-fn ~ file ( fn [] ~@ body ))) Macro can also decide how we evaluate (or not) the input, e.g. comment . A cool trick for a function that should be executed only once ( let [ x :a f ( ^ :once fn* [] ( println x ))] ( f ) ;; prints :a ( f )) ;; prints nil Macros can also rescuing errors and clean up resources. The main point is macros allow to eliminate noisy details of cleaning up an open resource, rescuing errors, or setting up dynamic bindings or other context for evaluation. It allows to abstract away the contextual details and core operations can be clarified to make the purpose of the code more obvious. - Optimization. Before optimizing, we should know how to benchmark. criterium.core is a nice solution for that. Macros can let write type hinting without the users being noticed and as the computation is done at compile time, they allow optimization of operations or functions which does not depend on user input. - Macro can build apis that say what they mean. It allows to avoid unnecessary intermediary steps for the users to know, especially ones that require forms that are not essentials to the API. For example, building resources or calling functions. In this case, we should try to have as much operations in functions, to avoid bugs but also to offer the choice to the user to call functions (which are values) or macros. - As macro execute the logic of its body before executing its arguments, we can bend the control flow of our code. The lowest level of looping in Clojure is the loop/recur construction and most control flow in Clojure are derived from this. This is a special case of creating languages features.","title":"Mastering Clojure Macro"},{"location":"cards/20200430155438-mastering_clojure_macro/#links","text":"Mastering Clojure Macros tags: clj","title":"Links"},{"location":"cards/20200430155438-mastering_clojure_macro/#see-also-generated","text":"Applied Clojure CLI Arguments Clojure Clojure for the brave and the true core.async David Nolen edn and transit Life In Dynamic Typing Multiple Environment Org-roam-clj: Org-roam extension with Clojure Simple Made Easy specs Why Clojure?","title":"See also (generated)"},{"location":"cards/20200430155637-applied_clojure/","text":"Applied Clojure \u00b6 Collections \u00b6 List (adddition at the head), vectors (addition at the end) and queues (FIFO). ( def new-orders clojure.lang.PersistentQueue/EMPTY ) Use transient and persistent! if the transformation is local. The library medley from weavejester incorporate useful functions. Collection accessing: use keyword first (:key m) , or (m :key) if it is certain that m is a map, otherwise if both might be null use (get m k) . If possible avoid having a stack of left parentheses such as ((f) x) . Abuse of select-keys to subset a map. If performance is required, we can create custom collection by defining a type and implementing the protocol, a custom printing is possible. Use records and maps to describe your entities. Maps should be the default choice, unless you decide to use protocols and need performance for dispatch. Protocols and multimethods are the two ways for dispatching. Protocols are faster in Clojure, but multimethods are more flexible. Processing Sequential Data. \u00b6 We can use map , filter , reduce to process sequence of values, but it might not be efficient. Transducers are created to avoid the concretion of the data structure. A transducer (usually denoted by xf or xform ) is a function that transform a reducing function into an another reducing function. That is xf: f -> g where f and g have signature whatever, input -> whatever . Concrete example of reducing function are conj with whatever being a list, + (with whatever being a number, and input a number). See here for more details. The trick is you can define map, filter and other operations as reducing function (reducing function are used in reduce operations usually). It is important to note that reducing function can actually grow the whatever (see conj ). We create them by omitting the coll argument in the typical sequence functions, e.g. (map f) yields a transducer. Use the sequence function to realize the transducer. The following calls are equal ( = ( map # ( * 2 % ) ( range 10 )) ( sequence ( map # ( * 2 % )) ( range 10 ))) If we need eagerness we could use into ( into [] ( map # ( * 2 % )) ( range 10 )) The benefit of transducer is intermediate values are not allocated and there is a decoupling of the transformations with the reducer (reducing function and reducible collection). They are also polymorphic. We can compose transducers and reduction with transduce ( def moons-transform ( comp ( filter planet? ) ( map :moons ))) ( defn total-moons [ entities ] ( transduce moons-transform + 0 entities )) See understanding transducers for more details. Duplicate removal with distinct and dedupe (only remove subsequent duplicate and safer for large input). Use mapcat instead of (-> map flatten) . Reference, State and Mutation \u00b6 Identity and state are two distinct notions. An identity is a sequence of immutable values, and the state is the actual value of an identity at a certain point of time. The challenge is to always display a single valid value to all the observer at the same time. There are two types of successions (mutation): atomic and transactions. An atomic transaction only cares about the change happening to the identity itself and not about the coordination of other identity. Transactional ensure that either all changes or none are performed. There are two states: program and runtime states. Program state is concerned with mutation in the problem domain, whereas runtime facilitate the software\u2019s execution (e.g. connections to databases or network, config files). Runtime state is often unavoidable whereas program state should be minimized and access through API with curated methods rather than directly. For managing change, we should build just enough to ensure the application\u2019s needs are met. Every side effect and mutable reference slows you down. We should be responsible over our functions (make them pure) and make choices about what need to be managed. State is a series of snapshots of values (data) which allows to act responsibly when considering the presence of observers in other processes. In Clojure, observers have consistent set of values as of a particular instant thanks to Clojure\u2019s mutable references. Use your cores \u00b6 One of the problem is to send task of the main thread to be completed asynchronously and retrieve the result ( future and promise ). Tasks and workers for long lived task-oriented concurrency. We can also use reducers and core.async (with channels and go blocks ). For agents, use send for computational tasks and won\u2019t block for I/O and send-off for updates that might block for an arbitrary time (thread pool will grow accordingly). The advantage is agent can maintain state compared to future . Use deref or @ for retrieving back the value of a future or promise . Promise are used to returns several values from a future block. Use realized? to check if a promise is available, otherwise it will block. The deref function with an additional argument can force timeout. Use Java queues and workers for task oriented programs. This is for coarse grained task parallelism. Queues , threads and executors are the tools from Java to perform a queue of incoming work or requests. For fine-grained parallelism The pmap function can be used for easy parallelism, but the overhead might be consequential. The clojure.core.reducer library is the solution for parallelism [fine-grained operations and memory efficient]. A reducer is reducible collection combined with a reducing function . fold is used to perform the reduction [only vectors and maps can be folded in parallel, but the serial version can be faster thanks to avoiding intermediary values]. A reducer splits the data into partition, reduce the elements and then combine them. The reduce and the combine functions can hence be different. Concurrency (design the program as a set of concurrent threads of execution) we can use core.async . Channels come in unbuffered, fixed buffered, dropping (discard new data) and sliding buffer (discard old data). Creating a channel is done with chan the function. nil can not be passed into channels (as it is the value for saying the channel is closed). The important operations are put and take . A full channel (once the buffer is complete) blocks a thread if no process other process is the other end of the channel to take the value sent by put . Backpressure is the efffect that fixed sized buffers creates by making the producers block when trying to add to a full queue. Traditionally channels are used in go block . In the Communicating Sequential Processes (CSP), process belongs to a thread pool and are parked when not blocked by a channel operation ( >! or <! ). Go blocks are great for building pipelines of data transformation. core.async/pipelines gives up the raw performance of fine-grained data parallelism but yield a more flexible architecture. The function moves the value from input to output channel with parallel transducer execution. Next step is to break a growing system into pieces using concurrency. Designing components \u00b6 Use of channels, better to receive and provide channels for interface. In core.async , a single go block is to call the body of the go block once asynchronously, while go-loop is intended for looping, unless we close the channel. go blocks return a channel, which can be used for pedestal. A good design is to split an API layer and implementation layer with a record. As for core.async , there are three additional concept for channels that are useful: pipeline, fan-in and fan-out. In a system, pipelines link an output channel to an input channel (acting like as a conveyor belt) and can possibly transform its input values with a transducer (async, sync, blocking). The pipe function should be used when no transformation. Fan-in channels gather the input of several channels and provide a single output channel. merge is a simple way to merge all the incoming channels into a single output channels, but it can\u2019t be modified after creation. The mix (for audio mix) function with its functions admix/unmix allows channel to participate in the mix. Users can toggle options for each input channel: :pause (no consumption nor inclusion in output channel), :mute (consumption but no inclusion), :solo ( if true, only solo-ed channels in output channel mix, :pause and :mute ignored if this is the case). Fan-out have three ways: mult , pub/sub , split . The mult abstraction is multiply traffic from the input channel into multiple output channels. Output channels (with different blocking policy) can participate in the connection with tap/untap (if a tap is closed, it is removed from the mult ). All the receiving channels must accept a value from the mult before the mult can move on to the next value. This is where alternative buffering strategy are useful. The pub/sub allows to distribute the traffic through a partition function and subscribers can inform to which partition value they want to lisen to. split divides the traffic two channels based on a truthiness of a predicate. split is actually a pub/sub with a partition function providing only truthy/falsy . Compose Your Application \u00b6 Taking things apart: usualy some portion of the code will work on the same data, or have the data has a common scope or lifetime, likelihehood of change from external requirement is similar are resource needed. If code is reusable when configured differently in more than one context, then it is a component. Component should communicate with channels, but in order to set up the system correctly, we need something to orchestrate it. Several library exist, the book recommends Component , but it has been super-seeded by integrant . An example can be found here reitit/integrant . Environment variable also should exist with different settings. The solution in the book are a bit old. Environ still seems to be good on clojure (jvm). Testing \u00b6 There are three ways to create tests in clojure: repl, example based, generative testing (properties check). With REPL driven development, the example used for development are stored in a file (these are candidates for examples). For example based, there is the expectations library and the following snippets ( deftest test-range-are ( testing \"Testing range(endIndex)\" ( are [ expected endIndexf ( = expected ( range endIndex )) ' ( 0 1 2 3 4 ) 5 ' () 0 ]))) Generative testing using ( ns generative-testing.core ( :require [ clojure.test.check :as tc ] [ clojure.test.check.generators :as gen ] [ clojure.test.check.properties :as prop ])) I think nowadays we would use spec for it. We are looking for invariants \u2013 properties that are always true. [\u2026] mathematical laws, relationships between inputs and outputs, round-trip or complementing functions, and comparing action effects. Properties like identity, associativity, commutativity and idempotency are an excellent place to start. Invariants are important because they reduce the number of case your code must consider. Thinking in Clojure \u00b6 Make Reasoned Choices: always compare trade-off of solutions (benefits and costs). Think first, then do . Careful treatment of decisions and weighed trade-off to fully understand the consequences. Be Reasonable: code with clearly expressed intent, limited side effects, neatly separated concerns, and unambiguous naming. Simple. Keep It Simple: Keep distinct concern as distinct as possible and avoid entangling concepts with other concepts. The code can be reasoned about, test and implemented without any incidental complexity. Entities are simplest when distinct and composable. Domain functions avoid complexity by avoiding side effects and concerning themselves only with entities in their domain. Build Just Enough: Keep complexity at bay and avoid overengineering. Compose: compose component, and evaluate your code composability by using it from another component. Results will be a set of tidy interfaces to distinct independent subsystems with clear communication channels. With a stable interface, a component can grow easily and adapt quickly. Be Precise: avoid ambiguity and communicate clearly with others and your future self. Entities typify one concept. Functions effect a single transformation. Queries ask simple questions and return unambiguous results. Use What Works: look for working libraries, solution in other languages or papers. Link \u00b6 Clojure Applied tags: clj core-async design See also (generated) \u00b6 CLI Arguments Clojure Clojure for the brave and the true core.async David Nolen Design edn and transit Life In Dynamic Typing Mastering Clojure Macro Multiple Environment Org-roam-clj: Org-roam extension with Clojure Simple Made Easy specs TODO Why Clojure?","title":"Applied Clojure"},{"location":"cards/20200430155637-applied_clojure/#applied-clojure","text":"","title":"Applied Clojure"},{"location":"cards/20200430155637-applied_clojure/#collections","text":"List (adddition at the head), vectors (addition at the end) and queues (FIFO). ( def new-orders clojure.lang.PersistentQueue/EMPTY ) Use transient and persistent! if the transformation is local. The library medley from weavejester incorporate useful functions. Collection accessing: use keyword first (:key m) , or (m :key) if it is certain that m is a map, otherwise if both might be null use (get m k) . If possible avoid having a stack of left parentheses such as ((f) x) . Abuse of select-keys to subset a map. If performance is required, we can create custom collection by defining a type and implementing the protocol, a custom printing is possible. Use records and maps to describe your entities. Maps should be the default choice, unless you decide to use protocols and need performance for dispatch. Protocols and multimethods are the two ways for dispatching. Protocols are faster in Clojure, but multimethods are more flexible.","title":"Collections"},{"location":"cards/20200430155637-applied_clojure/#processing-sequential-data","text":"We can use map , filter , reduce to process sequence of values, but it might not be efficient. Transducers are created to avoid the concretion of the data structure. A transducer (usually denoted by xf or xform ) is a function that transform a reducing function into an another reducing function. That is xf: f -> g where f and g have signature whatever, input -> whatever . Concrete example of reducing function are conj with whatever being a list, + (with whatever being a number, and input a number). See here for more details. The trick is you can define map, filter and other operations as reducing function (reducing function are used in reduce operations usually). It is important to note that reducing function can actually grow the whatever (see conj ). We create them by omitting the coll argument in the typical sequence functions, e.g. (map f) yields a transducer. Use the sequence function to realize the transducer. The following calls are equal ( = ( map # ( * 2 % ) ( range 10 )) ( sequence ( map # ( * 2 % )) ( range 10 ))) If we need eagerness we could use into ( into [] ( map # ( * 2 % )) ( range 10 )) The benefit of transducer is intermediate values are not allocated and there is a decoupling of the transformations with the reducer (reducing function and reducible collection). They are also polymorphic. We can compose transducers and reduction with transduce ( def moons-transform ( comp ( filter planet? ) ( map :moons ))) ( defn total-moons [ entities ] ( transduce moons-transform + 0 entities )) See understanding transducers for more details. Duplicate removal with distinct and dedupe (only remove subsequent duplicate and safer for large input). Use mapcat instead of (-> map flatten) .","title":"Processing Sequential Data."},{"location":"cards/20200430155637-applied_clojure/#reference-state-and-mutation","text":"Identity and state are two distinct notions. An identity is a sequence of immutable values, and the state is the actual value of an identity at a certain point of time. The challenge is to always display a single valid value to all the observer at the same time. There are two types of successions (mutation): atomic and transactions. An atomic transaction only cares about the change happening to the identity itself and not about the coordination of other identity. Transactional ensure that either all changes or none are performed. There are two states: program and runtime states. Program state is concerned with mutation in the problem domain, whereas runtime facilitate the software\u2019s execution (e.g. connections to databases or network, config files). Runtime state is often unavoidable whereas program state should be minimized and access through API with curated methods rather than directly. For managing change, we should build just enough to ensure the application\u2019s needs are met. Every side effect and mutable reference slows you down. We should be responsible over our functions (make them pure) and make choices about what need to be managed. State is a series of snapshots of values (data) which allows to act responsibly when considering the presence of observers in other processes. In Clojure, observers have consistent set of values as of a particular instant thanks to Clojure\u2019s mutable references.","title":"Reference, State and Mutation"},{"location":"cards/20200430155637-applied_clojure/#use-your-cores","text":"One of the problem is to send task of the main thread to be completed asynchronously and retrieve the result ( future and promise ). Tasks and workers for long lived task-oriented concurrency. We can also use reducers and core.async (with channels and go blocks ). For agents, use send for computational tasks and won\u2019t block for I/O and send-off for updates that might block for an arbitrary time (thread pool will grow accordingly). The advantage is agent can maintain state compared to future . Use deref or @ for retrieving back the value of a future or promise . Promise are used to returns several values from a future block. Use realized? to check if a promise is available, otherwise it will block. The deref function with an additional argument can force timeout. Use Java queues and workers for task oriented programs. This is for coarse grained task parallelism. Queues , threads and executors are the tools from Java to perform a queue of incoming work or requests. For fine-grained parallelism The pmap function can be used for easy parallelism, but the overhead might be consequential. The clojure.core.reducer library is the solution for parallelism [fine-grained operations and memory efficient]. A reducer is reducible collection combined with a reducing function . fold is used to perform the reduction [only vectors and maps can be folded in parallel, but the serial version can be faster thanks to avoiding intermediary values]. A reducer splits the data into partition, reduce the elements and then combine them. The reduce and the combine functions can hence be different. Concurrency (design the program as a set of concurrent threads of execution) we can use core.async . Channels come in unbuffered, fixed buffered, dropping (discard new data) and sliding buffer (discard old data). Creating a channel is done with chan the function. nil can not be passed into channels (as it is the value for saying the channel is closed). The important operations are put and take . A full channel (once the buffer is complete) blocks a thread if no process other process is the other end of the channel to take the value sent by put . Backpressure is the efffect that fixed sized buffers creates by making the producers block when trying to add to a full queue. Traditionally channels are used in go block . In the Communicating Sequential Processes (CSP), process belongs to a thread pool and are parked when not blocked by a channel operation ( >! or <! ). Go blocks are great for building pipelines of data transformation. core.async/pipelines gives up the raw performance of fine-grained data parallelism but yield a more flexible architecture. The function moves the value from input to output channel with parallel transducer execution. Next step is to break a growing system into pieces using concurrency.","title":"Use your cores"},{"location":"cards/20200430155637-applied_clojure/#designing-components","text":"Use of channels, better to receive and provide channels for interface. In core.async , a single go block is to call the body of the go block once asynchronously, while go-loop is intended for looping, unless we close the channel. go blocks return a channel, which can be used for pedestal. A good design is to split an API layer and implementation layer with a record. As for core.async , there are three additional concept for channels that are useful: pipeline, fan-in and fan-out. In a system, pipelines link an output channel to an input channel (acting like as a conveyor belt) and can possibly transform its input values with a transducer (async, sync, blocking). The pipe function should be used when no transformation. Fan-in channels gather the input of several channels and provide a single output channel. merge is a simple way to merge all the incoming channels into a single output channels, but it can\u2019t be modified after creation. The mix (for audio mix) function with its functions admix/unmix allows channel to participate in the mix. Users can toggle options for each input channel: :pause (no consumption nor inclusion in output channel), :mute (consumption but no inclusion), :solo ( if true, only solo-ed channels in output channel mix, :pause and :mute ignored if this is the case). Fan-out have three ways: mult , pub/sub , split . The mult abstraction is multiply traffic from the input channel into multiple output channels. Output channels (with different blocking policy) can participate in the connection with tap/untap (if a tap is closed, it is removed from the mult ). All the receiving channels must accept a value from the mult before the mult can move on to the next value. This is where alternative buffering strategy are useful. The pub/sub allows to distribute the traffic through a partition function and subscribers can inform to which partition value they want to lisen to. split divides the traffic two channels based on a truthiness of a predicate. split is actually a pub/sub with a partition function providing only truthy/falsy .","title":"Designing components"},{"location":"cards/20200430155637-applied_clojure/#compose-your-application","text":"Taking things apart: usualy some portion of the code will work on the same data, or have the data has a common scope or lifetime, likelihehood of change from external requirement is similar are resource needed. If code is reusable when configured differently in more than one context, then it is a component. Component should communicate with channels, but in order to set up the system correctly, we need something to orchestrate it. Several library exist, the book recommends Component , but it has been super-seeded by integrant . An example can be found here reitit/integrant . Environment variable also should exist with different settings. The solution in the book are a bit old. Environ still seems to be good on clojure (jvm).","title":"Compose Your Application"},{"location":"cards/20200430155637-applied_clojure/#testing","text":"There are three ways to create tests in clojure: repl, example based, generative testing (properties check). With REPL driven development, the example used for development are stored in a file (these are candidates for examples). For example based, there is the expectations library and the following snippets ( deftest test-range-are ( testing \"Testing range(endIndex)\" ( are [ expected endIndexf ( = expected ( range endIndex )) ' ( 0 1 2 3 4 ) 5 ' () 0 ]))) Generative testing using ( ns generative-testing.core ( :require [ clojure.test.check :as tc ] [ clojure.test.check.generators :as gen ] [ clojure.test.check.properties :as prop ])) I think nowadays we would use spec for it. We are looking for invariants \u2013 properties that are always true. [\u2026] mathematical laws, relationships between inputs and outputs, round-trip or complementing functions, and comparing action effects. Properties like identity, associativity, commutativity and idempotency are an excellent place to start. Invariants are important because they reduce the number of case your code must consider.","title":"Testing"},{"location":"cards/20200430155637-applied_clojure/#thinking-in-clojure","text":"Make Reasoned Choices: always compare trade-off of solutions (benefits and costs). Think first, then do . Careful treatment of decisions and weighed trade-off to fully understand the consequences. Be Reasonable: code with clearly expressed intent, limited side effects, neatly separated concerns, and unambiguous naming. Simple. Keep It Simple: Keep distinct concern as distinct as possible and avoid entangling concepts with other concepts. The code can be reasoned about, test and implemented without any incidental complexity. Entities are simplest when distinct and composable. Domain functions avoid complexity by avoiding side effects and concerning themselves only with entities in their domain. Build Just Enough: Keep complexity at bay and avoid overengineering. Compose: compose component, and evaluate your code composability by using it from another component. Results will be a set of tidy interfaces to distinct independent subsystems with clear communication channels. With a stable interface, a component can grow easily and adapt quickly. Be Precise: avoid ambiguity and communicate clearly with others and your future self. Entities typify one concept. Functions effect a single transformation. Queries ask simple questions and return unambiguous results. Use What Works: look for working libraries, solution in other languages or papers.","title":"Thinking in Clojure"},{"location":"cards/20200430155637-applied_clojure/#link","text":"Clojure Applied tags: clj core-async design","title":"Link"},{"location":"cards/20200430155637-applied_clojure/#see-also-generated","text":"CLI Arguments Clojure Clojure for the brave and the true core.async David Nolen Design edn and transit Life In Dynamic Typing Mastering Clojure Macro Multiple Environment Org-roam-clj: Org-roam extension with Clojure Simple Made Easy specs TODO Why Clojure?","title":"See also (generated)"},{"location":"cards/20200430155819-core_async/","text":"core.async \u00b6 tags: clojure asynchronous CSP Problems \u00b6 Function chains make poor machines Real world concurrency is exposed via callback API. core.async in Use \u00b6 Source: core.async in use Transducers are really important for using core.async. Use transducers as much as possible in channels and go block to avoid side effect. Make sure to return the channels. Disadvantage: async code pollutes the return type, problem with error handling, channels are IO and hence have side effects. It introduces non-determinism in the code. Don\u2019t use async, unless required. Pattern fetch and them conj all the result in a callback. A good api for library creators is to ask the user to take the result of the asynchronous code as a callback. Make a framework where the asynchronicity is set as an implemented detail. Remove it from the interface (user or API). You need to contains the asynchronicity and hide it from the business perspective. This yields, testable data, explicit data. Reifying is the act of taking virtual and making it concrete. Intangible to tangible. The interceptors ( enter , exit , on-error ). Dataflow and FRP. Nodes are connected via communication channels, each nodes takes and emits from on or more inputs/outputs, each node consists of a function that computes outputs ased on inputs. The advantage is that it Separates transformation from communication and connection. It is functionally pure, async code is removed from the user interface, connections are explicit, and any connections can be used. Actor, connections are implicit, sending message inside user code, opqare state hidden in loop local. Pattern in Pattern \u00b6 Keep user space code pure; Move the complexity of async out of the user space; Make dependencies/connections between modules/components explicit (the system can introspect itself). It increase leverage; Leverage this for easier testing; Use core.async to enable cleaner abstractions, not as aned in itself. Link \u00b6 Announcement Rich Hickey on core.async core.async in use See also (generated) \u00b6 Applied Clojure Clojure Clojure for the brave and the true Home for ideas for my Zettelkasten Mastering Clojure Macro TODO","title":"core.async"},{"location":"cards/20200430155819-core_async/#coreasync","text":"tags: clojure asynchronous CSP","title":"core.async"},{"location":"cards/20200430155819-core_async/#problems","text":"Function chains make poor machines Real world concurrency is exposed via callback API.","title":"Problems"},{"location":"cards/20200430155819-core_async/#coreasync-in-use","text":"Source: core.async in use Transducers are really important for using core.async. Use transducers as much as possible in channels and go block to avoid side effect. Make sure to return the channels. Disadvantage: async code pollutes the return type, problem with error handling, channels are IO and hence have side effects. It introduces non-determinism in the code. Don\u2019t use async, unless required. Pattern fetch and them conj all the result in a callback. A good api for library creators is to ask the user to take the result of the asynchronous code as a callback. Make a framework where the asynchronicity is set as an implemented detail. Remove it from the interface (user or API). You need to contains the asynchronicity and hide it from the business perspective. This yields, testable data, explicit data. Reifying is the act of taking virtual and making it concrete. Intangible to tangible. The interceptors ( enter , exit , on-error ). Dataflow and FRP. Nodes are connected via communication channels, each nodes takes and emits from on or more inputs/outputs, each node consists of a function that computes outputs ased on inputs. The advantage is that it Separates transformation from communication and connection. It is functionally pure, async code is removed from the user interface, connections are explicit, and any connections can be used. Actor, connections are implicit, sending message inside user code, opqare state hidden in loop local.","title":"core.async in Use"},{"location":"cards/20200430155819-core_async/#pattern-in-pattern","text":"Keep user space code pure; Move the complexity of async out of the user space; Make dependencies/connections between modules/components explicit (the system can introspect itself). It increase leverage; Leverage this for easier testing; Use core.async to enable cleaner abstractions, not as aned in itself.","title":"Pattern in Pattern"},{"location":"cards/20200430155819-core_async/#link","text":"Announcement Rich Hickey on core.async core.async in use","title":"Link"},{"location":"cards/20200430155819-core_async/#see-also-generated","text":"Applied Clojure Clojure Clojure for the brave and the true Home for ideas for my Zettelkasten Mastering Clojure Macro TODO","title":"See also (generated)"},{"location":"cards/20200430160432-clojure_for_the_brave_and_the_true/","text":"Clojure for the brave and the true \u00b6 Parallel demons :concurrency: \u00b6 Reference cell: Read and write a shared state. Mutual exclusion: Example with writing a log with several processes, e.g. concatenate \u201cab\u201d and \u201ccd\u201d in a file results in \u201cacbd\u201d. Deadlock: On a table, every one has to take the left and right stick and the same time. However, there is only one stick per person. Leading to a deadlock. Solutions to these are future (new thread), delay (like future but executed only at deref time), promise (empty memory location shared to all thread that will receive value only once with deliver ). The advantage is all the execution are cached. Note : deference is done with either the defer function or the @ sign in front of the variable. References type :concurrency:epochal_time_model: \u00b6 atom are identities that can be set and shared by multiple threads. They use a set and compare algorithm, i.e. the swap! function modifies the value of the atom variable only if its values did not change between the beginning and the end of the transaction. swap! and reset! are the main function to work with atoms. watch are function with four arguments: a key (a keyword for identifying the process calling the watcher), a reference variable being watched, the old-state, and the new state. ( defn f [ key watched old-state new-state ] nil ) A watcher function is attached to a reference type (e.g an atom) with the add-watch function having the following signature: ( def counter ( atom 0 )) ( add-watch counter :watching-counter watch-fn ) Validators are functions that can check if new states are valid. They take as argument the atom and return a boolean. They are added to the atom as follow ( defn bigger-than-1 [ x ] ( or ( > x 1 ) ( throw ( IllegalStateException. \"That's too small\" )))) ( def account ( atom 2 :validator bigger-than-1 )) ( swap! account inc ) ( swap! account - 10 ) ;; Throw an error ref type are the ACI in the ACID accronym (atomic, consistent and isolated) and use STM . It means that either the operations between two refs happened correctly, or the transaction is aborted. alter and dosync are the key functions. In a transaction (that is the body of dosync ), every ref keep their state to the transaction (invisible to outside threads) and when the transaction tries to commit, every ref checks if the value has been altered by other threads. If any of them has been change, then none of the ref are updated, and the transaction restart with the new value and commits only when the initial states has not been /alter/ed by other processes. commute also allow to change the state of a ref. However, at transaction time, if ref states have been altered, only the commute part is run again with the new states, which might lead to inconsistent state, but increased performance. ensure function protects refs from being modified by other transaction. This is helpful, when a transaction must modify only one refs, but the other related refs must not be altered by other transaction. 5. vars are associations between symbols and objects. ^:dynamic is a keyword in def to signal to clojure that a vars is dynamic. Varnames are enclosed around * (e.g. *user-email* ) to show to other programmers that the variable is dynamic. bindings is a dynamic let . Dynamic vars are often use to name a resource that one ore more functions target. set! allows to change the state of the dynamic vars. alter-var-root allows to rebind a immutable vars (which is unadvised), and with-redefs allows to create local binding for testing. 6. pmap and the following ppmap can be used to execute parallel task: ( defn ppmap \"Partitioned pmap, for grouping map ops together to make parallel overehead worthwile\" [ grain-size f & colls ] ( apply concat ( apply pmap ( fn [ & pgroups ] ( doall ( apply map f pgroups ))) ( map ( partial partition-all grain-size ) colls )))) core.async and channels :core_async: \u00b6 chan creates a channel. And channel communicate through messages . One can put and take message. Processes wait for completion of their message. Process: Wait and do nothing until successful completion of either put or take from a channel. After success of the operation, continue. go and their blocks ( go blocks ) runs separately on a concurrent thread. go creates a process (i.e. its go block), which runs a pool of threads equal two plus the number of machines cores (avoiding the overhead of creating threads). Each go block only live until it reach the ends of its body. <! and <!! are the take function. It listen to the channel and wait until an another process puts a value in the channel which the take function returns. >! and >!! are the put function which always return true. It provides a message to a channel and wait until the message to be taken by another process before releasing resources. The number of ! in the operation depends if one is inside a go block (one ! ) or not (two ! ). Blocking and parking waiting are key to understand the number of ! . Parking wait allows a thread to handle several process (and this is only possible in a go block ). When one of the process starts to wait, the thread put it aside and starts an another process until it starts to wait, and so on. Use poll! and offer! to have non blocking channel interactions in the REPL. Channel buffers are created as following: ( def buffer-size 2 ) ( def channel-buffer ( chan buffer-size )) This means we can create 2 values without waiting for a response. sliding-buffer (FIFO) and dropping-buffer (LIFO) can be used to discard channel message without blocking. 5. close! closes channel. A closed channel does not accept any puts anymore and after all the values have been retrieved, the subsequent takes return nil . 6. alts!! lets us use the result of the first successful channel operation among a collection of channel operations. The elegant solution with alts!! is one can define a timeout ( let [[ message channel ] ( alts!! [ c1 c2 ( timout 20 )])] ;; c1 and c2 are predefined channels. ( println message )) if the timeout is the first to finish than message is nil . See alt! macro as well. 7. Queues and pipelines (escaping the callback hell) are common patterns. Abstraction and polymorphism \u00b6 Multimethods ( defmulti method-name ( fn [ x ] ( :type x ))) ;; or simplty :type, can be more complicated as well ( defmethod method-name :hello [ x ] \"Hello\" ) ( defmethod method-name :good-bye [ x ] \"Good-bye\" ) ( defmethod method-name :default [ x ] \"I don't know you\" ) ( method-name { :type :hello }) ; => Hello ( method-name { :type :good-bye }) ; Good-bye ( method-name { :type :what? }) ; => I don't know you One can also create hierarchies with derive and namespace keywords. 2. A protocol allows to make dispatch by the type of the first argument and it is a collection of polymorphic operations (unlike multimethod which is just one function). Methods from protocols can not have a & rest argument. Key functions are defprotocol , extend-type , extend-protocol (for specifying for several type at once). - Caveat: methods from protocols are property of the namespace and not from the object. 3. Records are extension of hash-map . ( defrecord WereWolf [ name title ]) ( WereWolf. \"David\" \"Master\" ) ( ->WereWolf \"David\" \"Master\" ) ( map->WereWolf { :name \"David\" :title \"Master\" }) On has to use the :import: statement in the ns macro in order to import records. One can access field through the keyword or the dot . macro. ( .name ( WereWolf. \"David\" \"Master\" )) ; \"David\" ( :title ( WereWolf. \"David\" \"Master\" )) ; \"Master\" Any function on map works on record (although they do not retain their class if one dissoc or assoc them). Here is how one could extend a protocol. ( defprotocol WereCreature \"Awesom Were\" ( full-moon-behavior [ x ] \"Full-moon behavior\" )) ( defrecord WereWolf [ name title ] WereCreature ( full-moon-behavior [ x ] ( str name \" will kill everyone\" ))) ( full-moon-behavior ( WereWolf. \"David\" \"Master\" )) deftype , reify , proxy . reify is about implementing an anonymous protocol at runtime. Link \u00b6 Brave and the True See also (generated) \u00b6 Applied Clojure CLI Arguments Clojure core.async David Nolen edn and transit Life In Dynamic Typing Mastering Clojure Macro Multiple Environment Org-roam-clj: Org-roam extension with Clojure Simple Made Easy specs TODO Why Clojure?","title":"Clojure for the brave and the true"},{"location":"cards/20200430160432-clojure_for_the_brave_and_the_true/#clojure-for-the-brave-and-the-true","text":"","title":"Clojure for the brave and the true"},{"location":"cards/20200430160432-clojure_for_the_brave_and_the_true/#parallel-demons-concurrency","text":"Reference cell: Read and write a shared state. Mutual exclusion: Example with writing a log with several processes, e.g. concatenate \u201cab\u201d and \u201ccd\u201d in a file results in \u201cacbd\u201d. Deadlock: On a table, every one has to take the left and right stick and the same time. However, there is only one stick per person. Leading to a deadlock. Solutions to these are future (new thread), delay (like future but executed only at deref time), promise (empty memory location shared to all thread that will receive value only once with deliver ). The advantage is all the execution are cached. Note : deference is done with either the defer function or the @ sign in front of the variable.","title":"Parallel demons     :concurrency:"},{"location":"cards/20200430160432-clojure_for_the_brave_and_the_true/#references-type-concurrencyepochal_time_model","text":"atom are identities that can be set and shared by multiple threads. They use a set and compare algorithm, i.e. the swap! function modifies the value of the atom variable only if its values did not change between the beginning and the end of the transaction. swap! and reset! are the main function to work with atoms. watch are function with four arguments: a key (a keyword for identifying the process calling the watcher), a reference variable being watched, the old-state, and the new state. ( defn f [ key watched old-state new-state ] nil ) A watcher function is attached to a reference type (e.g an atom) with the add-watch function having the following signature: ( def counter ( atom 0 )) ( add-watch counter :watching-counter watch-fn ) Validators are functions that can check if new states are valid. They take as argument the atom and return a boolean. They are added to the atom as follow ( defn bigger-than-1 [ x ] ( or ( > x 1 ) ( throw ( IllegalStateException. \"That's too small\" )))) ( def account ( atom 2 :validator bigger-than-1 )) ( swap! account inc ) ( swap! account - 10 ) ;; Throw an error ref type are the ACI in the ACID accronym (atomic, consistent and isolated) and use STM . It means that either the operations between two refs happened correctly, or the transaction is aborted. alter and dosync are the key functions. In a transaction (that is the body of dosync ), every ref keep their state to the transaction (invisible to outside threads) and when the transaction tries to commit, every ref checks if the value has been altered by other threads. If any of them has been change, then none of the ref are updated, and the transaction restart with the new value and commits only when the initial states has not been /alter/ed by other processes. commute also allow to change the state of a ref. However, at transaction time, if ref states have been altered, only the commute part is run again with the new states, which might lead to inconsistent state, but increased performance. ensure function protects refs from being modified by other transaction. This is helpful, when a transaction must modify only one refs, but the other related refs must not be altered by other transaction. 5. vars are associations between symbols and objects. ^:dynamic is a keyword in def to signal to clojure that a vars is dynamic. Varnames are enclosed around * (e.g. *user-email* ) to show to other programmers that the variable is dynamic. bindings is a dynamic let . Dynamic vars are often use to name a resource that one ore more functions target. set! allows to change the state of the dynamic vars. alter-var-root allows to rebind a immutable vars (which is unadvised), and with-redefs allows to create local binding for testing. 6. pmap and the following ppmap can be used to execute parallel task: ( defn ppmap \"Partitioned pmap, for grouping map ops together to make parallel overehead worthwile\" [ grain-size f & colls ] ( apply concat ( apply pmap ( fn [ & pgroups ] ( doall ( apply map f pgroups ))) ( map ( partial partition-all grain-size ) colls ))))","title":"References type     :concurrency:epochal_time_model:"},{"location":"cards/20200430160432-clojure_for_the_brave_and_the_true/#coreasync-and-channels-core_async","text":"chan creates a channel. And channel communicate through messages . One can put and take message. Processes wait for completion of their message. Process: Wait and do nothing until successful completion of either put or take from a channel. After success of the operation, continue. go and their blocks ( go blocks ) runs separately on a concurrent thread. go creates a process (i.e. its go block), which runs a pool of threads equal two plus the number of machines cores (avoiding the overhead of creating threads). Each go block only live until it reach the ends of its body. <! and <!! are the take function. It listen to the channel and wait until an another process puts a value in the channel which the take function returns. >! and >!! are the put function which always return true. It provides a message to a channel and wait until the message to be taken by another process before releasing resources. The number of ! in the operation depends if one is inside a go block (one ! ) or not (two ! ). Blocking and parking waiting are key to understand the number of ! . Parking wait allows a thread to handle several process (and this is only possible in a go block ). When one of the process starts to wait, the thread put it aside and starts an another process until it starts to wait, and so on. Use poll! and offer! to have non blocking channel interactions in the REPL. Channel buffers are created as following: ( def buffer-size 2 ) ( def channel-buffer ( chan buffer-size )) This means we can create 2 values without waiting for a response. sliding-buffer (FIFO) and dropping-buffer (LIFO) can be used to discard channel message without blocking. 5. close! closes channel. A closed channel does not accept any puts anymore and after all the values have been retrieved, the subsequent takes return nil . 6. alts!! lets us use the result of the first successful channel operation among a collection of channel operations. The elegant solution with alts!! is one can define a timeout ( let [[ message channel ] ( alts!! [ c1 c2 ( timout 20 )])] ;; c1 and c2 are predefined channels. ( println message )) if the timeout is the first to finish than message is nil . See alt! macro as well. 7. Queues and pipelines (escaping the callback hell) are common patterns.","title":"core.async and channels     :core_async:"},{"location":"cards/20200430160432-clojure_for_the_brave_and_the_true/#abstraction-and-polymorphism","text":"Multimethods ( defmulti method-name ( fn [ x ] ( :type x ))) ;; or simplty :type, can be more complicated as well ( defmethod method-name :hello [ x ] \"Hello\" ) ( defmethod method-name :good-bye [ x ] \"Good-bye\" ) ( defmethod method-name :default [ x ] \"I don't know you\" ) ( method-name { :type :hello }) ; => Hello ( method-name { :type :good-bye }) ; Good-bye ( method-name { :type :what? }) ; => I don't know you One can also create hierarchies with derive and namespace keywords. 2. A protocol allows to make dispatch by the type of the first argument and it is a collection of polymorphic operations (unlike multimethod which is just one function). Methods from protocols can not have a & rest argument. Key functions are defprotocol , extend-type , extend-protocol (for specifying for several type at once). - Caveat: methods from protocols are property of the namespace and not from the object. 3. Records are extension of hash-map . ( defrecord WereWolf [ name title ]) ( WereWolf. \"David\" \"Master\" ) ( ->WereWolf \"David\" \"Master\" ) ( map->WereWolf { :name \"David\" :title \"Master\" }) On has to use the :import: statement in the ns macro in order to import records. One can access field through the keyword or the dot . macro. ( .name ( WereWolf. \"David\" \"Master\" )) ; \"David\" ( :title ( WereWolf. \"David\" \"Master\" )) ; \"Master\" Any function on map works on record (although they do not retain their class if one dissoc or assoc them). Here is how one could extend a protocol. ( defprotocol WereCreature \"Awesom Were\" ( full-moon-behavior [ x ] \"Full-moon behavior\" )) ( defrecord WereWolf [ name title ] WereCreature ( full-moon-behavior [ x ] ( str name \" will kill everyone\" ))) ( full-moon-behavior ( WereWolf. \"David\" \"Master\" )) deftype , reify , proxy . reify is about implementing an anonymous protocol at runtime.","title":"Abstraction and polymorphism"},{"location":"cards/20200430160432-clojure_for_the_brave_and_the_true/#link","text":"Brave and the True","title":"Link"},{"location":"cards/20200430160432-clojure_for_the_brave_and_the_true/#see-also-generated","text":"Applied Clojure CLI Arguments Clojure core.async David Nolen edn and transit Life In Dynamic Typing Mastering Clojure Macro Multiple Environment Org-roam-clj: Org-roam extension with Clojure Simple Made Easy specs TODO Why Clojure?","title":"See also (generated)"},{"location":"cards/20200430180442-org_mode/","text":"Org mode \u00b6 tags: org-mode Orgmk allows to use command line for exporting org files. org2gfm [ OPTION ] FILE Tricks \u00b6 Changing timestamp status . shift-up/down on the delimiters. See also (generated) \u00b6 Home for ideas for my Zettelkasten","title":"Org mode"},{"location":"cards/20200430180442-org_mode/#org-mode","text":"tags: org-mode Orgmk allows to use command line for exporting org files. org2gfm [ OPTION ] FILE","title":"Org mode"},{"location":"cards/20200430180442-org_mode/#tricks","text":"Changing timestamp status . shift-up/down on the delimiters.","title":"Tricks"},{"location":"cards/20200430180442-org_mode/#see-also-generated","text":"Home for ideas for my Zettelkasten","title":"See also (generated)"},{"location":"cards/20200430190921-design/","text":"Design \u00b6 Links \u00b6 Design, Composition, and Performance - Rich Hickey See also (generated) \u00b6 Applied Clojure Simple Made Easy","title":"Design"},{"location":"cards/20200430190921-design/#design","text":"","title":"Design"},{"location":"cards/20200430190921-design/#links","text":"Design, Composition, and Performance - Rich Hickey","title":"Links"},{"location":"cards/20200430190921-design/#see-also-generated","text":"Applied Clojure Simple Made Easy","title":"See also (generated)"},{"location":"cards/20200430235013-specs/","text":"Specs \u00b6 Links \u00b6 See also (generated) \u00b6 Applied Clojure Clojure Clojure for the brave and the true Life In Dynamic Typing Mastering Clojure Macro TODO Why Clojure?","title":"Specs"},{"location":"cards/20200430235013-specs/#specs","text":"","title":"Specs"},{"location":"cards/20200430235013-specs/#links","text":"","title":"Links"},{"location":"cards/20200430235013-specs/#see-also-generated","text":"Applied Clojure Clojure Clojure for the brave and the true Life In Dynamic Typing Mastering Clojure Macro TODO Why Clojure?","title":"See also (generated)"},{"location":"cards/20200501163355-goals/","text":"Goals \u00b6 Leverage TAGS \u00b6 Use #+TAGS options of orgs for generating automatically see also and tags field. [2020-05-04 Mon] . See also (generated) \u00b6 TODO","title":"Goals"},{"location":"cards/20200501163355-goals/#goals","text":"","title":"Goals"},{"location":"cards/20200501163355-goals/#leverage-tags","text":"Use #+TAGS options of orgs for generating automatically see also and tags field. [2020-05-04 Mon] .","title":"Leverage TAGS"},{"location":"cards/20200501163355-goals/#see-also-generated","text":"TODO","title":"See also (generated)"},{"location":"cards/20200501201607-quotes/","text":"Quotes \u00b6 Comics \u00b6 The measure of man lies not in what he says but in what he does . \u2013 Johnatan KENT Fiction \u00b6 Si on n\u2019est pas pr\u00eat \u00e0 tout, on n\u2019est pr\u00eat \u00e0 rien. \u2013 Paul AUSTER. A career is wonderful, but you can\u2019t curl up with it on a cold night. \u2013 Marilyn MONROE Science \u00b6 These quote are attributed to Einstein but I am not convinced. You can\u2019t blame gravity for falling in love. Learn from yesterday, live for today, hope for tomorrow. The important thing is not to stop questioning. Try not to become a man of success, but rather try to become a man of value. These, however, are probably from Einstein. Insanity: doing the same thing over and over again and expecting different results. The true sign of intelligence is not knowledge but imagination. The development of general ability for independent thinking and judgment should always be placed foremost. \u2013 Albert EINSTEIN Education \u00b6 Everybody is a genius. But if you judge a dolphin by its ability to climb a tree, it will live its whole life believing that it is stupid. \u2013 Anonymous Life Style \u00b6 These are inspirational philosophy [but not empirically approved in class room]. Growth mindset is about meaningful and purposed efforts. \u2013 Carol DWECK Grit is passion and sustained persistence applied toward long-term achievement, with no particular concern for rewards or recognition along the way. \u2013 Angela DUCKWORTH There should be a mixed between targeted skills [with clear steps to achieve them] and efforts. Deliberated practice is the key to mastery. Computer Science \u00b6 I don\u2019t know, I don\u2019t want to know. (Rich Hickey) In C++ and now in Haskell, we used to say that If it compiles, it is probably correct. It was as true then, as it is now. (Rich Hickey) Programmers know the benefits of everything and the tradeoffs of nothing. (Rich Hickey) tags: clj See also (generated) \u00b6 Clojure","title":"Quotes"},{"location":"cards/20200501201607-quotes/#quotes","text":"","title":"Quotes"},{"location":"cards/20200501201607-quotes/#comics","text":"The measure of man lies not in what he says but in what he does . \u2013 Johnatan KENT","title":"Comics"},{"location":"cards/20200501201607-quotes/#fiction","text":"Si on n\u2019est pas pr\u00eat \u00e0 tout, on n\u2019est pr\u00eat \u00e0 rien. \u2013 Paul AUSTER. A career is wonderful, but you can\u2019t curl up with it on a cold night. \u2013 Marilyn MONROE","title":"Fiction"},{"location":"cards/20200501201607-quotes/#science","text":"These quote are attributed to Einstein but I am not convinced. You can\u2019t blame gravity for falling in love. Learn from yesterday, live for today, hope for tomorrow. The important thing is not to stop questioning. Try not to become a man of success, but rather try to become a man of value. These, however, are probably from Einstein. Insanity: doing the same thing over and over again and expecting different results. The true sign of intelligence is not knowledge but imagination. The development of general ability for independent thinking and judgment should always be placed foremost. \u2013 Albert EINSTEIN","title":"Science"},{"location":"cards/20200501201607-quotes/#education","text":"Everybody is a genius. But if you judge a dolphin by its ability to climb a tree, it will live its whole life believing that it is stupid. \u2013 Anonymous","title":"Education"},{"location":"cards/20200501201607-quotes/#life-style","text":"These are inspirational philosophy [but not empirically approved in class room]. Growth mindset is about meaningful and purposed efforts. \u2013 Carol DWECK Grit is passion and sustained persistence applied toward long-term achievement, with no particular concern for rewards or recognition along the way. \u2013 Angela DUCKWORTH There should be a mixed between targeted skills [with clear steps to achieve them] and efforts. Deliberated practice is the key to mastery.","title":"Life Style"},{"location":"cards/20200501201607-quotes/#computer-science","text":"I don\u2019t know, I don\u2019t want to know. (Rich Hickey) In C++ and now in Haskell, we used to say that If it compiles, it is probably correct. It was as true then, as it is now. (Rich Hickey) Programmers know the benefits of everything and the tradeoffs of nothing. (Rich Hickey) tags: clj","title":"Computer Science"},{"location":"cards/20200501201607-quotes/#see-also-generated","text":"Clojure","title":"See also (generated)"},{"location":"cards/20200502122138-simple_made_easy/","text":"Simple Made Easy \u00b6 See also (generated) \u00b6 Applied Clojure Clojure Clojure for the brave and the true Design Mastering Clojure Macro Rich Hickey","title":"Simple Made Easy"},{"location":"cards/20200502122138-simple_made_easy/#simple-made-easy","text":"","title":"Simple Made Easy"},{"location":"cards/20200502122138-simple_made_easy/#see-also-generated","text":"Applied Clojure Clojure Clojure for the brave and the true Design Mastering Clojure Macro Rich Hickey","title":"See also (generated)"},{"location":"cards/20200503165952-materiala/","text":"Materiala \u00b6 My own tools for linking mkdocs and marginalia. See here for a rationale. TODO: \u00b6 Steal marginalia parser. Maybe do a fork, modify it and make a pull request. Github actions for updating the website and leaving the website in the git repo. Deploy to clojar. Get a group-id. Features \u00b6 Including multiple folder [2020-05-03 Sun] Extending the writer [2020-05-03 Sun] Parse non conform clojure code (marginalia has issue to reparse). [2020-05-03 Sun] Link \u00b6 https://github.com/davidpham87/materiala/ See also (generated) \u00b6 CLI Arguments General Skills Multiple Environment","title":"Materiala"},{"location":"cards/20200503165952-materiala/#materiala","text":"My own tools for linking mkdocs and marginalia. See here for a rationale.","title":"Materiala"},{"location":"cards/20200503165952-materiala/#todo","text":"Steal marginalia parser. Maybe do a fork, modify it and make a pull request. Github actions for updating the website and leaving the website in the git repo. Deploy to clojar. Get a group-id.","title":"TODO:"},{"location":"cards/20200503165952-materiala/#features","text":"Including multiple folder [2020-05-03 Sun] Extending the writer [2020-05-03 Sun] Parse non conform clojure code (marginalia has issue to reparse). [2020-05-03 Sun]","title":"Features"},{"location":"cards/20200503165952-materiala/#link","text":"https://github.com/davidpham87/materiala/","title":"Link"},{"location":"cards/20200503165952-materiala/#see-also-generated","text":"CLI Arguments General Skills Multiple Environment","title":"See also (generated)"},{"location":"cards/20200503222619-org_roam_clj/","text":"org-roam-clj \u00b6 Library for extending org-roam. Ideas \u00b6 Extend to markdown parsing. YAML heading. Own database [implement same operation]. GraalVM. Git as a database. Use Hugo for rendering. Cross device syncing with privacy. Use for leveraing org-parser Learn about instaparse . See also (generated) \u00b6 Applied Clojure Clojure Clojure for the brave and the true Mastering Clojure Macro","title":"org-roam-clj"},{"location":"cards/20200503222619-org_roam_clj/#org-roam-clj","text":"Library for extending org-roam.","title":"org-roam-clj"},{"location":"cards/20200503222619-org_roam_clj/#ideas","text":"Extend to markdown parsing. YAML heading. Own database [implement same operation]. GraalVM. Git as a database. Use Hugo for rendering. Cross device syncing with privacy. Use for leveraing org-parser Learn about instaparse .","title":"Ideas"},{"location":"cards/20200503222619-org_roam_clj/#see-also-generated","text":"Applied Clojure Clojure Clojure for the brave and the true Mastering Clojure Macro","title":"See also (generated)"},{"location":"cards/20200504204808-why_clojure/","text":"Why Clojure? \u00b6 Simplicity and concision (factor of 5 to 10), transparence. Information driven (work with data. Novelty of Lisp and functional programming. Better at design Macros, consumption, at change of paradigm Immutable Functions Reach (jvm, js, python) Concurrency and parallelism Reference type and why Testing Topics \u00b6 Hot code reloading Effective programming from Rich Hickey Links \u00b6 clojure specs core.async See also (generated) \u00b6 Applied Clojure Clojure Clojure for the brave and the true Mastering Clojure Macro specs","title":"Why Clojure?"},{"location":"cards/20200504204808-why_clojure/#why-clojure","text":"Simplicity and concision (factor of 5 to 10), transparence. Information driven (work with data. Novelty of Lisp and functional programming. Better at design Macros, consumption, at change of paradigm Immutable Functions Reach (jvm, js, python) Concurrency and parallelism Reference type and why Testing","title":"Why Clojure?"},{"location":"cards/20200504204808-why_clojure/#topics","text":"Hot code reloading Effective programming from Rich Hickey","title":"Topics"},{"location":"cards/20200504204808-why_clojure/#links","text":"clojure specs core.async","title":"Links"},{"location":"cards/20200504204808-why_clojure/#see-also-generated","text":"Applied Clojure Clojure Clojure for the brave and the true Mastering Clojure Macro specs","title":"See also (generated)"},{"location":"cards/20200504212017-edn_and_transit/","text":"edn and transit \u00b6 EDN \u00b6 EDN is the data format from Clojure. Transit \u00b6 Transit compress EDN to json or message pack and allows smaller payloads. You lose human readability, metadata and you need more context to understand the payloads. https://github.com/cognitect/transit-cljs/wiki/Getting-Started Links \u00b6 https://swannodette.github.io/2014/07/26/transit-clojurescript https://blog.cognitect.com/blog/2014/7/22/transit See also (generated) \u00b6 Applied Clojure Clojure Clojure for the brave and the true Mastering Clojure Macro","title":"edn and transit"},{"location":"cards/20200504212017-edn_and_transit/#edn-and-transit","text":"","title":"edn and transit"},{"location":"cards/20200504212017-edn_and_transit/#edn","text":"EDN is the data format from Clojure.","title":"EDN"},{"location":"cards/20200504212017-edn_and_transit/#transit","text":"Transit compress EDN to json or message pack and allows smaller payloads. You lose human readability, metadata and you need more context to understand the payloads. https://github.com/cognitect/transit-cljs/wiki/Getting-Started","title":"Transit"},{"location":"cards/20200504212017-edn_and_transit/#links","text":"https://swannodette.github.io/2014/07/26/transit-clojurescript https://blog.cognitect.com/blog/2014/7/22/transit","title":"Links"},{"location":"cards/20200504212017-edn_and_transit/#see-also-generated","text":"Applied Clojure Clojure Clojure for the brave and the true Mastering Clojure Macro","title":"See also (generated)"},{"location":"cards/20200504213118-effective_programs_10_years_of_clojure/","text":"Effective Programs - 10 years of clojure \u00b6 Links \u00b6 https://www.youtube.com/watch?v=2V1FtfBDsLU , Conj 2017 See also (generated) \u00b6 Rich Hickey","title":"Effective Programs - 10 years of clojure"},{"location":"cards/20200504213118-effective_programs_10_years_of_clojure/#effective-programs-10-years-of-clojure","text":"","title":"Effective Programs - 10 years of clojure"},{"location":"cards/20200504213118-effective_programs_10_years_of_clojure/#links","text":"https://www.youtube.com/watch?v=2V1FtfBDsLU , Conj 2017","title":"Links"},{"location":"cards/20200504213118-effective_programs_10_years_of_clojure/#see-also-generated","text":"Rich Hickey","title":"See also (generated)"},{"location":"cards/20200504213225-rich_hickey/","text":"Rich Hickey \u00b6 Author of Clojure See also (generated) \u00b6 Effective Programs - 10 years of clojure Simple Made Easy","title":"Rich Hickey"},{"location":"cards/20200504213225-rich_hickey/#rich-hickey","text":"Author of Clojure","title":"Rich Hickey"},{"location":"cards/20200504213225-rich_hickey/#see-also-generated","text":"Effective Programs - 10 years of clojure Simple Made Easy","title":"See also (generated)"},{"location":"cards/continuing_education/","text":"Continuing Education \u00b6 TODO FRM \u00b6 Read and do the exams for the two tests. TODO CFA \u00b6 Level 2 \u00b6 [X] Register [ ] Study TODO CQF \u00b6 TODO Udacity Nanodegree \u00b6 TODO Fullstack \u00b6 TODO Data Streaming \u00b6 DONE Front-end \u00b6 Not necessary thanks to ClojureScript. DONE Deep learning \u00b6 DONE Machine learning \u00b6 TODO Edx \u00b6 Finish Micro Master in statistics and Data Science. See also (generated) \u00b6 -","title":"Continuing Education"},{"location":"cards/continuing_education/#continuing-education","text":"","title":"Continuing Education"},{"location":"cards/continuing_education/#todo-frm","text":"Read and do the exams for the two tests.","title":"TODO FRM"},{"location":"cards/continuing_education/#todo-cfa","text":"","title":"TODO CFA"},{"location":"cards/continuing_education/#level-2","text":"[X] Register [ ] Study","title":"Level 2"},{"location":"cards/continuing_education/#todo-cqf","text":"","title":"TODO CQF"},{"location":"cards/continuing_education/#todo-udacity-nanodegree","text":"","title":"TODO Udacity Nanodegree"},{"location":"cards/continuing_education/#todo-fullstack","text":"","title":"TODO Fullstack"},{"location":"cards/continuing_education/#todo-data-streaming","text":"","title":"TODO Data Streaming"},{"location":"cards/continuing_education/#done-front-end","text":"Not necessary thanks to ClojureScript.","title":"DONE Front-end"},{"location":"cards/continuing_education/#done-deep-learning","text":"","title":"DONE Deep learning"},{"location":"cards/continuing_education/#done-machine-learning","text":"","title":"DONE Machine learning"},{"location":"cards/continuing_education/#todo-edx","text":"Finish Micro Master in statistics and Data Science.","title":"TODO Edx"},{"location":"cards/continuing_education/#see-also-generated","text":"-","title":"See also (generated)"},{"location":"cards/cpp/","text":"C/C++ \u00b6 [ ] Learn C the hard way [ ] Use Cling , the C++ interpreter [X] Learn CUDA <-> Udacity [ ] Read a tour of C++ [ ] Modern C++ (Scott Meyer) [ ] Redo the cpp exercise [ ] Reread Google Style Guide in C++ See also (generated) \u00b6 -","title":"C/C++"},{"location":"cards/cpp/#cc","text":"[ ] Learn C the hard way [ ] Use Cling , the C++ interpreter [X] Learn CUDA <-> Udacity [ ] Read a tour of C++ [ ] Modern C++ (Scott Meyer) [ ] Redo the cpp exercise [ ] Reread Google Style Guide in C++","title":"C/C++"},{"location":"cards/cpp/#see-also-generated","text":"-","title":"See also (generated)"},{"location":"cards/devops/","text":"Docker and Kubernete \u00b6 Docker are containers/processes which can be considered as lightweight VMs. Kuberenetes (K8s) are container orchestration. They allow for load balancing (2 level with ingress (external load balancing) and service (internal load balancer)) on pods (docker containers). They allow for recover from failure for resource, and rolling update. DevOPS \u00b6 Learn about ansible (again). Ubuntu Server/Install Starting Projects \u00b6 DONE Git [3/3] \u00b6 Remains to test in practice, but the project is pretty stable now. [X] Create a python file that writes the makefile automatically [X] Create README.md where appropriate. [X] Test the application See also (generated) \u00b6 -","title":"Docker and Kubernete"},{"location":"cards/devops/#docker-and-kubernete","text":"Docker are containers/processes which can be considered as lightweight VMs. Kuberenetes (K8s) are container orchestration. They allow for load balancing (2 level with ingress (external load balancing) and service (internal load balancer)) on pods (docker containers). They allow for recover from failure for resource, and rolling update.","title":"Docker and Kubernete"},{"location":"cards/devops/#devops","text":"Learn about ansible (again).","title":"DevOPS"},{"location":"cards/devops/#ubuntu-serverinstall-starting-projects","text":"","title":"Ubuntu Server/Install Starting Projects"},{"location":"cards/devops/#done-git-33","text":"Remains to test in practice, but the project is pretty stable now. [X] Create a python file that writes the makefile automatically [X] Create README.md where appropriate. [X] Test the application","title":"DONE Git [3/3]"},{"location":"cards/devops/#see-also-generated","text":"-","title":"See also (generated)"},{"location":"cards/general/","text":"General \u00b6 Learn with https://www.hackerrank.com/ (especially Clojure). Complete some harder problems in functional programming. www.pythonchallenge.com Exercise TODO Read introduction to elisp \u00b6 TODO Diff, ediff \u00b6 a or b to select which version is correct. Append x for saving. magit and git, gitimmersion \u00b6 [X] Revert file in magit [ ] Read introduction Master/read manual org-mode \u00b6 org-mode easy template (e.g. <s[tab] ) allows to easily include org syntax. C-c C-q (insert tags), C-c / (filter org-file by). Rewrite emacs.d through org-mode and usepackage. \u00b6 It would be good to get a unified version of my .emacs.d with org files and usepackage. DONE Dired mode \u00b6 Find files with grep Still have to learn the new shortcuts. Most important are R , C , D , ( , % m and =% g0. Using Q , empower the user to query and replace in files. Using * u to select all non-saved buffer to close them all. DONE Perfect use of keyboard [2/2] \u00b6 [X] The comma should be hit with the middle finger. [X] Emacs keybindings should be used using both hands, this has to be set with key-bindings. Tip: use the hand palm for reaching the CTRL keys. DONE Write a script to update my-emacs-config automatically. \u00b6 Best way would be to use git. Used a fork of emacs-live. DONE Remap C-c C-z to C-c C-y for Swiss Keyboards, for terminal switching. \u00b6 DONE Emmet in Emacs, with HAML filter in the json snippet. \u00b6 HAML is automatic in emacs. However, the key bindings need to be remapped as the usage of `C-j` is too much widespread. DONE Cppcheck \u00b6 wget https://raw.githubusercontent.com/google/styleguide/gh-pages/cpplint/cpplint.py sudo mv cpplint.py /usr/local/bin/cpplint.py sudo chmod 755 /usr/local/bin/cpplint.py Also uncomment the following ( custom-set-variables ' ( flycheck-c/c++-googlelint-executable \"/usr/local/bin/cpplint.py\" )) in cpp-settings.el . DONE Aspell \u00b6 Set dictionary in French and German. sudo apt-get install aspell-fr aspell-de Go to char (avy-goto-word-or-subword-1) \u00b6 In prelude \"C-c j\" and then char jumps to a given character in the buffer. See also (generated) \u00b6 Materiala Multiple Environment","title":"General"},{"location":"cards/general/#general","text":"Learn with https://www.hackerrank.com/ (especially Clojure). Complete some harder problems in functional programming. www.pythonchallenge.com Exercise","title":"General"},{"location":"cards/general/#todo-read-introduction-to-elisp","text":"","title":"TODO Read introduction to elisp"},{"location":"cards/general/#todo-diff-ediff","text":"a or b to select which version is correct. Append x for saving.","title":"TODO Diff, ediff"},{"location":"cards/general/#magit-and-git-gitimmersion","text":"[X] Revert file in magit [ ] Read introduction","title":"magit and git, gitimmersion"},{"location":"cards/general/#masterread-manual-org-mode","text":"org-mode easy template (e.g. <s[tab] ) allows to easily include org syntax. C-c C-q (insert tags), C-c / (filter org-file by).","title":"Master/read manual org-mode"},{"location":"cards/general/#rewrite-emacsd-through-org-mode-and-usepackage","text":"It would be good to get a unified version of my .emacs.d with org files and usepackage.","title":"Rewrite emacs.d through org-mode and usepackage."},{"location":"cards/general/#done-dired-mode","text":"Find files with grep Still have to learn the new shortcuts. Most important are R , C , D , ( , % m and =% g0. Using Q , empower the user to query and replace in files. Using * u to select all non-saved buffer to close them all.","title":"DONE Dired mode"},{"location":"cards/general/#done-perfect-use-of-keyboard-22","text":"[X] The comma should be hit with the middle finger. [X] Emacs keybindings should be used using both hands, this has to be set with key-bindings. Tip: use the hand palm for reaching the CTRL keys.","title":"DONE Perfect use of keyboard [2/2]"},{"location":"cards/general/#done-write-a-script-to-update-my-emacs-config-automatically","text":"Best way would be to use git. Used a fork of emacs-live.","title":"DONE Write a script to update my-emacs-config automatically."},{"location":"cards/general/#done-remap-c-c-c-z-to-c-c-c-y-for-swiss-keyboards-for-terminal-switching","text":"","title":"DONE Remap C-c C-z to C-c C-y for Swiss Keyboards, for terminal switching."},{"location":"cards/general/#done-emmet-in-emacs-with-haml-filter-in-the-json-snippet","text":"HAML is automatic in emacs. However, the key bindings need to be remapped as the usage of `C-j` is too much widespread.","title":"DONE Emmet in Emacs, with HAML filter in the json snippet."},{"location":"cards/general/#done-cppcheck","text":"wget https://raw.githubusercontent.com/google/styleguide/gh-pages/cpplint/cpplint.py sudo mv cpplint.py /usr/local/bin/cpplint.py sudo chmod 755 /usr/local/bin/cpplint.py Also uncomment the following ( custom-set-variables ' ( flycheck-c/c++-googlelint-executable \"/usr/local/bin/cpplint.py\" )) in cpp-settings.el .","title":"DONE Cppcheck"},{"location":"cards/general/#done-aspell","text":"Set dictionary in French and German. sudo apt-get install aspell-fr aspell-de","title":"DONE Aspell"},{"location":"cards/general/#go-to-char-avy-goto-word-or-subword-1","text":"In prelude \"C-c j\" and then char jumps to a given character in the buffer.","title":"Go to char (avy-goto-word-or-subword-1)"},{"location":"cards/general/#see-also-generated","text":"Materiala Multiple Environment","title":"See also (generated)"},{"location":"cards/python/","text":"Python \u00b6 [X] IPython [X] Jupyter Noteboks jupyter notebooks [ ] scikit, read documentation. [X] pylint pylintrc to determine which mistakes to solve. One can also use # pylint header in python files, e.g. pandas source code. you can use disable [X] pyflakes [ ] nose2 and automatic test. [X] Google Tensorflow . [ ] pytorch See also (generated) \u00b6 ETHZ R CRAN","title":"Python"},{"location":"cards/python/#python","text":"[X] IPython [X] Jupyter Noteboks jupyter notebooks [ ] scikit, read documentation. [X] pylint pylintrc to determine which mistakes to solve. One can also use # pylint header in python files, e.g. pandas source code. you can use disable [X] pyflakes [ ] nose2 and automatic test. [X] Google Tensorflow . [ ] pytorch","title":"Python"},{"location":"cards/python/#see-also-generated","text":"ETHZ R CRAN","title":"See also (generated)"},{"location":"cards/r_cran/","text":"R \u00b6 [X] Do the empirical stuff, start MSc Thesis. [X] Go through base R functions to discover new functions. [ ] Rcpp after revising C++. [X] Shiny. [ ] Set lintr on Emacs. See also (generated) \u00b6 ETHZ Python","title":"R"},{"location":"cards/r_cran/#r","text":"[X] Do the empirical stuff, start MSc Thesis. [X] Go through base R functions to discover new functions. [ ] Rcpp after revising C++. [X] Shiny. [ ] Set lintr on Emacs.","title":"R"},{"location":"cards/r_cran/#see-also-generated","text":"ETHZ Python","title":"See also (generated)"},{"location":"cards/readings/","text":"Books \u00b6 DONE How Google works \u00b6 Culture is the one thing to get right. Smart creatives are the core of the company. These are monsters, who can do everything and are social people. Hiring is vital, colleagues must be learning animals and smarter than you are. Consensus brings opposite point of view. Design someone as owner of meetings, transparency (about objectives, results and key results for all employees), manager sets deadlines. Innovation: shoot for the moon. Default to open for your technology. Quality of a product is the only dimension on which on should focus. Create new products because of technical insight. TODO Work rules from Google \u00b6 Culture makes it right. Vision. Openess. Hire smarter than you (in some meaningful way). Committee hiring. Trust your employees, managers to decide about deadlines and conflict. Performance review: 5 rank OKR: objectives, key, results and transparency about OKR. Manager Gives actionable feedback that helps improve performance No micromanagement Consideration as a person Keeps team focused on priority results/deliverable. Share relevant information from his manager and senior leadership. Meaningful discussion about career development every six months. Comminucates clear goals. Has techincal expertise required to effectively manage. Should be recommended to other coworkers. Learning: focus on learning few things but well. Repetition and internalization concepts or teaching material. TODO When To Rob A Bank. \u00b6 Culture Code. \u00b6 TODO The Art of Unix Programming \u00b6 Philosophy of linux. TODO Principles of financial engineering \u00b6 TODO Becoming a better programmer, Pete Goodliffe \u00b6 You.write(code) Favor common convention in style, strive for consistency and clarity, good design is better that good presentation. Write less code (elegance is paramount, DRY). Pay attention to logic operator to avoid if-else construct, use existing code to avoid bugs, delete dead code (never called function, never read variable, unused parameters and other types). Comments should explain the why . Try to use ternary operator as much as possible. Take responsibility of code removal and leave code a little better than it was. Improve code by remove it. Do not write code that you do not need now . A system can improve by removing code. It is inevitable that dead code arises. Zombie code makes your life harder. TODO Code Craft, Pete Goodliffe \u00b6 TODO Why I left Goldman Sachs \u00b6 TODO Lords of Finance \u00b6 TODO The Finance Curse: How global finance is making us all poorer \u00b6 SICP \u00b6 See also (generated) \u00b6 Home for ideas for my Zettelkasten","title":"Books"},{"location":"cards/readings/#books","text":"","title":"Books"},{"location":"cards/readings/#done-how-google-works","text":"Culture is the one thing to get right. Smart creatives are the core of the company. These are monsters, who can do everything and are social people. Hiring is vital, colleagues must be learning animals and smarter than you are. Consensus brings opposite point of view. Design someone as owner of meetings, transparency (about objectives, results and key results for all employees), manager sets deadlines. Innovation: shoot for the moon. Default to open for your technology. Quality of a product is the only dimension on which on should focus. Create new products because of technical insight.","title":"DONE How Google works"},{"location":"cards/readings/#todo-work-rules-from-google","text":"Culture makes it right. Vision. Openess. Hire smarter than you (in some meaningful way). Committee hiring. Trust your employees, managers to decide about deadlines and conflict. Performance review: 5 rank OKR: objectives, key, results and transparency about OKR. Manager Gives actionable feedback that helps improve performance No micromanagement Consideration as a person Keeps team focused on priority results/deliverable. Share relevant information from his manager and senior leadership. Meaningful discussion about career development every six months. Comminucates clear goals. Has techincal expertise required to effectively manage. Should be recommended to other coworkers. Learning: focus on learning few things but well. Repetition and internalization concepts or teaching material.","title":"TODO Work rules from Google"},{"location":"cards/readings/#todo-when-to-rob-a-bank","text":"","title":"TODO When To Rob A Bank."},{"location":"cards/readings/#culture-code","text":"","title":"Culture Code."},{"location":"cards/readings/#todo-the-art-of-unix-programming","text":"Philosophy of linux.","title":"TODO The Art of Unix Programming"},{"location":"cards/readings/#todo-principles-of-financial-engineering","text":"","title":"TODO Principles of financial engineering"},{"location":"cards/readings/#todo-becoming-a-better-programmer-pete-goodliffe","text":"You.write(code) Favor common convention in style, strive for consistency and clarity, good design is better that good presentation. Write less code (elegance is paramount, DRY). Pay attention to logic operator to avoid if-else construct, use existing code to avoid bugs, delete dead code (never called function, never read variable, unused parameters and other types). Comments should explain the why . Try to use ternary operator as much as possible. Take responsibility of code removal and leave code a little better than it was. Improve code by remove it. Do not write code that you do not need now . A system can improve by removing code. It is inevitable that dead code arises. Zombie code makes your life harder.","title":"TODO Becoming a better programmer, Pete Goodliffe"},{"location":"cards/readings/#todo-code-craft-pete-goodliffe","text":"","title":"TODO Code Craft, Pete Goodliffe"},{"location":"cards/readings/#todo-why-i-left-goldman-sachs","text":"","title":"TODO Why I left Goldman Sachs"},{"location":"cards/readings/#todo-lords-of-finance","text":"","title":"TODO Lords of Finance"},{"location":"cards/readings/#todo-the-finance-curse-how-global-finance-is-making-us-all-poorer","text":"","title":"TODO The Finance Curse: How global finance is making us all poorer"},{"location":"cards/readings/#sicp","text":"","title":"SICP"},{"location":"cards/readings/#see-also-generated","text":"Home for ideas for my Zettelkasten","title":"See also (generated)"},{"location":"cards/unix/","text":"Unix command learning \u00b6 [X] find command: options are: -name (\"*.cpp\" or \".c\") , -type (f, d) , -mtime , use +/-[:digit:] for saying \u201cmore or less [:digit:] time\u201d, escaped parentheses \\( \\) , -a(nd) or -o(r) ! (negation) . The -exec option passes the result to the following instruction (like ls -s) with {} \\; for the place holder of the find results. [ ] Grep [ ] cron (scheduling). See also (generated) \u00b6 -","title":"Unix command learning"},{"location":"cards/unix/#unix-command-learning","text":"[X] find command: options are: -name (\"*.cpp\" or \".c\") , -type (f, d) , -mtime , use +/-[:digit:] for saying \u201cmore or less [:digit:] time\u201d, escaped parentheses \\( \\) , -a(nd) or -o(r) ! (negation) . The -exec option passes the result to the following instruction (like ls -s) with {} \\; for the place holder of the find results. [ ] Grep [ ] cron (scheduling).","title":"Unix command learning"},{"location":"cards/unix/#see-also-generated","text":"-","title":"See also (generated)"},{"location":"cards/website/","text":"Website [3/3] Recreate online cv with middleman and org for blog See also (generated) Website [3/3] \u00b6 [X] Learn html and css (udacity). [X] middleman (ruby) for static page generation. [3/3] [X] HAML, partial and filters. [X] Bootrstrap inteegration [X] Use the following to deploy interactively with live-reload. bundle exec middleman [X] Write about codemirror and mathjax in codemirror Recreate online cv with middleman and org for blog \u00b6 [X] Online cv done. [ ] Understand middleman gh-page for blog. [ ] Links org files. [ ] Publish summaries. See also (generated) \u00b6 -","title":"Website"},{"location":"cards/website/#website-33","text":"[X] Learn html and css (udacity). [X] middleman (ruby) for static page generation. [3/3] [X] HAML, partial and filters. [X] Bootrstrap inteegration [X] Use the following to deploy interactively with live-reload. bundle exec middleman [X] Write about codemirror and mathjax in codemirror","title":"Website [3/3]"},{"location":"cards/website/#recreate-online-cv-with-middleman-and-org-for-blog","text":"[X] Online cv done. [ ] Understand middleman gh-page for blog. [ ] Links org files. [ ] Publish summaries.","title":"Recreate online cv with middleman and org for blog"},{"location":"cards/website/#see-also-generated","text":"-","title":"See also (generated)"},{"location":"decks/clojure/","text":"Clojure \u00b6 General \u00b6 [X] Check flycheck with clojure (if useful, use clj-kondo). Concepts \u00b6 [ ] specs: write about the principal functions. Test and use generative testing with specs. [ ] Create generators using asnyc and neanderthal. [ ] transducers: use them more extensively. [ ] core.async: find excuses to use them. [ ] Integrant [ ] aero/enviro [whatever works with cljs] [ ] Datomic [ ] Webworkers TODO Web Development with Clojure \u00b6 A handler is a function that receive a request map (and response callaback and raise callback) and returns a response map or calls the reponse callback on the response map. A middleware is a function that whose first argument is a handler and should return a handler. Clojurescript \u00b6 [X] https://github.com/bhauman/lein-figwheel [shadow-cljs is more useful] [ ] tools.deps, read more about arguments. [X] Understand how to wrap javascript code into Clojure. Use NPM. How to communicate between clojure and clojurescript (cljc) or sente. [ ] https://funcool.github.io/clojurescript-unraveled/ [ ] Make a summary of core.async chapter. Udemy [core.async] Elements of Clojure \u00b6 Naming \u00b6 There is a difference between the sign (the symbols or letters) and the referent (the thing/value to which the sign refers). Consistency is one of the feature that allow to grow. Precision is a trade-off with generality. synthetic allow precision, natural allows beginners to understand (trade off wit how much to learn before being productive). Idioms \u00b6 Indirection \u00b6 Indirection is the process of separating the how from the what . It useful when answering the question How does it work is answered best with it depends . Reference and conditionals are two tools to perform indirection. Getting the referent from a reference is called dereferencing . Reference are open, while conditional are closed (which could be a feature). Another difference is the order matters in conditional (like cond ). Dispatch happens in two context runtime ( dynamic ) and compile time ( static dispatching). Best to avoid hierarchies. Abstraction should be simplest model that satisfies the context requirements and self consistent. It depends on the context which sets the minimal set of constraints to pay attention to. As such it lives in a bubble/context. Hence, we should ask, what are the assumptions of the code? There are the two distinction for abstraction Principled vs Adaptable. Principled allows to create big architecture artifacts, but they are not adaptable (castle cards or sky scrapper, changing a room are hard). We should thrive for complex adaptable network, that is small components that are principled but in an adaptable network (pieces can be removed and substituted). How to gather code to create principled component? If code have the same set of assumption, then good place to gather them. Change is constant. Blogs \u00b6 Agile is an attitude - Russ Olsen Cognitect [2017] \u00b6 The Monkey wrench of agile is the following: To get the job done you need to focus on the goal and the people who will get you there. There is no magic recipe, no set of practices that will guarantee success You need to be ready to throw away the rule book and bob and weave and flex with whatever comes next. You need to improvise, adapt and overcome. Above all, agile means keeping your eye on the fundamentals: What are the goals? And how are we going to get there? You need to be ready to throw away the rule book and bob and weave and flex with whatever comes next. You need to improvise, adapt and overcome . Above all, agile means keeping your eye on the fundamentals: What are the goals? And how are we going to get there? . You need to improvise, adapt and overcome. What are the goals, and how are we going to get there? When agile processes make sense, use them. When they don\u2019t, let them go without regret. Iteration Zero - Naoko Higashide Cognitect [2017] \u00b6 The framework is about people first, conversations, realizations, and shared understanding. Bring people who will participate (not attend). First is to define responsibilities. will for . Finishing lines. The project will be complete when\u2026 Winning condition. Of the following choose three and describe: Schedule Scope Quality Budget Customer Satisfaction Teamwork / Learning Make sure that project\u2019s sponsor is aligned with those of the team. Talks \u00b6 Maybe not - Rich Hickey [2018] \u00b6 The talk is about clojure.spec and about the optionality in requirements. Static typing proponents will always talks about the benefits of types without ever mentioning the costs. In non breaking changes of API (requiring less, providing more), static typing will break APIs callers. Records in contrast to maps (open sets of keys and values) are PLOP. Because you need to place something in the slot where they contain data, and hence options. Clojure will always forbid to create brittle system with closed specifications. In Clojure, when an field of information (the value of a key in map) in unknown, the key is removed from the map (and avoid keys with nil value). Because if the value is nil , we don\u2019t know if we should be worried if the value is nil or if it is valid. In contrast, if the key is not in the map we can safely ignore it. Data aggregates are herd of information and is moving from one process to another. The solution is to define herd is to split the specifications into two: a schema describing the aggregate (and its tree) and a context whenever in function calls and returns. Specs Leverage/Testing/Custom Generators, Screencast- Stuart Halloway [2016] \u00b6 The advantage are validation, conformance, destructuring, error message, composition, example data generation, assertion, documentation, generative testing, instrumentation. It is about specs. Specs allows to define attributes, composites and function specs. A function specs takes three keys :args , :ret and :fn (which takes the specs as argument). The most interesting is the fn which is describe properties of the function returns. Specs allows to use regular expression on data structure for creating your specs. You can use s/exercise for generating sample of your spec and (test/check `my-fn) and test/summarize-result for checking your function specs. The function s/valid? and s/explain-data allows to validate and to get data for our mistakes. Whenever testing, you also can use test/instrument to instrument your function for better error message. s/alt for alternative, s/and for predicates aggregation, s/or for or predicate composition. Maybe s/& . The function gen/fmap takes a value from a generate and returns a value, while gen/let and gen/bind takes a generator and return a generator. Usually these are wrapped into functions and called with ( s/exercise ::s { ::s wrapper-around-fmap }) ;; or ( s/def ::s ( s/spec pred? :gen wrapper-around-fmap )) Usually, gen/let and gen/bind are used in conjunction with a model for representing the input data. The model acts as generator of test input, helping to conceptualize the expected inputs. For example ( def model ( s/cat :prefix string? :match string? :suffix string? )) when testing a index-of function for string. Write about s/fspec . The trick in using s/fspec is to provide reasonable generators. Using the gen/return allows to wrap a high order function as a generator . Read test.check.generator for more details . Design, Composition and Performance [2013] \u00b6 What is a good design? Separating into things that can be composed. Each component should be about one or a few things. We solve a problem by composing the parts. It is iterative. Design is about taking things apart. Requirements: Move from the want/need to the problems. Explicit the knowns to the unknowns. Requirement from the domain side (how the information is transformed) to the solution side (on which technology should the code run). We can split the cause and the symptom for the problem, and explicit the unstated requirement (e.g. should not destroy the machine or crash). Time, order and flow: In which ordering are the operation to happen, can they be commutative? Place, participants: Who is participating into the process? Which processes? Information and mechanism: Which components belongs to the information or business problem, and which belongs to the technical solution. Solutions: We have to compare multiple solutions and state their benefits and trade offs. We should separate need/features from the intrinsic problem. Learning requires inefficiency. Constraint is a driver of Creativity. So we should ask as much constraint as possible when solving a problem. We are forced to take a choice and move on. Design is imagining (potential solution) and embrace constraints, create additional if not enough restrictive. It is optimistic, be positive and imagine a lot. Design is about making decisions. The value conveyed is in decisions made. Performing is preparing (planning). We should practice and study. Develop sensibilities you can apply on the fly (pattern, techniques to know what works and what not). Design is about take things apart in order to be able to pull them back together. Design like Bartok (communication very well at multiple levels). Code like Coltrane (preparedness and experience, by doing multiple things and not the same thing over and over). Choose tools that are like instruments (stable, simple and oriented at one thing and around people who know how to use them). They should express a fundamental idea (excitation for instruments). Try to pursue harmony in the design. See also (generated) \u00b6 Applied Clojure CLI Arguments Clojure for the brave and the true core.async David Nolen edn and transit Home for ideas for my Zettelkasten Life In Dynamic Typing Mastering Clojure Macro Multiple Environment Org-roam-clj: Org-roam extension with Clojure Quotes shadow-cljs Simple Made Easy specs Why Clojure?","title":"Clojure"},{"location":"decks/clojure/#clojure","text":"","title":"Clojure"},{"location":"decks/clojure/#general","text":"[X] Check flycheck with clojure (if useful, use clj-kondo).","title":"General"},{"location":"decks/clojure/#concepts","text":"[ ] specs: write about the principal functions. Test and use generative testing with specs. [ ] Create generators using asnyc and neanderthal. [ ] transducers: use them more extensively. [ ] core.async: find excuses to use them. [ ] Integrant [ ] aero/enviro [whatever works with cljs] [ ] Datomic [ ] Webworkers","title":"Concepts"},{"location":"decks/clojure/#todo-web-development-with-clojure","text":"A handler is a function that receive a request map (and response callaback and raise callback) and returns a response map or calls the reponse callback on the response map. A middleware is a function that whose first argument is a handler and should return a handler.","title":"TODO Web Development with Clojure"},{"location":"decks/clojure/#clojurescript","text":"[X] https://github.com/bhauman/lein-figwheel [shadow-cljs is more useful] [ ] tools.deps, read more about arguments. [X] Understand how to wrap javascript code into Clojure. Use NPM. How to communicate between clojure and clojurescript (cljc) or sente. [ ] https://funcool.github.io/clojurescript-unraveled/ [ ] Make a summary of core.async chapter. Udemy [core.async]","title":"Clojurescript"},{"location":"decks/clojure/#elements-of-clojure","text":"","title":"Elements of Clojure"},{"location":"decks/clojure/#naming","text":"There is a difference between the sign (the symbols or letters) and the referent (the thing/value to which the sign refers). Consistency is one of the feature that allow to grow. Precision is a trade-off with generality. synthetic allow precision, natural allows beginners to understand (trade off wit how much to learn before being productive).","title":"Naming"},{"location":"decks/clojure/#idioms","text":"","title":"Idioms"},{"location":"decks/clojure/#indirection","text":"Indirection is the process of separating the how from the what . It useful when answering the question How does it work is answered best with it depends . Reference and conditionals are two tools to perform indirection. Getting the referent from a reference is called dereferencing . Reference are open, while conditional are closed (which could be a feature). Another difference is the order matters in conditional (like cond ). Dispatch happens in two context runtime ( dynamic ) and compile time ( static dispatching). Best to avoid hierarchies. Abstraction should be simplest model that satisfies the context requirements and self consistent. It depends on the context which sets the minimal set of constraints to pay attention to. As such it lives in a bubble/context. Hence, we should ask, what are the assumptions of the code? There are the two distinction for abstraction Principled vs Adaptable. Principled allows to create big architecture artifacts, but they are not adaptable (castle cards or sky scrapper, changing a room are hard). We should thrive for complex adaptable network, that is small components that are principled but in an adaptable network (pieces can be removed and substituted). How to gather code to create principled component? If code have the same set of assumption, then good place to gather them. Change is constant.","title":"Indirection"},{"location":"decks/clojure/#blogs","text":"","title":"Blogs"},{"location":"decks/clojure/#agile-is-an-attitude-russ-olsen-cognitect-2017","text":"The Monkey wrench of agile is the following: To get the job done you need to focus on the goal and the people who will get you there. There is no magic recipe, no set of practices that will guarantee success You need to be ready to throw away the rule book and bob and weave and flex with whatever comes next. You need to improvise, adapt and overcome. Above all, agile means keeping your eye on the fundamentals: What are the goals? And how are we going to get there? You need to be ready to throw away the rule book and bob and weave and flex with whatever comes next. You need to improvise, adapt and overcome . Above all, agile means keeping your eye on the fundamentals: What are the goals? And how are we going to get there? . You need to improvise, adapt and overcome. What are the goals, and how are we going to get there? When agile processes make sense, use them. When they don\u2019t, let them go without regret.","title":"Agile is an attitude - Russ Olsen Cognitect [2017]"},{"location":"decks/clojure/#iteration-zero-naoko-higashide-cognitect-2017","text":"The framework is about people first, conversations, realizations, and shared understanding. Bring people who will participate (not attend). First is to define responsibilities. will for . Finishing lines. The project will be complete when\u2026 Winning condition. Of the following choose three and describe: Schedule Scope Quality Budget Customer Satisfaction Teamwork / Learning Make sure that project\u2019s sponsor is aligned with those of the team.","title":"Iteration Zero - Naoko Higashide Cognitect [2017]"},{"location":"decks/clojure/#talks","text":"","title":"Talks"},{"location":"decks/clojure/#maybe-not-rich-hickey-2018","text":"The talk is about clojure.spec and about the optionality in requirements. Static typing proponents will always talks about the benefits of types without ever mentioning the costs. In non breaking changes of API (requiring less, providing more), static typing will break APIs callers. Records in contrast to maps (open sets of keys and values) are PLOP. Because you need to place something in the slot where they contain data, and hence options. Clojure will always forbid to create brittle system with closed specifications. In Clojure, when an field of information (the value of a key in map) in unknown, the key is removed from the map (and avoid keys with nil value). Because if the value is nil , we don\u2019t know if we should be worried if the value is nil or if it is valid. In contrast, if the key is not in the map we can safely ignore it. Data aggregates are herd of information and is moving from one process to another. The solution is to define herd is to split the specifications into two: a schema describing the aggregate (and its tree) and a context whenever in function calls and returns.","title":"Maybe not - Rich Hickey [2018]"},{"location":"decks/clojure/#specs-leveragetestingcustom-generators-screencast-stuart-halloway-2016","text":"The advantage are validation, conformance, destructuring, error message, composition, example data generation, assertion, documentation, generative testing, instrumentation. It is about specs. Specs allows to define attributes, composites and function specs. A function specs takes three keys :args , :ret and :fn (which takes the specs as argument). The most interesting is the fn which is describe properties of the function returns. Specs allows to use regular expression on data structure for creating your specs. You can use s/exercise for generating sample of your spec and (test/check `my-fn) and test/summarize-result for checking your function specs. The function s/valid? and s/explain-data allows to validate and to get data for our mistakes. Whenever testing, you also can use test/instrument to instrument your function for better error message. s/alt for alternative, s/and for predicates aggregation, s/or for or predicate composition. Maybe s/& . The function gen/fmap takes a value from a generate and returns a value, while gen/let and gen/bind takes a generator and return a generator. Usually these are wrapped into functions and called with ( s/exercise ::s { ::s wrapper-around-fmap }) ;; or ( s/def ::s ( s/spec pred? :gen wrapper-around-fmap )) Usually, gen/let and gen/bind are used in conjunction with a model for representing the input data. The model acts as generator of test input, helping to conceptualize the expected inputs. For example ( def model ( s/cat :prefix string? :match string? :suffix string? )) when testing a index-of function for string. Write about s/fspec . The trick in using s/fspec is to provide reasonable generators. Using the gen/return allows to wrap a high order function as a generator . Read test.check.generator for more details .","title":"Specs Leverage/Testing/Custom Generators, Screencast- Stuart Halloway [2016]"},{"location":"decks/clojure/#design-composition-and-performance-2013","text":"What is a good design? Separating into things that can be composed. Each component should be about one or a few things. We solve a problem by composing the parts. It is iterative. Design is about taking things apart. Requirements: Move from the want/need to the problems. Explicit the knowns to the unknowns. Requirement from the domain side (how the information is transformed) to the solution side (on which technology should the code run). We can split the cause and the symptom for the problem, and explicit the unstated requirement (e.g. should not destroy the machine or crash). Time, order and flow: In which ordering are the operation to happen, can they be commutative? Place, participants: Who is participating into the process? Which processes? Information and mechanism: Which components belongs to the information or business problem, and which belongs to the technical solution. Solutions: We have to compare multiple solutions and state their benefits and trade offs. We should separate need/features from the intrinsic problem. Learning requires inefficiency. Constraint is a driver of Creativity. So we should ask as much constraint as possible when solving a problem. We are forced to take a choice and move on. Design is imagining (potential solution) and embrace constraints, create additional if not enough restrictive. It is optimistic, be positive and imagine a lot. Design is about making decisions. The value conveyed is in decisions made. Performing is preparing (planning). We should practice and study. Develop sensibilities you can apply on the fly (pattern, techniques to know what works and what not). Design is about take things apart in order to be able to pull them back together. Design like Bartok (communication very well at multiple levels). Code like Coltrane (preparedness and experience, by doing multiple things and not the same thing over and over). Choose tools that are like instruments (stable, simple and oriented at one thing and around people who know how to use them). They should express a fundamental idea (excitation for instruments). Try to pursue harmony in the design.","title":"Design, Composition and Performance [2013]"},{"location":"decks/clojure/#see-also-generated","text":"Applied Clojure CLI Arguments Clojure for the brave and the true core.async David Nolen edn and transit Home for ideas for my Zettelkasten Life In Dynamic Typing Mastering Clojure Macro Multiple Environment Org-roam-clj: Org-roam extension with Clojure Quotes shadow-cljs Simple Made Easy specs Why Clojure?","title":"See also (generated)"}]}