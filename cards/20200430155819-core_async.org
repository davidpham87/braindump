#+TITLE: core.async
#+OPTIONS: toc:nil
#+ROAM_ALIAS: core.async concurrency
#+TAGS: clj concurrency

* core.async

- tags :: clojure asynchronous CSP

** Problems

- Function chains make poor machines
- Real world concurrency is exposed via callback API.

** core.async in Use

- Source :: [[https://www.youtube.com/watch?v=096pIlA3GDo][core.async in use]]

- Transducers are really important for using core.async.


- Use transducers as much as possible in channels and go block to avoid side
  effect.
- Make sure to return the channels.
- Disadvantage: async code pollutes the return type, problem with error
  handling, channels are IO and hence have side effects. It introduces
  non-determinism in the code.

- Don't use async, unless required.
- Pattern fetch and them conj all the result in a callback.

- A good api for library creators is to ask the user to take the result of the
  asynchronous code as a callback.
- Make a framework where the asynchronicity is set as an implemented
  detail. Remove it from the interface (user or API). You need to contains the
  asynchronicity and hide it from the business perspective. This yields,
  testable data, explicit data.
- Reifying is the act of taking virtual and making it concrete. Intangible to
  tangible. The interceptors (=enter=, =exit=, =on-error=).
- Dataflow and FRP.  Nodes are connected via communication channels, each nodes
  takes and emits from on or more inputs/outputs, each node consists of a
  function that computes outputs ased on inputs. The advantage is that it
  Separates transformation from communication and connection. It is
  functionally pure, async code is removed from the user interface, connections
  are explicit, and any connections can be used.
- Actor, connections are implicit, sending message inside user code, opqare
  state hidden in loop local.

*** Pattern in Pattern

- Keep user space code pure;
- Move the complexity of async out of the user space;
- Make dependencies/connections between modules/components explicit (the system
  can introspect itself). It increase leverage;
- Leverage this for easier testing;
- Use core.async to enable cleaner abstractions, not as aned in itself.


** Link

- [[https://clojure.org/news/2013/06/28/clojure-clore-async-channels][Announcement]]
- [[https://www.youtube.com/watch?v=9HspeHGBg-Q][Rich Hickey on core.async]]
- [[https://www.youtube.com/watch?v=096pIlA3GDo][core.async in use]]


** See also (generated)

- [[file:20200430155637-applied_clojure.org][Applied Clojure]]
- [[file:../decks/clojure.org][Clojure]]
- [[file:20200430160432-clojure_for_the_brave_and_the_true.org][Clojure for the brave and the true]]
- [[file:../README.org][Home for ideas for my Zettelkasten]]
- [[file:20200430155438-mastering_clojure_macro.org][Mastering Clojure Macro]]
- [[file:../todo.org][TODO]]

